(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors"],{

/***/ "./node_modules/@webcomponents/custom-elements/src/native-shim.js":
/*!************************************************************************!*\
  !*** ./node_modules/@webcomponents/custom-elements/src/native-shim.js ***!
  \************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n(function () {\n  if ( // No Reflect, no classes, no need for shim because native custom elements\n  // require ES2015 classes or Reflect.\n  window.Reflect === undefined || window.customElements === undefined || // The webcomponentsjs custom elements polyfill doesn't require\n  // ES2015-compatible construction (`super()` or `Reflect.construct`).\n  window.customElements.polyfillWrapFlushCallback) {\n    return;\n  }\n\n  var BuiltInHTMLElement = HTMLElement;\n\n  window.HTMLElement =\n  /** @this {!Object} */\n  function HTMLElement() {\n    return Reflect.construct(BuiltInHTMLElement, [],\n    /** @type {!Function} */\n    this.constructor);\n  };\n\n  HTMLElement.prototype = BuiltInHTMLElement.prototype;\n  HTMLElement.prototype.constructor = HTMLElement;\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9uYXRpdmUtc2hpbS5qcz9iMzU2Il0sIm5hbWVzIjpbIndpbmRvdyIsIlJlZmxlY3QiLCJ1bmRlZmluZWQiLCJjdXN0b21FbGVtZW50cyIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJCdWlsdEluSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImNvbnN0cnVjdCIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBVUE7Ozs7OztBQU1BLENBQUMsWUFBVztBQUNWLE9BQ0U7QUFDQTtBQUNBQSxRQUFNLENBQUNDLE9BQVAsS0FBbUJDLFNBQW5CLElBQ0FGLE1BQU0sQ0FBQ0csY0FBUCxLQUEwQkQsU0FEMUIsSUFFQTtBQUNBO0FBQ0FGLFFBQU0sQ0FBQ0csY0FBUCxDQUFzQkMseUJBUHhCLEVBUUU7QUFDQTtBQUNEOztBQUNELE1BQU1DLGtCQUFrQixHQUFHQyxXQUEzQjs7QUFDQU4sUUFBTSxDQUFDTSxXQUFQO0FBQXFCO0FBQXVCLFdBQVNBLFdBQVQsR0FBdUI7QUFDakUsV0FBT0wsT0FBTyxDQUFDTSxTQUFSLENBQ0hGLGtCQURHLEVBQ2lCLEVBRGpCO0FBQ3FCO0FBQTBCLFNBQUtHLFdBRHBELENBQVA7QUFFRCxHQUhEOztBQUlBRixhQUFXLENBQUNHLFNBQVosR0FBd0JKLGtCQUFrQixDQUFDSSxTQUEzQztBQUNBSCxhQUFXLENBQUNHLFNBQVosQ0FBc0JELFdBQXRCLEdBQW9DRixXQUFwQztBQUNBSSxRQUFNLENBQUNDLGNBQVAsQ0FBc0JMLFdBQXRCLEVBQW1DRCxrQkFBbkM7QUFDRCxDQXBCRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMvc3JjL25hdGl2ZS1zaGltLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbi8qKlxuICogVGhpcyBzaGltIGFsbG93cyBlbGVtZW50cyB3cml0dGVuIGluLCBvciBjb21waWxlZCB0bywgRVM1IHRvIHdvcmsgb24gbmF0aXZlXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgQ3VzdG9tIEVsZW1lbnRzIHYxLiBJdCBzZXRzIG5ldy50YXJnZXQgdG8gdGhlIHZhbHVlIG9mXG4gKiB0aGlzLmNvbnN0cnVjdG9yIHNvIHRoYXQgdGhlIG5hdGl2ZSBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciBjYW4gYWNjZXNzIHRoZVxuICogY3VycmVudCB1bmRlci1jb25zdHJ1Y3Rpb24gZWxlbWVudCdzIGRlZmluaXRpb24uXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgaWYgKFxuICAgIC8vIE5vIFJlZmxlY3QsIG5vIGNsYXNzZXMsIG5vIG5lZWQgZm9yIHNoaW0gYmVjYXVzZSBuYXRpdmUgY3VzdG9tIGVsZW1lbnRzXG4gICAgLy8gcmVxdWlyZSBFUzIwMTUgY2xhc3NlcyBvciBSZWZsZWN0LlxuICAgIHdpbmRvdy5SZWZsZWN0ID09PSB1bmRlZmluZWQgfHxcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgIC8vIFRoZSB3ZWJjb21wb25lbnRzanMgY3VzdG9tIGVsZW1lbnRzIHBvbHlmaWxsIGRvZXNuJ3QgcmVxdWlyZVxuICAgIC8vIEVTMjAxNS1jb21wYXRpYmxlIGNvbnN0cnVjdGlvbiAoYHN1cGVyKClgIG9yIGBSZWZsZWN0LmNvbnN0cnVjdGApLlxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBCdWlsdEluSFRNTEVsZW1lbnQgPSBIVE1MRWxlbWVudDtcbiAgd2luZG93LkhUTUxFbGVtZW50ID0gLyoqIEB0aGlzIHshT2JqZWN0fSAqLyBmdW5jdGlvbiBIVE1MRWxlbWVudCgpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoXG4gICAgICAgIEJ1aWx0SW5IVE1MRWxlbWVudCwgW10sIC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyAodGhpcy5jb25zdHJ1Y3RvcikpO1xuICB9O1xuICBIVE1MRWxlbWVudC5wcm90b3R5cGUgPSBCdWlsdEluSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuICBIVE1MRWxlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MRWxlbWVudDtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEhUTUxFbGVtZW50LCBCdWlsdEluSFRNTEVsZW1lbnQpO1xufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@webcomponents/custom-elements/src/native-shim.js\n");

/***/ }),

/***/ "./node_modules/@webcomponents/shadydom/src/shadydom.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@webcomponents/shadydom/src/shadydom.js + 28 modules ***!
  \***************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shady-data.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nvar ShadyData =\n/*#__PURE__*/\nfunction () {\n  function ShadyData() {\n    _classCallCheck(this, ShadyData);\n  }\n\n  _createClass(ShadyData, [{\n    key: \"toJSON\",\n\n    /** @override */\n    value: function toJSON() {\n      return {};\n    }\n  }]);\n\n  return ShadyData;\n}();\nfunction ensureShadyDataForNode(node) {\n  if (!node.__shady) {\n    node.__shady = new ShadyData();\n  }\n\n  return node.__shady;\n}\nfunction shadyDataForNode(node) {\n  return node && node.__shady;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/utils.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/** @type {!Object} */\n\nvar settings = window['ShadyDOM'] || {};\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\nvar desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');\nsettings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);\nsettings.inUse = settings['force'] || !settings.hasNativeShadowDOM;\nsettings.noPatch = settings['noPatch'] || false;\nsettings.preferPerformance = settings['preferPerformance'];\nvar IS_IE = navigator.userAgent.match('Trident');\nsettings.IS_IE = IS_IE;\nvar canUpgrade = function canUpgrade() {\n  return !settings.IS_IE;\n};\nvar utils_isTrackingLogicalChildNodes = function isTrackingLogicalChildNodes(node) {\n  var nodeData = shadyDataForNode(node);\n  return nodeData && nodeData.firstChild !== undefined;\n};\nvar utils_isShadyRoot = function isShadyRoot(obj) {\n  return Boolean(obj._localName === 'ShadyRoot');\n};\nvar utils_hasShadowRootWithSlot = function hasShadowRootWithSlot(node) {\n  var nodeData = shadyDataForNode(node);\n  var root = nodeData && nodeData.root;\n  return root && root._hasInsertionPoint();\n};\nvar utils_p = Element.prototype;\nvar matches = utils_p.matches || utils_p.matchesSelector || utils_p.mozMatchesSelector || utils_p.msMatchesSelector || utils_p.oMatchesSelector || utils_p.webkitMatchesSelector;\nvar matchesSelector = function matchesSelector(element, selector) {\n  return matches.call(element, selector);\n};\nvar mixin = function mixin(target, source) {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n\n  return target;\n}; // NOTE, prefer MutationObserver over Promise for microtask timing\n// for consistency x-platform.\n\nvar twiddle = document.createTextNode('');\nvar utils_content = 0;\nvar queue = [];\nnew MutationObserver(function () {\n  while (queue.length) {\n    // catch errors in user code...\n    try {\n      queue.shift()();\n    } catch (e) {\n      // enqueue another record and throw\n      twiddle.textContent = utils_content++;\n      throw e;\n    }\n  }\n}).observe(twiddle, {\n  characterData: true\n}); // use MutationObserver to get microtask async timing.\n\nvar microtask = function microtask(callback) {\n  queue.push(callback);\n  twiddle.textContent = utils_content++;\n};\nvar hasDocumentContains = Boolean(document.contains);\nvar utils_contains = function contains(container, node) {\n  while (node) {\n    if (node == container) {\n      return true;\n    }\n\n    node = node[SHADY_PREFIX + 'parentNode'];\n  }\n\n  return false;\n};\n\nvar getNodeHTMLCollectionName = function getNodeHTMLCollectionName(node) {\n  return node.getAttribute('id') || node.getAttribute('name');\n};\n\nvar isValidHTMLCollectionName = function isValidHTMLCollectionName(name) {\n  return name !== 'length' && isNaN(name);\n};\n\nvar createPolyfilledHTMLCollection = function createPolyfilledHTMLCollection(nodes) {\n  // Note: loop in reverse so that the first named item matches the named property\n  for (var l = nodes.length - 1; l >= 0; l--) {\n    var node = nodes[l];\n    var name = getNodeHTMLCollectionName(node);\n\n    if (name && isValidHTMLCollectionName(name)) {\n      nodes[name] = node;\n    }\n  }\n\n  nodes.item = function (index) {\n    return nodes[index];\n  };\n\n  nodes.namedItem = function (name) {\n    if (isValidHTMLCollectionName(name) && nodes[name]) {\n      return nodes[name];\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _node = _step.value;\n        var nodeName = getNodeHTMLCollectionName(_node);\n\n        if (nodeName == name) {\n          return _node;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return nodes;\n};\nvar NATIVE_PREFIX = '__shady_native_';\nvar SHADY_PREFIX = '__shady_';\nvar nativeChildNodesArray = function nativeChildNodesArray(parent) {\n  var result = [];\n\n  for (var n = parent[NATIVE_PREFIX + 'firstChild']; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n    result.push(n);\n  }\n\n  return result;\n};\nvar childNodesArray = function childNodesArray(parent) {\n  var result = [];\n\n  for (var n = parent[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n    result.push(n);\n  }\n\n  return result;\n};\n/**\n * Patch a group of accessors on an object only if it exists or if the `force`\n * argument is true.\n * @param {!Object} proto\n * @param {!Object} descriptors\n * @param {string=} prefix\n * @param {Array=} disallowedPatches\n */\n\nvar patchProperties = function patchProperties(proto, descriptors) {\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var disallowedPatches = arguments.length > 3 ? arguments[3] : undefined;\n\n  for (var _p in descriptors) {\n    var newDescriptor = descriptors[_p];\n\n    if (disallowedPatches && disallowedPatches.indexOf(_p) >= 0) {\n      continue;\n    }\n\n    newDescriptor.configurable = true;\n    var name = prefix + _p; // NOTE: we prefer writing directly because some browsers\n    // have descriptors that are writable but not configurable (e.g.\n    // `appendChild` on older browsers)\n\n    if (newDescriptor.value) {\n      proto[name] = newDescriptor.value;\n    } else {\n      // NOTE: this can throw if 'force' is used so catch the error.\n      try {\n        Object.defineProperty(proto, name, newDescriptor);\n      } catch (e) {// this error is harmless so we just trap it.\n      }\n    }\n  }\n};\n/** @type {!function(new:HTMLElement)} */\n\nvar NativeHTMLElement = window['customElements'] && window['customElements']['nativeHTMLElement'] || HTMLElement; // note, this is not a perfect polyfill since it doesn't include symbols\n\n/** @return {!Object<!ObjectPropertyDescriptor>} */\n\nvar getOwnPropertyDescriptors = function getOwnPropertyDescriptors(obj) {\n  var descriptors = {};\n  Object.getOwnPropertyNames(obj).forEach(function (name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n  });\n  return descriptors;\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/flush.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n // render enqueuer/flusher\n\nvar flushList = [];\nvar scheduled;\nfunction enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    microtask(flush);\n  }\n\n  flushList.push(callback);\n}\nfunction flush() {\n  scheduled = false;\n  var didFlush = Boolean(flushList.length);\n\n  while (flushList.length) {\n    flushList.shift()();\n  }\n\n  return didFlush;\n}\nflush['list'] = flushList;\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/observe-changes.js\nfunction observe_changes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction observe_changes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction observe_changes_createClass(Constructor, protoProps, staticProps) { if (protoProps) observe_changes_defineProperties(Constructor.prototype, protoProps); if (staticProps) observe_changes_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar observe_changes_AsyncObserver =\n/*#__PURE__*/\nfunction () {\n  function AsyncObserver() {\n    observe_changes_classCallCheck(this, AsyncObserver);\n\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  observe_changes_createClass(AsyncObserver, [{\n    key: \"schedule\",\n    value: function schedule() {\n      var _this = this;\n\n      if (!this._scheduled) {\n        this._scheduled = true;\n        microtask(function () {\n          _this.flush();\n        });\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._scheduled) {\n        this._scheduled = false;\n        var mutations = this.takeRecords();\n\n        if (mutations.length) {\n          this.callbacks.forEach(function (cb) {\n            cb(mutations);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"takeRecords\",\n    value: function takeRecords() {\n      if (this.addedNodes.length || this.removedNodes.length) {\n        var mutations = [{\n          addedNodes: this.addedNodes,\n          removedNodes: this.removedNodes\n        }];\n        this.addedNodes = [];\n        this.removedNodes = [];\n        return mutations;\n      }\n\n      return [];\n    }\n  }]);\n\n  return AsyncObserver;\n}(); // TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\n\n\nvar observe_changes_observeChildren = function observeChildren(node, callback) {\n  var sd = ensureShadyDataForNode(node);\n\n  if (!sd.observer) {\n    sd.observer = new observe_changes_AsyncObserver();\n  }\n\n  sd.observer.callbacks.add(callback);\n  var observer = sd.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords: function takeRecords() {\n      return observer.takeRecords();\n    }\n  };\n};\nvar observe_changes_unobserveChildren = function unobserveChildren(handle) {\n  var observer = handle && handle._observer;\n\n  if (observer) {\n    observer.callbacks[\"delete\"](handle._callback);\n\n    if (!observer.callbacks.size) {\n      ensureShadyDataForNode(handle._node).observer = null;\n    }\n  }\n};\nfunction filterMutations(mutations, target) {\n  /** @const {Node} */\n  var targetRootNode = target.getRootNode();\n  return mutations.map(function (mutation) {\n    /** @const {boolean} */\n    var mutationInScope = targetRootNode === mutation.target.getRootNode();\n\n    if (mutationInScope && mutation.addedNodes) {\n      var nodes = Array.from(mutation.addedNodes).filter(function (n) {\n        return targetRootNode === n.getRootNode();\n      });\n\n      if (nodes.length) {\n        mutation = Object.create(mutation);\n        Object.defineProperty(mutation, 'addedNodes', {\n          value: nodes,\n          configurable: true\n        });\n        return mutation;\n      }\n    } else if (mutationInScope) {\n      return mutation;\n    }\n  }).filter(function (m) {\n    return m;\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/innerHTML.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n\n    case '<':\n      return '&lt;';\n\n    case '>':\n      return '&gt;';\n\n    case '\"':\n      return '&quot;';\n\n    case \"\\xA0\":\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  var set = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n\n  return set;\n} // http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\n\nvar voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\nvar plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @param {Function=} callback\n */\n\nfunction getOuterHTML(node, parentNode, callback) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      {\n        var tagName = node.localName;\n        var s = '<' + tagName;\n        var attrs = node.attributes;\n\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n\n        s += '>';\n\n        if (voidElements[tagName]) {\n          return s;\n        }\n\n        return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n      }\n\n    case Node.TEXT_NODE:\n      {\n        var data =\n        /** @type {Text} */\n        node.data;\n\n        if (parentNode && plaintextParents[parentNode.localName]) {\n          return data;\n        }\n\n        return escapeData(data);\n      }\n\n    case Node.COMMENT_NODE:\n      {\n        return '<!--' +\n        /** @type {Comment} */\n        node.data + '-->';\n      }\n\n    default:\n      {\n        window.console.error(node);\n        throw new Error('not implemented');\n      }\n  }\n}\n/**\n * @param {Node} node\n * @param {Function=} callback\n */\n\nfunction getInnerHTML(node, callback) {\n  if (node.localName === 'template') {\n    node =\n    /** @type {HTMLTemplateElement} */\n    node.content;\n  }\n\n  var s = '';\n  var c$ = callback ? callback(node) : node.childNodes;\n\n  for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\n    s += getOuterHTML(child, node, callback);\n  }\n\n  return s;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-native.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar hasDescriptors = settings.hasDescriptors;\nvar patch_native_NATIVE_PREFIX = NATIVE_PREFIX; // Object on which raw native methods are stored.\n// e.g. `nativeMethods.querySelector.call(node, selector)`\n// same as `node.querySelector(selector)`\n\nvar nativeMethods = {\n  /** @this {Element} */\n  querySelector: function querySelector(selector) {\n    return this[patch_native_NATIVE_PREFIX + 'querySelector'](selector);\n  },\n\n  /** @this {Element} */\n  querySelectorAll: function querySelectorAll(selector) {\n    return this[patch_native_NATIVE_PREFIX + 'querySelectorAll'](selector);\n  }\n}; // Object on which raw native accessors are available via `accessorName(node)`.\n// e.g. `nativeTree.firstChild(node)`\n// same as `node.firstChild`\n\nvar nativeTree = {};\n\nvar installNativeAccessor = function installNativeAccessor(name) {\n  nativeTree[name] = function (node) {\n    return node[patch_native_NATIVE_PREFIX + name];\n  };\n};\n\nvar installNativeMethod = function installNativeMethod(name, fn) {\n  if (!nativeMethods[name]) {\n    nativeMethods[name] = fn;\n  }\n};\n\nvar patch_native_defineNativeAccessors = function defineNativeAccessors(proto, descriptors) {\n  patchProperties(proto, descriptors, patch_native_NATIVE_PREFIX); // make native accessors available to users\n\n  for (var prop in descriptors) {\n    installNativeAccessor(prop);\n  }\n};\n\nvar copyProperties = function copyProperties(proto) {\n  var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  for (var i = 0; i < list.length; i++) {\n    var name = list[i];\n    var descriptor = Object.getOwnPropertyDescriptor(proto, name);\n\n    if (descriptor) {\n      Object.defineProperty(proto, patch_native_NATIVE_PREFIX + name, descriptor); // make native methods/accessors available to users\n\n      if (descriptor.value) {\n        installNativeMethod(name, descriptor.value);\n      } else {\n        installNativeAccessor(name);\n      }\n    }\n  }\n};\n/** @type {!TreeWalker} */\n\n\nvar nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\n/** @type {!TreeWalker} */\n\nvar elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);\n/** @type {!Document} */\n\nvar inertDoc = document.implementation.createHTMLDocument('inert');\n\nvar clearNode = function clearNode(node) {\n  var firstChild;\n\n  while (firstChild = node[patch_native_NATIVE_PREFIX + 'firstChild']) {\n    node[patch_native_NATIVE_PREFIX + 'removeChild'](firstChild);\n  }\n};\n\nvar ParentNodeAccessors = ['firstElementChild', 'lastElementChild', 'children', 'childElementCount'];\nvar ParentNodeMethods = ['querySelector', 'querySelectorAll' // 'append', 'prepend'\n];\nvar patch_native_addNativePrefixedProperties = function addNativePrefixedProperties() {\n  // EventTarget\n  var eventProps = ['dispatchEvent', 'addEventListener', 'removeEventListener'];\n\n  if (window.EventTarget) {\n    copyProperties(window.EventTarget.prototype, eventProps);\n  } else {\n    copyProperties(Node.prototype, eventProps);\n    copyProperties(Window.prototype, eventProps);\n  } // Node\n\n\n  if (hasDescriptors) {\n    copyProperties(Node.prototype, ['parentNode', 'firstChild', 'lastChild', 'previousSibling', 'nextSibling', 'childNodes', 'parentElement', 'textContent']);\n  } else {\n    patch_native_defineNativeAccessors(Node.prototype, {\n      parentNode: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.parentNode();\n        }\n      },\n      firstChild: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.firstChild();\n        }\n      },\n      lastChild: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.lastChild();\n        }\n      },\n      previousSibling: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.previousSibling();\n        }\n      },\n      nextSibling: {\n        /** @this {Node} */\n        get: function get() {\n          nodeWalker.currentNode = this;\n          return nodeWalker.nextSibling();\n        }\n      },\n      // TODO(sorvell): make this a NodeList or whatever\n      childNodes: {\n        /** @this {Node} */\n        get: function get() {\n          var nodes = [];\n          nodeWalker.currentNode = this;\n          var n = nodeWalker.firstChild();\n\n          while (n) {\n            nodes.push(n);\n            n = nodeWalker.nextSibling();\n          }\n\n          return nodes;\n        }\n      },\n      parentElement: {\n        /** @this {Node} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.parentNode();\n        }\n      },\n      textContent: {\n        /** @this {Node} */\n        get: function get() {\n          /* eslint-disable no-case-declarations */\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              // TODO(sorvell): This cannot be a single TreeWalker that's reused\n              // at least for Safari 9, but it's unclear why.\n              var textWalker = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, false);\n              var content = '',\n                  n;\n\n              while (n = textWalker.nextNode()) {\n                // TODO(sorvell): can't use textContent since we patch it on Node.prototype!\n                // However, should probably patch it only on element.\n                content += n.nodeValue;\n              }\n\n              return content;\n\n            default:\n              return this.nodeValue;\n          }\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n\n        /** @this {Node} */\n        set: function set(value) {\n          if (typeof value === 'undefined' || value === null) {\n            value = '';\n          }\n\n          switch (this.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n              clearNode(this); // Document fragments must have no childnodes if setting a blank string\n\n              if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n                // Note: old Chrome versions require 2nd argument here\n                this[patch_native_NATIVE_PREFIX + 'insertBefore'](document.createTextNode(value), undefined);\n              }\n\n              break;\n\n            default:\n              // TODO(sorvell): can't do this if patch nodeValue.\n              this.nodeValue = value;\n              break;\n          }\n        }\n      }\n    });\n  }\n\n  copyProperties(Node.prototype, ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'cloneNode', 'contains']); // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement\n\n  copyProperties(HTMLElement.prototype, ['parentElement', 'contains']);\n  var ParentNodeWalkerDescriptors = {\n    firstElementChild: {\n      /** @this {ParentNode} */\n      get: function get() {\n        elementWalker.currentNode = this;\n        return elementWalker.firstChild();\n      }\n    },\n    lastElementChild: {\n      /** @this {ParentNode} */\n      get: function get() {\n        elementWalker.currentNode = this;\n        return elementWalker.lastChild();\n      }\n    },\n    children: {\n      /** @this {ParentNode} */\n      get: function get() {\n        var nodes = [];\n        elementWalker.currentNode = this;\n        var n = elementWalker.firstChild();\n\n        while (n) {\n          nodes.push(n);\n          n = elementWalker.nextSibling();\n        }\n\n        return createPolyfilledHTMLCollection(nodes);\n      }\n    },\n    childElementCount: {\n      /** @this {ParentNode} */\n      get: function get() {\n        if (this.children) {\n          return this.children.length;\n        }\n\n        return 0;\n      }\n    }\n  }; // Element\n\n  if (hasDescriptors) {\n    copyProperties(Element.prototype, ParentNodeAccessors);\n    copyProperties(Element.prototype, ['previousElementSibling', 'nextElementSibling', 'innerHTML', 'className']); // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement\n\n    copyProperties(HTMLElement.prototype, ['children', 'innerHTML', 'className']);\n  } else {\n    patch_native_defineNativeAccessors(Element.prototype, ParentNodeWalkerDescriptors);\n    patch_native_defineNativeAccessors(Element.prototype, {\n      previousElementSibling: {\n        /** @this {Element} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.previousSibling();\n        }\n      },\n      nextElementSibling: {\n        /** @this {Element} */\n        get: function get() {\n          elementWalker.currentNode = this;\n          return elementWalker.nextSibling();\n        }\n      },\n      innerHTML: {\n        /** @this {Element} */\n        get: function get() {\n          return getInnerHTML(this, nativeChildNodesArray);\n        },\n        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)\n\n        /** @this {Element} */\n        set: function set(value) {\n          var content = this.localName === 'template' ?\n          /** @type {HTMLTemplateElement} */\n          this.content : this;\n          clearNode(content);\n          var containerName = this.localName || 'div';\n          var htmlContainer;\n\n          if (!this.namespaceURI || this.namespaceURI === inertDoc.namespaceURI) {\n            htmlContainer = inertDoc.createElement(containerName);\n          } else {\n            htmlContainer = inertDoc.createElementNS(this.namespaceURI, containerName);\n          }\n\n          htmlContainer.innerHTML = value;\n          var newContent = this.localName === 'template' ?\n          /** @type {HTMLTemplateElement} */\n          htmlContainer.content : htmlContainer;\n          var firstChild;\n\n          while (firstChild = newContent[patch_native_NATIVE_PREFIX + 'firstChild']) {\n            // Note: old Chrome versions require 2nd argument here\n            content[patch_native_NATIVE_PREFIX + 'insertBefore'](firstChild, undefined);\n          }\n        }\n      },\n      className: {\n        /** @this {Element} */\n        get: function get() {\n          return this.getAttribute('class') || '';\n        },\n\n        /** @this {Element} */\n        set: function set(value) {\n          this.setAttribute('class', value);\n        }\n      }\n    });\n  }\n\n  copyProperties(Element.prototype, ['setAttribute', 'getAttribute', 'hasAttribute', 'removeAttribute', // on older Safari, these are on Element.\n  'focus', 'blur']);\n  copyProperties(Element.prototype, ParentNodeMethods); // HTMLElement\n\n  copyProperties(HTMLElement.prototype, ['focus', 'blur']); // HTMLTemplateElement\n\n  if (window.HTMLTemplateElement) {\n    copyProperties(window.HTMLTemplateElement.prototype, ['innerHTML']);\n  } // DocumentFragment\n\n\n  if (hasDescriptors) {\n    // NOTE, IE 11 does not have on DocumentFragment\n    // firstElementChild\n    // lastElementChild\n    copyProperties(DocumentFragment.prototype, ParentNodeAccessors);\n  } else {\n    patch_native_defineNativeAccessors(DocumentFragment.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(DocumentFragment.prototype, ParentNodeMethods); // Document\n\n  if (hasDescriptors) {\n    copyProperties(Document.prototype, ParentNodeAccessors);\n    copyProperties(Document.prototype, ['activeElement']);\n  } else {\n    patch_native_defineNativeAccessors(Document.prototype, ParentNodeWalkerDescriptors);\n  }\n\n  copyProperties(Document.prototype, ['importNode', 'getElementById']);\n  copyProperties(Document.prototype, ParentNodeMethods);\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-instances.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar InsideDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get childNodes() {\n    return this[SHADY_PREFIX + 'childNodes'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    return this[SHADY_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    return this[SHADY_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get childElementCount() {\n    return this[SHADY_PREFIX + 'childElementCount'];\n  },\n\n  /** @this {Node} */\n  get children() {\n    return this[SHADY_PREFIX + 'children'];\n  },\n\n  /** @this {Node} */\n  get firstElementChild() {\n    return this[SHADY_PREFIX + 'firstElementChild'];\n  },\n\n  /** @this {Node} */\n  get lastElementChild() {\n    return this[SHADY_PREFIX + 'lastElementChild'];\n  },\n\n  /** @this {Node} */\n  get shadowRoot() {\n    return this[SHADY_PREFIX + 'shadowRoot'];\n  }\n\n});\nvar TextContentInnerHTMLDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get textContent() {\n    return this[SHADY_PREFIX + 'textContent'];\n  },\n\n  /** @this {Node} */\n  set textContent(value) {\n    this[SHADY_PREFIX + 'textContent'] = value;\n  },\n\n  /** @this {Node} */\n  get innerHTML() {\n    return this[SHADY_PREFIX + 'innerHTML'];\n  },\n\n  /** @this {Node} */\n  set innerHTML(value) {\n    return this[SHADY_PREFIX + 'innerHTML'] = value;\n  }\n\n});\nvar OutsideDescriptors = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentElement() {\n    return this[SHADY_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get parentNode() {\n    return this[SHADY_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    return this[SHADY_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    return this[SHADY_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get nextElementSibling() {\n    return this[SHADY_PREFIX + 'nextElementSibling'];\n  },\n\n  /** @this {Node} */\n  get previousElementSibling() {\n    return this[SHADY_PREFIX + 'previousElementSibling'];\n  },\n\n  /** @this {Node} */\n  get className() {\n    return this[SHADY_PREFIX + 'className'];\n  },\n\n  /** @this {Node} */\n  set className(value) {\n    return this[SHADY_PREFIX + 'className'] = value;\n  }\n\n});\n\nfor (var patch_instances_prop in InsideDescriptors) {\n  InsideDescriptors[patch_instances_prop].enumerable = false;\n}\n\nfor (var _prop in TextContentInnerHTMLDescriptors) {\n  TextContentInnerHTMLDescriptors[_prop].enumerable = false;\n}\n\nfor (var _prop2 in OutsideDescriptors) {\n  OutsideDescriptors[_prop2].enumerable = false;\n}\n\nvar noInstancePatching = settings.hasDescriptors || settings.noPatch; // ensure an element has patched \"outside\" accessors; no-op when not needed\n\nvar patchOutsideElementAccessors = noInstancePatching ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__outsideAccessors) {\n    sd.__outsideAccessors = true;\n    patchProperties(element, OutsideDescriptors);\n  }\n}; // ensure an element has patched \"inside\" accessors; no-op when not needed\n\nvar patchInsideElementAccessors = noInstancePatching ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__insideAccessors) {\n    sd.__insideAccessors = true;\n    patchProperties(element, InsideDescriptors); // NOTE: There are compatibility issues with patches for `textContent`\n    // and `innerHTML` between CE and SD. Since SD patches are applied\n    // via `ShadyDOM.patch` and CE patches are applied as the tree is walked,\n    // SD patches overwrite CE patches.\n    // * When SD is in patching mode, SD calls through to native\n    // methods not patched by CE (since SD is at the bottom) and CE does not\n    // upgrade, connect, or disconnect elements. Therefore do *not patch*\n    // these accessors in this case.\n    // * When SD is in `noPatch` mode, the SD patches call through to\n    // \"native\" methods that are patched by CE (since CE is at the bottom).\n    // Therefore continue to patch in this case.\n    // If customElements is not loaded, then these accessors should be\n    // patched so they work correctly.\n\n    if (!window['customElements'] || settings.noPatch) {\n      patchProperties(element, TextContentInnerHTMLDescriptors);\n    }\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-events.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/*\nMake this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`\nhttps://github.com/webcomponents/shadydom/issues/173\n*/\n\nvar\n/** string */\neventWrappersName = \"__eventWrappers\".concat(Date.now());\n/** @type {?function(!Event): boolean} */\n\nvar composedGetter = function () {\n  var composedProp = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');\n  return composedProp ? function (ev) {\n    return composedProp.get.call(ev);\n  } : null;\n}();\n\nvar supportsEventOptions = function () {\n  var supported = false;\n  var eventOptions = {\n    get capture() {\n      supported = true;\n    }\n\n  };\n\n  var listener = function listener() {}; // NOTE: These will be unpatched at this point.\n\n\n  window.addEventListener('test', listener, eventOptions);\n  window.removeEventListener('test', listener, eventOptions);\n  return supported;\n}();\n\nvar parseEventOptions = function parseEventOptions(optionsOrCapture) {\n  var capture, once, passive, shadyTarget;\n\n  if (optionsOrCapture && _typeof(optionsOrCapture) === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n    shadyTarget = optionsOrCapture.__shadyTarget;\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n\n  return {\n    shadyTarget: shadyTarget,\n    capture: capture,\n    once: once,\n    passive: passive,\n    nativeEventOptions: supportsEventOptions ? optionsOrCapture : capture\n  };\n}; // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\n\nvar alwaysComposed = {\n  'blur': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'click': true,\n  'dblclick': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'wheel': true,\n  'beforeinput': true,\n  'input': true,\n  'keydown': true,\n  'keyup': true,\n  'compositionstart': true,\n  'compositionupdate': true,\n  'compositionend': true,\n  'touchstart': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchcancel': true,\n  'pointerover': true,\n  'pointerenter': true,\n  'pointerdown': true,\n  'pointermove': true,\n  'pointerup': true,\n  'pointercancel': true,\n  'pointerout': true,\n  'pointerleave': true,\n  'gotpointercapture': true,\n  'lostpointercapture': true,\n  'dragstart': true,\n  'drag': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'drop': true,\n  'dragend': true,\n  'DOMActivate': true,\n  'DOMFocusIn': true,\n  'DOMFocusOut': true,\n  'keypress': true\n};\nvar unpatchedEvents = {\n  'DOMAttrModified': true,\n  'DOMAttributeNameChanged': true,\n  'DOMCharacterDataModified': true,\n  'DOMElementNameChanged': true,\n  'DOMNodeInserted': true,\n  'DOMNodeInsertedIntoDocument': true,\n  'DOMNodeRemoved': true,\n  'DOMNodeRemovedFromDocument': true,\n  'DOMSubtreeModified': true\n  /**\n   * Some EventTarget subclasses are not Node subclasses, and you cannot call\n   * `getRootNode()` on them.\n   *\n   * @param {!(Node|EventTarget)} eventTarget\n   * @return {!(Node|EventTarget)}\n   */\n\n};\n\nfunction getRootNodeWithFallback(eventTarget) {\n  if (eventTarget instanceof Node) {\n    return eventTarget[SHADY_PREFIX + 'getRootNode']();\n  } else {\n    return eventTarget;\n  }\n}\n\nfunction pathComposer(startNode, composed) {\n  var composedPath = [];\n  var current = startNode;\n  var startRoot = getRootNodeWithFallback(startNode);\n\n  while (current) {\n    composedPath.push(current);\n\n    if (current[SHADY_PREFIX + 'assignedSlot']) {\n      current = current[SHADY_PREFIX + 'assignedSlot'];\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n      current = current.host;\n    } else {\n      current = current[SHADY_PREFIX + 'parentNode'];\n    }\n  } // event composedPath includes window when startNode's ownerRoot is document\n\n\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n\n  return composedPath;\n}\n\nvar patch_events_composedPath = function composedPath(event) {\n  if (!event.__composedPath) {\n    event.__composedPath = pathComposer(event.target, true);\n  }\n\n  return event.__composedPath;\n};\n\nfunction retarget(refNode, path) {\n  if (!utils_isShadyRoot) {\n    return refNode;\n  } // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n\n\n  var refNodePath = pathComposer(refNode, true);\n  var p$ = path;\n\n  for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = getRootNodeWithFallback(ancestor);\n\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n\n    if (!utils_isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nvar EventPatches = {\n  /**\n   * @this {Event}\n   */\n  get composed() {\n    if (this.__composed === undefined) {\n      // if there's an original `composed` getter on the Event prototype, use that\n      if (composedGetter) {\n        // TODO(web-padawan): see https://github.com/webcomponents/shadydom/issues/275\n        this.__composed = this.type === 'focusin' || this.type === 'focusout' || composedGetter(this); // If the event is trusted, or `isTrusted` is not supported, check the list of always composed events\n      } else if (this.isTrusted !== false) {\n        this.__composed = alwaysComposed[this.type];\n      }\n    }\n\n    return (\n      /** @type {!Event} */\n      this.__composed || false\n    );\n  },\n\n  /**\n   * @this {Event}\n   */\n  composedPath: function composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this['__target'], this.composed);\n    }\n\n    return (\n      /** @type {!Event} */\n      this.__composedPath\n    );\n  },\n\n  /**\n   * @this {Event}\n   */\n  get target() {\n    return retarget(this.currentTarget || this['__previousCurrentTarget'], this.composedPath());\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\n  /**\n   * @this {Event}\n   */\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n    } // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\n\n    return retarget(this.currentTarget || this['__previousCurrentTarget'],\n    /** @type {!Event} */\n    this.__relatedTargetComposedPath);\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopPropagation: function stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  }\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  var klazz = function klazz(type, options) {\n    var event = new Base(type, options);\n    event.__composed = options && Boolean(options['composed']);\n    return event;\n  }; // put constructor properties on subclass\n\n\n  klazz.__proto__ = Base;\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nvar nonBubblingEventsToRetarget = {\n  'focus': true,\n  'blur': true\n};\n/**\n * Check if the event has been retargeted by comparing original `target`, and calculated `target`\n * @param {Event} event\n * @return {boolean} True if the original target and calculated target are the same\n */\n\nfunction hasRetargeted(event) {\n  return event['__target'] !== event.target || event.__relatedTarget !== event.relatedTarget;\n}\n/**\n *\n * @param {Event} event\n * @param {Node} node\n * @param {string} phase\n */\n\n\nfunction fireHandlers(event, node, phase) {\n  var hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];\n\n  if (hs) {\n    for (var i = 0, fn; fn = hs[i]; i++) {\n      if (hasRetargeted(event) && event.target === event.relatedTarget) {\n        return;\n      }\n\n      fn.call(node, event);\n\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction retargetNonBubblingEvent(e) {\n  var path = e.composedPath();\n  var node; // override `currentTarget` to let patched `target` calculate correctly\n\n  Object.defineProperty(e, 'currentTarget', {\n    get: function get() {\n      return node;\n    },\n    configurable: true\n  });\n\n  for (var i = path.length - 1; i >= 0; i--) {\n    node = path[i]; // capture phase fires all capture handlers\n\n    fireHandlers(e, node, 'capture');\n\n    if (e.__propagationStopped) {\n      return;\n    }\n  } // set the event phase to `AT_TARGET` as in spec\n\n\n  Object.defineProperty(e, 'eventPhase', {\n    get: function get() {\n      return Event.AT_TARGET;\n    }\n  }); // the event only needs to be fired when owner roots change when iterating the event path\n  // keep track of the last seen owner root\n\n  var lastFiredRoot;\n\n  for (var _i = 0; _i < path.length; _i++) {\n    node = path[_i];\n    var nodeData = shadyDataForNode(node);\n    var root = nodeData && nodeData.root;\n\n    if (_i === 0 || root && root === lastFiredRoot) {\n      fireHandlers(e, node, 'bubble'); // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\n      if (node !== window) {\n        lastFiredRoot = node[SHADY_PREFIX + 'getRootNode']();\n      }\n\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction listenerSettingsEqual(savedListener, node, type, capture, once, passive) {\n  var savedNode = savedListener.node,\n      savedType = savedListener.type,\n      savedCapture = savedListener.capture,\n      savedOnce = savedListener.once,\n      savedPassive = savedListener.passive;\n  return node === savedNode && type === savedType && capture === savedCapture && once === savedOnce && passive === savedPassive;\n}\n\nfunction findListener(wrappers, node, type, capture, once, passive) {\n  for (var i = 0; i < wrappers.length; i++) {\n    if (listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run\n * Try/Catch accessing eventWrappers to work around\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074\n */\n\nfunction getEventWrappers(eventLike) {\n  var wrappers = null;\n\n  try {\n    wrappers = eventLike[eventWrappersName];\n  } catch (e) {} // eslint-disable-line no-empty\n\n\n  return wrappers;\n}\n\nfunction targetNeedsPathCheck(node) {\n  return utils_isShadyRoot(node) || node.localName === 'slot';\n}\n/**\n * @this {EventTarget}\n */\n\n\nfunction patch_events_addEventListener(type, fnOrObj, optionsOrCapture) {\n  var _parseEventOptions = parseEventOptions(optionsOrCapture),\n      capture = _parseEventOptions.capture,\n      once = _parseEventOptions.once,\n      passive = _parseEventOptions.passive,\n      shadyTarget = _parseEventOptions.shadyTarget,\n      nativeEventOptions = _parseEventOptions.nativeEventOptions;\n\n  if (!fnOrObj) {\n    return;\n  }\n\n  var handlerType = _typeof(fnOrObj); // bail if `fnOrObj` is not a function, not an object\n\n\n  if (handlerType !== 'function' && handlerType !== 'object') {\n    return;\n  } // bail if `fnOrObj` is an object without a `handleEvent` method\n\n\n  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {\n    return;\n  }\n\n  if (unpatchedEvents[type]) {\n    return this[NATIVE_PREFIX + 'addEventListener'](type, fnOrObj, nativeEventOptions);\n  } // hack to let ShadyRoots have event listeners\n  // event listener will be on host, but `currentTarget`\n  // will be set to shadyroot for event listener\n\n\n  var target = shadyTarget || this;\n  var wrappers = fnOrObj[eventWrappersName];\n\n  if (wrappers) {\n    // The callback `fn` might be used for multiple nodes/events. Since we generate\n    // a wrapper function, we need to keep track of it when we remove the listener.\n    // It's more efficient to store the node/type/options information as Array in\n    // `fn` itself rather than the node (we assume that the same callback is used\n    // for few nodes at most, whereas a node will likely have many event listeners).\n    // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n    // Stop if the wrapper function has already been created.\n    if (findListener(wrappers, target, type, capture, once, passive) > -1) {\n      return;\n    }\n  } else {\n    fnOrObj[eventWrappersName] = [];\n  }\n  /**\n   * @this {HTMLElement}\n   * @param {Event} e\n   */\n\n\n  var wrapperFn = function wrapperFn(e) {\n    // Support `once` option.\n    if (once) {\n      this[SHADY_PREFIX + 'removeEventListener'](type, fnOrObj, optionsOrCapture);\n    }\n\n    if (!e['__target']) {\n      patchEvent(e);\n    }\n\n    var lastCurrentTargetDesc;\n\n    if (target !== this) {\n      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot\n      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(e, 'currentTarget');\n      Object.defineProperty(e, 'currentTarget', {\n        get: function get() {\n          return target;\n        },\n        configurable: true\n      });\n    }\n\n    e['__previousCurrentTarget'] = e['currentTarget']; // Always check if a shadowRoot or slot is in the current event path.\n    // If it is not, the event was generated on either the host of the shadowRoot\n    // or a children of the host.\n\n    if (targetNeedsPathCheck(target) && e.composedPath().indexOf(target) == -1) {\n      return;\n    } // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\n\n    if (e.composed || e.composedPath().indexOf(target) > -1) {\n      if (hasRetargeted(e) && e.target === e.relatedTarget) {\n        if (e.eventPhase === Event.BUBBLING_PHASE) {\n          e.stopImmediatePropagation();\n        }\n\n        return;\n      } // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase\n\n\n      if (e.eventPhase !== Event.CAPTURING_PHASE && !e.bubbles && e.target !== target && !(target instanceof Window)) {\n        return;\n      }\n\n      var ret = handlerType === 'function' ? fnOrObj.call(target, e) : fnOrObj.handleEvent && fnOrObj.handleEvent(e);\n\n      if (target !== this) {\n        // replace the \"correct\" `currentTarget`\n        if (lastCurrentTargetDesc) {\n          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);\n          lastCurrentTargetDesc = null;\n        } else {\n          delete e['currentTarget'];\n        }\n      }\n\n      return ret;\n    }\n  }; // Store the wrapper information.\n\n\n  fnOrObj[eventWrappersName].push({\n    // note: use target here which is either a shadowRoot\n    // (when the host element is proxy'ing the event) or this element\n    node: target,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn\n  });\n\n  if (nonBubblingEventsToRetarget[type]) {\n    this.__handlers = this.__handlers || {};\n    this.__handlers[type] = this.__handlers[type] || {\n      'capture': [],\n      'bubble': []\n    };\n\n    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n  } else {\n    this[NATIVE_PREFIX + 'addEventListener'](type, wrapperFn, nativeEventOptions);\n  }\n}\n/**\n * @this {EventTarget}\n */\n\nfunction patch_events_removeEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  var _parseEventOptions2 = parseEventOptions(optionsOrCapture),\n      capture = _parseEventOptions2.capture,\n      once = _parseEventOptions2.once,\n      passive = _parseEventOptions2.passive,\n      shadyTarget = _parseEventOptions2.shadyTarget,\n      nativeEventOptions = _parseEventOptions2.nativeEventOptions;\n\n  if (unpatchedEvents[type]) {\n    return this[NATIVE_PREFIX + 'removeEventListener'](type, fnOrObj, nativeEventOptions);\n  }\n\n  var target = shadyTarget || this; // Search the wrapped function.\n\n  var wrapperFn = undefined;\n  var wrappers = getEventWrappers(fnOrObj);\n\n  if (wrappers) {\n    var idx = findListener(wrappers, target, type, capture, once, passive);\n\n    if (idx > -1) {\n      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn; // Cleanup.\n\n      if (!wrappers.length) {\n        fnOrObj[eventWrappersName] = undefined;\n      }\n    }\n  }\n\n  this[NATIVE_PREFIX + 'removeEventListener'](type, wrapperFn || fnOrObj, nativeEventOptions);\n\n  if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {\n    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\n    var _idx = arr.indexOf(wrapperFn);\n\n    if (_idx > -1) {\n      arr.splice(_idx, 1);\n    }\n  }\n}\n\nfunction activateFocusEventOverrides() {\n  for (var ev in nonBubblingEventsToRetarget) {\n    window[NATIVE_PREFIX + 'addEventListener'](ev, function (e) {\n      if (!e['__target']) {\n        patchEvent(e);\n        retargetNonBubblingEvent(e);\n      }\n    }, true);\n  }\n}\n\nvar EventPatchesDescriptors = getOwnPropertyDescriptors(EventPatches);\nvar SHADY_PROTO = '__shady_patchedProto';\nvar SHADY_SOURCE_PROTO = '__shady_sourceProto';\n\nfunction patchEvent(event) {\n  event['__target'] = event.target;\n  event.__relatedTarget = event.relatedTarget; // attempt to patch prototype (via cache)\n\n  if (settings.hasDescriptors) {\n    var proto = Object.getPrototypeOf(event);\n\n    if (!Object.hasOwnProperty(proto, SHADY_PROTO)) {\n      var patchedProto = Object.create(proto);\n      patchedProto[SHADY_SOURCE_PROTO] = proto;\n      patchProperties(patchedProto, EventPatchesDescriptors);\n      proto[SHADY_PROTO] = patchedProto;\n    }\n\n    event.__proto__ = proto[SHADY_PROTO]; // and fallback to patching instance\n  } else {\n    patchProperties(event, EventPatchesDescriptors);\n  }\n}\n\nvar PatchedEvent = mixinComposedFlag(Event);\nvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\nvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\nfunction patchEvents() {\n  activateFocusEventOverrides();\n  window.Event = PatchedEvent;\n  window.CustomEvent = PatchedCustomEvent;\n  window.MouseEvent = PatchedMouseEvent;\n}\nfunction patchClick() {\n  // Fix up `Element.prototype.click()` if `isTrusted` is supported, but `composed` isn't\n  if (!composedGetter && Object.getOwnPropertyDescriptor(Event.prototype, 'isTrusted')) {\n    /** @this {Element} */\n    var composedClickFn = function composedClickFn() {\n      var ev = new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      this[SHADY_PREFIX + 'dispatchEvent'](ev);\n    };\n\n    if (Element.prototype.click) {\n      Element.prototype.click = composedClickFn;\n    } else if (HTMLElement.prototype.click) {\n      HTMLElement.prototype.click = composedClickFn;\n    }\n  }\n}\nvar eventPropertyNames = Object.getOwnPropertyNames(Document.prototype).filter(function (name) {\n  return name.substring(0, 2) === 'on';\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/array-splice.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  var rowCount = oldEnd - oldStart + 1;\n  var columnCount = currentEnd - currentStart + 1;\n  var distances = new Array(rowCount); // \"Addition\" rows. Initialize null column.\n\n  for (var i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (var j = 0; j < columnCount; j++) {\n    distances[0][j] = j;\n  }\n\n  for (var _i = 1; _i < rowCount; _i++) {\n    for (var _j = 1; _j < columnCount; _j++) {\n      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {\n        var north = distances[_i - 1][_j] + 1;\n        var west = distances[_i][_j - 1] + 1;\n        distances[_i][_j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  var i = distances.length - 1;\n  var j = distances[0].length - 1;\n  var current = distances[i][j];\n  var edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    var northWest = distances[i - 1][j - 1];\n    var west = distances[i - 1][j];\n    var north = distances[i][j - 1];\n    var min = void 0;\n    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\n\n\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  var prefixCount = 0;\n  var suffixCount = 0;\n  var splice;\n  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n\n  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  splice = undefined;\n  var splices = [];\n  var index = currentStart;\n  var oldIndex = oldStart;\n\n  for (var i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (var i = 0; i < searchLength; i++) {\n    if (!equals(current[i], old[i])) return i;\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  var index1 = current.length;\n  var index2 = old.length;\n  var count = 0;\n\n  while (count < searchLength && equals(current[--index1], old[--index2])) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\nfunction calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/link-nodes.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\nfunction linkNode(node, container, containerData, ref_node) {\n  patchOutsideElementAccessors(node);\n  ref_node = ref_node || null;\n  var nodeData = ensureShadyDataForNode(node);\n  var ref_nodeData = ref_node ? ensureShadyDataForNode(ref_node) : null; // update ref_node.previousSibling <-> node\n\n  nodeData.previousSibling = ref_node ? ref_nodeData.previousSibling : container[SHADY_PREFIX + 'lastChild'];\n  var psd = shadyDataForNode(nodeData.previousSibling);\n\n  if (psd) {\n    psd.nextSibling = node;\n  } // update node <-> ref_node\n\n\n  var nsd = shadyDataForNode(nodeData.nextSibling = ref_node);\n\n  if (nsd) {\n    nsd.previousSibling = node;\n  } // update node <-> container\n\n\n  nodeData.parentNode = container;\n\n  if (ref_node) {\n    if (ref_node === containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } else {\n    containerData.lastChild = node;\n\n    if (!containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } // remove caching of childNodes\n\n\n  containerData.childNodes = null;\n}\n\nvar link_nodes_recordInsertBefore = function recordInsertBefore(node, container, ref_node) {\n  patchInsideElementAccessors(container);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (containerData.firstChild !== undefined) {\n    containerData.childNodes = null;\n  } // handle document fragments\n\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // Note, documentFragments should not have logical DOM so there's\n    // no need update that. It is possible to append a ShadowRoot, but we're\n    // choosing not to support that.\n    var first = node[NATIVE_PREFIX + 'firstChild'];\n\n    for (var n = first; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n      linkNode(n, container, containerData, ref_node);\n    }\n  } else {\n    linkNode(node, container, containerData, ref_node);\n  }\n};\nvar link_nodes_recordRemoveChild = function recordRemoveChild(node, container) {\n  var nodeData = ensureShadyDataForNode(node);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (node === containerData.firstChild) {\n    containerData.firstChild = nodeData.nextSibling;\n  }\n\n  if (node === containerData.lastChild) {\n    containerData.lastChild = nodeData.previousSibling;\n  }\n\n  var p = nodeData.previousSibling;\n  var n = nodeData.nextSibling;\n\n  if (p) {\n    ensureShadyDataForNode(p).nextSibling = n;\n  }\n\n  if (n) {\n    ensureShadyDataForNode(n).previousSibling = p;\n  } // When an element is removed, logical data is no longer tracked.\n  // Explicitly set `undefined` here to indicate this. This is disginguished\n  // from `null` which is set if info is null.\n\n\n  nodeData.parentNode = nodeData.previousSibling = nodeData.nextSibling = undefined;\n\n  if (containerData.childNodes !== undefined) {\n    // remove caching of childNodes\n    containerData.childNodes = null;\n  }\n};\n/**\n * @param  {!Node|DocumentFragment} node\n * @param  {!Node|DocumentFragment=} adoptedParent\n */\n\nvar link_nodes_recordChildNodes = function recordChildNodes(node, adoptedParent) {\n  var nodeData = ensureShadyDataForNode(node);\n\n  if (!adoptedParent && nodeData.firstChild !== undefined) {\n    return;\n  } // remove caching of childNodes\n\n\n  nodeData.childNodes = null;\n  var first = nodeData.firstChild = node[NATIVE_PREFIX + 'firstChild'];\n  nodeData.lastChild = node[NATIVE_PREFIX + 'lastChild'];\n  patchInsideElementAccessors(node);\n\n  for (var n = first, previous; n; n = n[NATIVE_PREFIX + 'nextSibling']) {\n    var sd = ensureShadyDataForNode(n);\n    sd.parentNode = adoptedParent || node;\n    sd.nextSibling = n[NATIVE_PREFIX + 'nextSibling'];\n    sd.previousSibling = previous || null;\n    previous = n;\n    patchOutsideElementAccessors(n);\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/style-scoping.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar style_scoping_scopingShim = null;\nfunction getScopingShim() {\n  if (!style_scoping_scopingShim) {\n    style_scoping_scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];\n  }\n\n  return style_scoping_scopingShim || null;\n}\n/**\n * @param {!Node} node\n * @param {string} attr\n * @param {string} value\n */\n\nfunction scopeClassAttribute(node, attr, value) {\n  var scopingShim = getScopingShim();\n\n  if (scopingShim && attr === 'class') {\n    scopingShim['setElementClass'](node, value);\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n */\n\nfunction addShadyScoping(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['scopeNode'](node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} currentScopeName\n */\n\nfunction removeShadyScoping(node, currentScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['unscopeNode'](node, currentScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @param {string} oldScopeName\n */\n\nfunction replaceShadyScoping(node, newScopeName, oldScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  if (oldScopeName) {\n    removeShadyScoping(node, oldScopeName);\n  }\n\n  addShadyScoping(node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @return {boolean}\n */\n\nfunction currentScopeIsCorrect(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return true;\n  }\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // NOTE: as an optimization, only check that all the top-level children\n    // have the correct scope.\n    var correctScope = true;\n\n    for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n      correctScope = correctScope && currentScopeIsCorrect(n, newScopeName);\n    }\n\n    return correctScope;\n  }\n\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n\n  var currentScope = scopingShim['currentScopeForNode'](node);\n  return currentScope === newScopeName;\n}\n/**\n * @param {!Node} node\n * @return {string}\n */\n\nfunction currentScopeForNode(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return '';\n  }\n\n  return scopingShim['currentScopeForNode'](node);\n}\n/**\n * Walk over a node's tree and apply visitorFn to each element node\n *\n * @param {Node} node\n * @param {function(!Node):void} visitorFn\n */\n\nfunction treeVisitor(node, visitorFn) {\n  if (!node) {\n    return;\n  } // this check is necessary if `node` is a Document Fragment\n\n\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    visitorFn(node);\n  }\n\n  for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      treeVisitor(n, visitorFn);\n    }\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Node.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\nvar doc = window.document;\nvar preferPerformance = settings.preferPerformance;\nvar nativeIsConnectedAccessors =\n/** @type {ObjectPropertyDescriptor} */\nObject.getOwnPropertyDescriptor(Node.prototype, 'isConnected');\nvar nativeIsConnected = nativeIsConnectedAccessors && nativeIsConnectedAccessors.get;\nfunction Node_clearNode(node) {\n  var firstChild;\n\n  while (firstChild = node[SHADY_PREFIX + 'firstChild']) {\n    node[SHADY_PREFIX + 'removeChild'](firstChild);\n  }\n}\n\nfunction removeOwnerShadyRoot(node) {\n  // optimization: only reset the tree if node is actually in a root\n  if (hasCachedOwnerRoot(node)) {\n    for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n      removeOwnerShadyRoot(n);\n    }\n  }\n\n  var nodeData = shadyDataForNode(node);\n\n  if (nodeData) {\n    nodeData.ownerShadyRoot = undefined;\n  }\n}\n\nfunction hasCachedOwnerRoot(node) {\n  var nodeData = shadyDataForNode(node);\n  return Boolean(nodeData && nodeData.ownerShadyRoot !== undefined);\n}\n/**\n * Finds the first flattened node that is composed in the node's parent.\n * If the given node is a slot, then the first flattened node is returned\n * if it exists, otherwise advance to the node's nextSibling.\n * @param {Node} node within which to find first composed node\n * @returns {Node} first composed node\n */\n\n\nfunction firstComposedNode(node) {\n  var composed = node;\n\n  if (node && node.localName === 'slot') {\n    var nodeData = shadyDataForNode(node);\n    var flattened = nodeData && nodeData.flattenedNodes;\n    composed = flattened && flattened.length ? flattened[0] : firstComposedNode(node[SHADY_PREFIX + 'nextSibling']);\n  }\n\n  return composed;\n}\n/**\n * @param {Node} node\n * @param {Node=} addedNode\n * @param {Node=} removedNode\n */\n\n\nfunction scheduleObserver(node, addedNode, removedNode) {\n  var nodeData = shadyDataForNode(node);\n  var observer = nodeData && nodeData.observer;\n\n  if (observer) {\n    if (addedNode) {\n      observer.addedNodes.push(addedNode);\n    }\n\n    if (removedNode) {\n      observer.removedNodes.push(removedNode);\n    }\n\n    observer.schedule();\n  }\n}\n\nvar NodePatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get parentNode() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.parentNode;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentNode'];\n  },\n\n  /** @this {Node} */\n  get firstChild() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.firstChild;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'firstChild'];\n  },\n\n  /** @this {Node} */\n  get lastChild() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.lastChild;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'lastChild'];\n  },\n\n  /** @this {Node} */\n  get nextSibling() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.nextSibling;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'nextSibling'];\n  },\n\n  /** @this {Node} */\n  get previousSibling() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.previousSibling;\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'previousSibling'];\n  },\n\n  /** @this {Node} */\n  get childNodes() {\n    var childNodes;\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var nodeData = shadyDataForNode(this);\n\n      if (!nodeData.childNodes) {\n        nodeData.childNodes = [];\n\n        for (var n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n          nodeData.childNodes.push(n);\n        }\n      }\n\n      childNodes = nodeData.childNodes;\n    } else {\n      childNodes = this[NATIVE_PREFIX + 'childNodes'];\n    }\n\n    childNodes.item = function (index) {\n      return childNodes[index];\n    };\n\n    return childNodes;\n  },\n\n  /** @this {Node} */\n  get parentElement() {\n    var nodeData = shadyDataForNode(this);\n    var l = nodeData && nodeData.parentNode;\n\n    if (l && l.nodeType !== Node.ELEMENT_NODE) {\n      l = null;\n    }\n\n    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentElement'];\n  },\n\n  /** @this {Node} */\n  get isConnected() {\n    if (nativeIsConnected && nativeIsConnected.call(this)) {\n      return true;\n    }\n\n    if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n      return false;\n    } // Fast path for distributed nodes.\n\n\n    var ownerDocument = this.ownerDocument;\n\n    if (hasDocumentContains) {\n      if (ownerDocument[NATIVE_PREFIX + 'contains'](this)) {\n        return true;\n      }\n    } else if (ownerDocument.documentElement && ownerDocument.documentElement[NATIVE_PREFIX + 'contains'](this)) {\n      return true;\n    } // Slow path for non-distributed nodes.\n\n\n    var node = this;\n\n    while (node && !(node instanceof Document)) {\n      node = node[SHADY_PREFIX + 'parentNode'] || (utils_isShadyRoot(node) ?\n      /** @type {ShadowRoot} */\n      node.host : undefined);\n    }\n\n    return !!(node && node instanceof Document);\n  },\n\n  /** @this {Node} */\n  get textContent() {\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var tc = [];\n\n      for (var n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        if (n.nodeType !== Node.COMMENT_NODE) {\n          tc.push(n[SHADY_PREFIX + 'textContent']);\n        }\n      }\n\n      return tc.join('');\n    } else {\n      return this[NATIVE_PREFIX + 'textContent'];\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {string} value\n   */\n  set textContent(value) {\n    if (typeof value === 'undefined' || value === null) {\n      value = '';\n    }\n\n    switch (this.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        if (!utils_isTrackingLogicalChildNodes(this) && settings.hasDescriptors) {\n          // may be removing a nested slot but fast path if we know we are not.\n          var firstChild = this[SHADY_PREFIX + 'firstChild'];\n\n          if (firstChild != this[SHADY_PREFIX + 'lastChild'] || firstChild && firstChild.nodeType != Node.TEXT_NODE) {\n            Node_clearNode(this);\n          }\n\n          this[NATIVE_PREFIX + 'textContent'] = value;\n        } else {\n          Node_clearNode(this); // Document fragments must have no childNodes if setting a blank string\n\n          if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n            this[SHADY_PREFIX + 'insertBefore'](document.createTextNode(value));\n          }\n        }\n\n        break;\n\n      default:\n        // Note, be wary of patching `nodeValue`.\n        this.nodeValue = value;\n        break;\n    }\n  },\n\n  // Patched `insertBefore`. Note that all mutations that add nodes are routed\n  // here. When a <slot> is added or a node is added to a host with a shadowRoot\n  // with a slot, a standard dom `insert` call is aborted and `_asyncRender`\n  // is called on the relevant shadowRoot. In all other cases, a standard dom\n  // `insert` can be made, but the location and ref_node may need to be changed.\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  insertBefore: function insertBefore(node, ref_node) {\n    // optimization: assume native insertBefore is ok if the nodes are not in the document.\n    if (this.ownerDocument !== doc && node.ownerDocument !== doc) {\n      this[NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      return node;\n    }\n\n    if (node === this) {\n      throw Error(\"Failed to execute 'appendChild' on 'Node': The new child element contains the parent.\");\n    }\n\n    if (ref_node) {\n      var refData = shadyDataForNode(ref_node);\n      var p = refData && refData.parentNode;\n\n      if (p !== undefined && p !== this || p === undefined && ref_node[NATIVE_PREFIX + 'parentNode'] !== this) {\n        throw Error(\"Failed to execute 'insertBefore' on 'Node': The node \" + \"before which the new node is to be inserted is not a child of this node.\");\n      }\n    }\n\n    if (ref_node === node) {\n      return node;\n    }\n    /** @type {!Array<!HTMLSlotElement>} */\n\n\n    var slotsAdded = [];\n    var ownerRoot = attach_shadow_ownerShadyRootForNode(this);\n    /** @type {string} */\n\n    var newScopeName = ownerRoot ? ownerRoot.host.localName : currentScopeForNode(this);\n    /** @type {string} */\n\n    var oldScopeName; // remove from existing location\n\n    var parentNode = node[SHADY_PREFIX + 'parentNode'];\n\n    if (parentNode) {\n      oldScopeName = currentScopeForNode(node);\n      var skipUnscoping = // Don't remove scoping if we're inserting into another shadowRoot;\n      // this would be unnecessary since it will be re-scoped below\n      Boolean(ownerRoot) || // Don't remove scoping if we're being moved between non-shadowRoot\n      // locations (the likely case is when moving pre-scoped nodes in a template)\n      !attach_shadow_ownerShadyRootForNode(node) || // Under preferPerformance, don't remove scoping when moving back into\n      // a document fragment that was previously scoped; the assumption is\n      // that the user should only move correctly-scoped DOM back into it\n      preferPerformance && this['__noInsertionPoint'] !== undefined;\n      parentNode[SHADY_PREFIX + 'removeChild'](node, skipUnscoping);\n    } // add to new parent\n\n\n    var allowNativeInsert = true;\n    var needsScoping = (!preferPerformance || // Under preferPerformance, only re-scope if we're not coming from a\n    // pre-scoped doc fragment or back into a pre-scoped doc fragment\n    node['__noInsertionPoint'] === undefined && this['__noInsertionPoint'] === undefined) && !currentScopeIsCorrect(node, newScopeName);\n    var needsSlotFinding = ownerRoot && !node['__noInsertionPoint'] && (!preferPerformance || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\n    if (needsSlotFinding || needsScoping) {\n      // NOTE: avoid node.removeChild as this *can* trigger another patched\n      // method (e.g. custom elements) and we want only the shady method to run.\n      // The following table describes what style scoping actions should happen as a result of this insertion.\n      // document -> shadowRoot: replace\n      // shadowRoot -> shadowRoot: replace\n      // shadowRoot -> shadowRoot of same type: do nothing\n      // shadowRoot -> document: allow unscoping\n      // document -> document: do nothing\n      // The \"same type of shadowRoot\" and \"document to document cases rely on `currentScopeIsCorrect` returning true\n      if (needsScoping) {\n        // in a document or disconnected tree, replace scoping if necessary\n        oldScopeName = oldScopeName || currentScopeForNode(node);\n      }\n\n      treeVisitor(node, function (node) {\n        if (needsSlotFinding && node.localName === 'slot') {\n          slotsAdded.push(\n          /** @type {!HTMLSlotElement} */\n          node);\n        }\n\n        if (needsScoping) {\n          replaceShadyScoping(node, newScopeName, oldScopeName);\n        }\n      });\n    } // if a slot is added, must render containing root.\n\n\n    if (slotsAdded.length) {\n      ownerRoot._addSlots(slotsAdded);\n\n      ownerRoot._asyncRender();\n    }\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      link_nodes_recordInsertBefore(node, this, ref_node); // when inserting into a host with a shadowRoot with slot, use\n      // `shadowRoot._asyncRender()` via `attach-shadow` module\n\n      var parentData = shadyDataForNode(this);\n\n      if (utils_hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n\n        allowNativeInsert = false; // when inserting into a host with shadowRoot with NO slot, do nothing\n        // as the node should not be added to composed dome anywhere.\n      } else if (parentData.root) {\n        allowNativeInsert = false;\n      }\n    }\n\n    if (allowNativeInsert) {\n      // if adding to a shadyRoot, add to host instead\n      var container = utils_isShadyRoot(this) ?\n      /** @type {ShadowRoot} */\n      this.host : this; // if ref_node, get the ref_node that's actually in composed dom.\n\n      if (ref_node) {\n        ref_node = firstComposedNode(ref_node);\n        container[NATIVE_PREFIX + 'insertBefore'](node, ref_node);\n      } else {\n        container[NATIVE_PREFIX + 'appendChild'](node);\n      } // Since ownerDocument is not patched, it can be incorrect after this call\n      // if the node is physically appended via distribution. This can result\n      // in the custom elements polyfill not upgrading the node if it's in an inert doc.\n      // We correct this by calling `adoptNode`.\n\n    } else if (node.ownerDocument !== this.ownerDocument) {\n      this.ownerDocument.adoptNode(node);\n    }\n\n    scheduleObserver(this, node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   */\n  appendChild: function appendChild(node) {\n    // if this is a shadowRoot and the shadowRoot is passed as `node`\n    // then an optimized append has already been performed, so do nothing.\n    if (!(this == node && utils_isShadyRoot(node))) {\n      return this[SHADY_PREFIX + 'insertBefore'](node);\n    }\n  },\n\n  /**\n   * Patched `removeChild`. Note that all dom \"removals\" are routed here.\n   * Removes the given `node` from the element's `children`.\n   * This method also performs dom composition.\n   * @this {Node}\n   * @param {Node} node\n   * @param {boolean=} skipUnscoping\n   */\n  removeChild: function removeChild(node) {\n    var skipUnscoping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.ownerDocument !== doc) {\n      return this[NATIVE_PREFIX + 'removeChild'](node);\n    }\n\n    if (node[SHADY_PREFIX + 'parentNode'] !== this) {\n      throw Error('The node to be removed is not a child of this node: ' + node);\n    }\n\n    var preventNativeRemove;\n    var ownerRoot = attach_shadow_ownerShadyRootForNode(node);\n\n    var removingInsertionPoint = ownerRoot && ownerRoot._removeContainedSlots(node);\n\n    var parentData = shadyDataForNode(this);\n\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      link_nodes_recordRemoveChild(node, this);\n\n      if (utils_hasShadowRootWithSlot(this)) {\n        parentData.root._asyncRender();\n\n        preventNativeRemove = true;\n      }\n    } // unscope a node leaving a ShadowRoot if ShadyCSS is present, and this node\n    // is not going to be rescoped in `insertBefore`\n\n\n    if (getScopingShim() && !skipUnscoping && ownerRoot && node.nodeType !== Node.TEXT_NODE) {\n      var oldScopeName = currentScopeForNode(node);\n      treeVisitor(node, function (node) {\n        removeShadyScoping(node, oldScopeName);\n      });\n    }\n\n    removeOwnerShadyRoot(node); // if removing slot, must render containing root\n\n    if (ownerRoot) {\n      var changeSlotContent = this && this.localName === 'slot';\n\n      if (changeSlotContent) {\n        preventNativeRemove = true;\n      }\n\n      if (removingInsertionPoint || changeSlotContent) {\n        ownerRoot._asyncRender();\n      }\n    }\n\n    if (!preventNativeRemove) {\n      // if removing from a shadyRoot, remove from host instead\n      var container = utils_isShadyRoot(this) ?\n      /** @type {ShadowRoot} */\n      this.host : this; // not guaranteed to physically be in container; e.g.\n      // (1) if parent has a shadyRoot, element may or may not at distributed\n      // location (could be undistributed)\n      // (2) if parent is a slot, element may not ben in composed dom\n\n      if (!(parentData.root || node.localName === 'slot') || container === node[NATIVE_PREFIX + 'parentNode']) {\n        container[NATIVE_PREFIX + 'removeChild'](node);\n      }\n    }\n\n    scheduleObserver(this, null, node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {Node} node\n   * @param {Node=} ref_node\n   */\n  replaceChild: function replaceChild(node, ref_node) {\n    this[SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    this[SHADY_PREFIX + 'removeChild'](ref_node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   * @param {boolean=} deep\n   */\n  cloneNode: function cloneNode(deep) {\n    if (this.localName == 'template') {\n      return this[NATIVE_PREFIX + 'cloneNode'](deep);\n    } else {\n      var n = this[NATIVE_PREFIX + 'cloneNode'](false); // Attribute nodes historically had childNodes, but they have later\n      // been removed from the spec.\n      // Make sure we do not do a deep clone on them for old browsers (IE11)\n\n      if (deep && n.nodeType !== Node.ATTRIBUTE_NODE) {\n        for (var c = this[SHADY_PREFIX + 'firstChild'], nc; c; c = c[SHADY_PREFIX + 'nextSibling']) {\n          nc = c[SHADY_PREFIX + 'cloneNode'](true);\n          n[SHADY_PREFIX + 'appendChild'](nc);\n        }\n      }\n\n      return n;\n    }\n  },\n\n  /**\n   * @this {Node}\n   * @param {Object=} options\n   */\n  // TODO(sorvell): implement `options` e.g. `{ composed: boolean }`\n  getRootNode: function getRootNode(options) {\n    // eslint-disable-line no-unused-vars\n    if (!this || !this.nodeType) {\n      return;\n    }\n\n    var nodeData = ensureShadyDataForNode(this);\n    var root = nodeData.ownerShadyRoot;\n\n    if (root === undefined) {\n      if (utils_isShadyRoot(this)) {\n        root = this;\n        nodeData.ownerShadyRoot = root;\n      } else {\n        var parent = this[SHADY_PREFIX + 'parentNode'];\n        root = parent ? parent[SHADY_PREFIX + 'getRootNode'](options) : this; // memo-ize result for performance but only memo-ize\n        // result if node is in the document. This avoids a problem where a root\n        // can be cached while an element is inside a fragment.\n        // If this happens and we cache the result, the value can become stale\n        // because for perf we avoid processing the subtree of added fragments.\n\n        if (document.documentElement[NATIVE_PREFIX + 'contains'](this)) {\n          nodeData.ownerShadyRoot = root;\n        }\n      }\n    }\n\n    return root;\n  },\n\n  /** @this {Node} */\n  contains: function contains(node) {\n    return utils_contains(this, node);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ParentNode.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/**\n * @param {Node} node\n * @param {Function} matcher\n * @param {Function=} halter\n */\n\nfunction query(node, matcher, halter) {\n  var list = [];\n  queryChildNodes(node, matcher, halter, list);\n  return list;\n}\n\nfunction queryChildNodes(parent, matcher, halter, list) {\n  for (var n = parent[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n    if (n.nodeType === Node.ELEMENT_NODE && queryElement(n, matcher, halter, list)) {\n      return true;\n    }\n  }\n}\n\nfunction queryElement(node, matcher, halter, list) {\n  var result = matcher(node);\n\n  if (result) {\n    list.push(node);\n  }\n\n  if (halter && halter(result)) {\n    return result;\n  }\n\n  queryChildNodes(node, matcher, halter, list);\n} // Needed on Element, DocumentFragment, Document\n\n\nvar ParentNodePatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get firstElementChild() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.firstChild !== undefined) {\n      var n = this[SHADY_PREFIX + 'firstChild'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'nextSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'firstElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get lastElementChild() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.lastChild !== undefined) {\n      var n = this[SHADY_PREFIX + 'lastChild'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'previousSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'lastElementChild'];\n    }\n  },\n\n  /** @this {Element} */\n  get children() {\n    if (!utils_isTrackingLogicalChildNodes(this)) {\n      return this[NATIVE_PREFIX + 'children'];\n    }\n\n    return createPolyfilledHTMLCollection(Array.prototype.filter.call(childNodesArray(this), function (n) {\n      return n.nodeType === Node.ELEMENT_NODE;\n    }));\n  },\n\n  /** @this {Element} */\n  get childElementCount() {\n    var children = this[SHADY_PREFIX + 'children'];\n\n    if (children) {\n      return children.length;\n    }\n\n    return 0;\n  }\n\n});\nvar QueryPatches = getOwnPropertyDescriptors({\n  // TODO(sorvell): consider doing native QSA and filtering results.\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   */\n  querySelector: function querySelector(selector) {\n    // match selector and halt on first result.\n    var result = query(this, function (n) {\n      return matchesSelector(n, selector);\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  },\n\n  /**\n   * @this {Element}\n   * @param  {string} selector\n   * @param  {boolean} useNative\n   */\n  // TODO(sorvell): `useNative` option relies on native querySelectorAll and\n  // misses distributed nodes, see\n  // https://github.com/webcomponents/shadydom/pull/210#issuecomment-361435503\n  querySelectorAll: function querySelectorAll(selector, useNative) {\n    if (useNative) {\n      var o = Array.prototype.slice.call(this[NATIVE_PREFIX + 'querySelectorAll'](selector));\n      var root = this[SHADY_PREFIX + 'getRootNode']();\n      return o.filter(function (e) {\n        return e[SHADY_PREFIX + 'getRootNode']() == root;\n      });\n    }\n\n    return query(this, function (n) {\n      return matchesSelector(n, selector);\n    });\n  }\n}); // In preferPerformance mode, create a custom `ParentNodeDocumentOrFragment`\n// that optionally does not mixin querySelector/All; this is a performance\n// optimization. In noPatch, we need to keep the query patches here in order to\n// ensure the query API is available on the wrapper\n\nvar ParentNodeDocumentOrFragmentPatches = settings.preferPerformance && !settings.noPatch ? Object.assign({}, ParentNodePatches) : ParentNodePatches;\nObject.assign(ParentNodePatches, QueryPatches);\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrFragment.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar DocumentOrFragmentPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {Element}\n   * @param {string} id\n   */\n  getElementById: function getElementById(id) {\n    if (id === '') {\n      return null;\n    }\n\n    var result = query(this, function (n) {\n      return n.id == id;\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrShadowRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nfunction getDocumentActiveElement() {\n  if (settings.hasDescriptors) {\n    return document[NATIVE_PREFIX + 'activeElement'];\n  } else {\n    return document.activeElement;\n  }\n}\n\nvar DocumentOrShadowRootPatches = getOwnPropertyDescriptors({\n  /** @this {Document|ShadowRoot} */\n  get activeElement() {\n    var active = getDocumentActiveElement(); // In IE11, activeElement might be an empty object if the document is\n    // contained in an iframe.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/\n\n    if (!active || !active.nodeType) {\n      return null;\n    }\n\n    var isShadyRoot = !!utils_isShadyRoot(this);\n\n    if (this !== document) {\n      // If this node isn't a document or shady root, then it doesn't have\n      // an active element.\n      if (!isShadyRoot) {\n        return null;\n      } // If this shady root's host is the active element or the active\n      // element is not a descendant of the host (in the composed tree),\n      // then it doesn't have an active element.\n\n\n      if (this.host === active || !this.host[NATIVE_PREFIX + 'contains'](active)) {\n        return null;\n      }\n    } // This node is either the document or a shady root of which the active\n    // element is a (composed) descendant of its host; iterate upwards to\n    // find the active element's most shallow host within it.\n\n\n    var activeRoot = attach_shadow_ownerShadyRootForNode(active);\n\n    while (activeRoot && activeRoot !== this) {\n      active = activeRoot.host;\n      activeRoot = attach_shadow_ownerShadyRootForNode(active);\n    }\n\n    if (this === document) {\n      // This node is the document, so activeRoot should be null.\n      return activeRoot ? null : active;\n    } else {\n      // This node is a non-document shady root, and it should be\n      // activeRoot.\n      return activeRoot === this ? active : null;\n    }\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ElementOrShadowRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/** @type {!Document} */\n\nvar ElementOrShadowRoot_inertDoc = document.implementation.createHTMLDocument('inert');\nvar ElementOrShadowRootPatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get innerHTML() {\n    if (utils_isTrackingLogicalChildNodes(this)) {\n      var content = this.localName === 'template' ?\n      /** @type {HTMLTemplateElement} */\n      this.content : this;\n      return getInnerHTML(content, childNodesArray);\n    } else {\n      return this[NATIVE_PREFIX + 'innerHTML'];\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set innerHTML(value) {\n    if (this.localName === 'template') {\n      this[NATIVE_PREFIX + 'innerHTML'] = value;\n    } else {\n      Node_clearNode(this);\n      var containerName = this.localName || 'div';\n      var htmlContainer;\n\n      if (!this.namespaceURI || this.namespaceURI === ElementOrShadowRoot_inertDoc.namespaceURI) {\n        htmlContainer = ElementOrShadowRoot_inertDoc.createElement(containerName);\n      } else {\n        htmlContainer = ElementOrShadowRoot_inertDoc.createElementNS(this.namespaceURI, containerName);\n      }\n\n      if (settings.hasDescriptors) {\n        htmlContainer[NATIVE_PREFIX + 'innerHTML'] = value;\n      } else {\n        htmlContainer.innerHTML = value;\n      }\n\n      var firstChild;\n\n      while (firstChild = htmlContainer[SHADY_PREFIX + 'firstChild']) {\n        this[SHADY_PREFIX + 'insertBefore'](firstChild);\n      }\n    }\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ShadowRoot.js\nfunction ShadowRoot_typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { ShadowRoot_typeof = function _typeof(obj) { return typeof obj; }; } else { ShadowRoot_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return ShadowRoot_typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar ShadowRootPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener: function addEventListener(type, fn, optionsOrCapture) {\n    if (ShadowRoot_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    } // Note, `__shadyTarget` may already be set if an event was added on a <slot> child\n\n\n    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;\n    this.host[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);\n  },\n\n  /**\n   * @this {ShadowRoot}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener: function removeEventListener(type, fn, optionsOrCapture) {\n    if (ShadowRoot_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    } // Note, `__shadyTarget` may already be set if an event was added on a <slot> child\n\n\n    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;\n    this.host[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-shadyRoot.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n/**\n * @param {!Object} proto\n * @param {string=} prefix\n */\n\nvar patch_shadyRoot_patchShadyAccessors = function patchShadyAccessors(proto, prefix) {\n  patchProperties(proto, ShadowRootPatches, prefix);\n  patchProperties(proto, DocumentOrShadowRootPatches, prefix);\n  patchProperties(proto, ElementOrShadowRootPatches, prefix); // We ensure ParentNode accessors since these do not exist in Edge/IE on DocumentFragments.\n\n  patchProperties(proto, ParentNodePatches, prefix); // Ensure `shadowRoot` has basic descriptors when we cannot rely\n  // on them coming from DocumentFragment.\n  //\n  // Case 1, noPatching: Because we want noPatch ShadyRoots to have native property\n  // names so that they do not have to be wrapped...\n  // When we do *not* patch Node/DocumentFragment.prototype\n  // we must manually install those properties on ShadyRoot's prototype.\n  // Note, it's important to only install these in this mode so as not to stomp\n  // over CustomElements polyfill's patches on Node/DocumentFragment methods.\n\n  if (settings.noPatch && !prefix) {\n    patchProperties(proto, NodePatches, prefix);\n    patchProperties(proto, DocumentOrFragmentPatches, prefix); // Case 2, bad descriptors: Ensure accessors are on ShadowRoot.\n    // These descriptors are normally used for instance patching but because\n    // ShadyRoot can always be patched, just do it to the prototype.\n  } else if (!settings.hasDescriptors) {\n    patchProperties(proto, OutsideDescriptors);\n    patchProperties(proto, InsideDescriptors);\n    patchProperties(proto, TextContentInnerHTMLDescriptors);\n  }\n};\n\nvar patch_shadyRoot_patchShadyRoot = function patchShadyRoot(proto) {\n  proto.__proto__ = DocumentFragment.prototype; // patch both prefixed and not, even when noPatch == true.\n\n  patch_shadyRoot_patchShadyAccessors(proto, SHADY_PREFIX);\n  patch_shadyRoot_patchShadyAccessors(proto); // Ensure native properties are all safely wrapped since ShadowRoot is not an\n  // actual DocumentFragment instance.\n\n  Object.defineProperties(proto, {\n    nodeType: {\n      value: Node.DOCUMENT_FRAGMENT_NODE,\n      configurable: true\n    },\n    nodeName: {\n      value: '#document-fragment',\n      configurable: true\n    },\n    nodeValue: {\n      value: null,\n      configurable: true\n    }\n  }); // make undefined\n\n  ['localName', 'namespaceURI', 'prefix'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      value: undefined,\n      configurable: true\n    });\n  }); // defer properties to host\n\n  ['ownerDocument', 'baseURI', 'isConnected'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      /** @this {ShadowRoot} */\n      get: function get() {\n        return this.host[prop];\n      },\n      configurable: true\n    });\n  });\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/attach-shadow.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction attach_shadow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction attach_shadow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction attach_shadow_createClass(Constructor, protoProps, staticProps) { if (protoProps) attach_shadow_defineProperties(Constructor.prototype, protoProps); if (staticProps) attach_shadow_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n // Do not export this object. It must be passed as the first argument to the\n// ShadyRoot constructor in `attachShadow` to prevent the constructor from\n// throwing. This prevents the user from being able to manually construct a\n// ShadyRoot (i.e. `new ShadowRoot()`).\n\nvar ShadyRootConstructionToken = {};\nvar CATCHALL_NAME = '__catchall';\nvar SHADYROOT_NAME = 'ShadyRoot';\nvar MODE_CLOSED = 'closed';\nvar isRendering = settings['deferConnectionCallbacks'] && document.readyState === 'loading';\nvar rootRendered;\n\nfunction ancestorList(node) {\n  var ancestors = [];\n\n  do {\n    ancestors.unshift(node);\n  } while (node = node[SHADY_PREFIX + 'parentNode']);\n\n  return ancestors;\n}\n/**\n * @extends {ShadowRoot}\n */\n\n\nvar attach_shadow_ShadyRoot =\n/*#__PURE__*/\nfunction () {\n  function ShadyRoot(token, host, options) {\n    attach_shadow_classCallCheck(this, ShadyRoot);\n\n    if (token !== ShadyRootConstructionToken) {\n      throw new TypeError('Illegal constructor');\n    }\n    /** @type {boolean} */\n\n\n    this._renderPending;\n    /** @type {boolean} */\n\n    this._hasRendered;\n    /** @type {?Array<HTMLSlotElement>} */\n\n    this._slotList = null;\n    /** @type {?Object<string, Array<HTMLSlotElement>>} */\n\n    this._slotMap;\n    /** @type {?Array<HTMLSlotElement>} */\n\n    this._pendingSlots;\n\n    this._init(host, options);\n  }\n\n  attach_shadow_createClass(ShadyRoot, [{\n    key: \"_init\",\n    value: function _init(host, options) {\n      // NOTE: set a fake local name so this element can be\n      // distinguished from a DocumentFragment when patching.\n      // FF doesn't allow this to be `localName`\n\n      /** @type {string} */\n      this._localName = SHADYROOT_NAME; // root <=> host\n\n      this.host = host;\n      /** @type {!string|undefined} */\n\n      this.mode = options && options.mode;\n      link_nodes_recordChildNodes(this.host);\n      var hostData = ensureShadyDataForNode(this.host);\n      /** @type {!ShadyRoot} */\n\n      hostData.root = this;\n      hostData.publicRoot = this.mode !== MODE_CLOSED ? this : null; // setup root\n\n      var rootData = ensureShadyDataForNode(this);\n      rootData.firstChild = rootData.lastChild = rootData.parentNode = rootData.nextSibling = rootData.previousSibling = null; // NOTE: optimization flag, only require an asynchronous render\n      // to record parsed children if flag is not set.\n\n      if (settings['preferPerformance']) {\n        var n;\n\n        while (n = this.host[NATIVE_PREFIX + 'firstChild']) {\n          this.host[NATIVE_PREFIX + 'removeChild'](n);\n        }\n      } else {\n        this._asyncRender();\n      }\n    }\n  }, {\n    key: \"_asyncRender\",\n    value: function _asyncRender() {\n      var _this = this;\n\n      if (!this._renderPending) {\n        this._renderPending = true;\n        enqueue(function () {\n          return _this._render();\n        });\n      }\n    } // returns the oldest renderPending ancestor root.\n\n  }, {\n    key: \"_getPendingDistributionRoot\",\n    value: function _getPendingDistributionRoot() {\n      var renderRoot;\n      var root = this;\n\n      while (root) {\n        if (root._renderPending) {\n          renderRoot = root;\n        }\n\n        root = root._getDistributionParent();\n      }\n\n      return renderRoot;\n    } // Returns the shadyRoot `this.host` if `this.host`\n    // has children that require distribution.\n\n  }, {\n    key: \"_getDistributionParent\",\n    value: function _getDistributionParent() {\n      var root = this.host[SHADY_PREFIX + 'getRootNode']();\n\n      if (!utils_isShadyRoot(root)) {\n        return;\n      }\n\n      var nodeData = shadyDataForNode(this.host);\n\n      if (nodeData && nodeData.__childSlotCount > 0) {\n        return root;\n      }\n    } // Renders the top most render pending shadowRoot in the distribution tree.\n    // This is safe because when a distribution parent renders, all children render.\n\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      // If this root is not pending, it needs no rendering work. Any pending\n      // parent that needs to render wll cause this root to render.\n      var root = this._renderPending && this._getPendingDistributionRoot();\n\n      if (root) {\n        root._renderSelf();\n      }\n    }\n  }, {\n    key: \"_flushInitial\",\n    value: function _flushInitial() {\n      if (!this._hasRendered && this._renderPending) {\n        this._render();\n      }\n    }\n    /** @override */\n\n  }, {\n    key: \"_renderSelf\",\n    value: function _renderSelf() {\n      // track rendering state.\n      var wasRendering = isRendering;\n      isRendering = true;\n      this._renderPending = false;\n\n      if (this._slotList) {\n        this._distribute();\n\n        this._compose();\n      } // NOTE: optimization flag, only process parsed children\n      // if optimization flag is not set.\n      // on initial render remove any undistributed children.\n\n\n      if (!settings['preferPerformance'] && !this._hasRendered) {\n        for (var n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n          var data = shadyDataForNode(n);\n\n          if (n[NATIVE_PREFIX + 'parentNode'] === this.host && (n.localName === 'slot' || !data.assignedSlot)) {\n            this.host[NATIVE_PREFIX + 'removeChild'](n);\n          }\n        }\n      }\n\n      this._hasRendered = true;\n      isRendering = wasRendering;\n\n      if (rootRendered) {\n        rootRendered();\n      }\n    }\n  }, {\n    key: \"_distribute\",\n    value: function _distribute() {\n      this._validateSlots(); // capture # of previously assigned nodes to help determine if dirty.\n\n\n      for (var i = 0, slot; i < this._slotList.length; i++) {\n        slot = this._slotList[i];\n\n        this._clearSlotAssignedNodes(slot);\n      } // distribute host children.\n\n\n      for (var n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        this._distributeNodeToSlot(n);\n      } // fallback content, slotchange, and dirty roots\n\n\n      for (var _i = 0; _i < this._slotList.length; _i++) {\n        var _slot = this._slotList[_i];\n        var slotData = shadyDataForNode(_slot); // distribute fallback content\n\n        if (!slotData.assignedNodes.length) {\n          for (var _n = _slot[SHADY_PREFIX + 'firstChild']; _n; _n = _n[SHADY_PREFIX + 'nextSibling']) {\n            this._distributeNodeToSlot(_n, _slot);\n          }\n        }\n\n        var slotParentData = shadyDataForNode(_slot[SHADY_PREFIX + 'parentNode']);\n        var slotParentRoot = slotParentData && slotParentData.root;\n\n        if (slotParentRoot && (slotParentRoot._hasInsertionPoint() || slotParentRoot._renderPending)) {\n          slotParentRoot._renderSelf();\n        }\n\n        this._addAssignedToFlattenedNodes(slotData.flattenedNodes, slotData.assignedNodes);\n\n        var prevAssignedNodes = slotData._previouslyAssignedNodes;\n\n        if (prevAssignedNodes) {\n          for (var _i2 = 0; _i2 < prevAssignedNodes.length; _i2++) {\n            shadyDataForNode(prevAssignedNodes[_i2])._prevAssignedSlot = null;\n          }\n\n          slotData._previouslyAssignedNodes = null; // dirty if previously less assigned nodes than previously assigned.\n\n          if (prevAssignedNodes.length > slotData.assignedNodes.length) {\n            slotData.dirty = true;\n          }\n        }\n        /* Note: A slot is marked dirty whenever a node is newly assigned to it\n        or a node is assigned to a different slot (done in `_distributeNodeToSlot`)\n        or if the number of nodes assigned to the slot has decreased (done above);\n        */\n\n\n        if (slotData.dirty) {\n          slotData.dirty = false;\n\n          this._fireSlotChange(_slot);\n        }\n      }\n    }\n    /**\n     * Distributes given `node` to the appropriate slot based on its `slot`\n     * attribute. If `forcedSlot` is given, then the node is distributed to the\n     * `forcedSlot`.\n     * Note: slot to which the node is assigned will be marked dirty for firing\n     * `slotchange`.\n     * @param {Node} node\n     * @param {Node=} forcedSlot\n     *\n     */\n\n  }, {\n    key: \"_distributeNodeToSlot\",\n    value: function _distributeNodeToSlot(node, forcedSlot) {\n      var nodeData = ensureShadyDataForNode(node);\n      var oldSlot = nodeData._prevAssignedSlot;\n      nodeData._prevAssignedSlot = null;\n      var slot = forcedSlot;\n\n      if (!slot) {\n        var name = node[SHADY_PREFIX + 'slot'] || CATCHALL_NAME;\n        var list = this._slotMap[name];\n        slot = list && list[0];\n      }\n\n      if (slot) {\n        var slotData = ensureShadyDataForNode(slot);\n        slotData.assignedNodes.push(node);\n        nodeData.assignedSlot = slot;\n      } else {\n        nodeData.assignedSlot = undefined;\n      }\n\n      if (oldSlot !== nodeData.assignedSlot) {\n        if (nodeData.assignedSlot) {\n          ensureShadyDataForNode(nodeData.assignedSlot).dirty = true;\n        }\n      }\n    }\n    /**\n     * Clears the assignedNodes tracking data for a given `slot`. Note, the current\n     * assigned node data is tracked (via _previouslyAssignedNodes and\n     * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out\n     *  of date at this time because the assigned nodes may have already been\n     * distributed to another root. This is ok since this data is only used to\n     * track changes.\n     * @param {HTMLSlotElement} slot\n     */\n\n  }, {\n    key: \"_clearSlotAssignedNodes\",\n    value: function _clearSlotAssignedNodes(slot) {\n      var slotData = shadyDataForNode(slot);\n      var n$ = slotData.assignedNodes;\n      slotData.assignedNodes = [];\n      slotData.flattenedNodes = [];\n      slotData._previouslyAssignedNodes = n$;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var n = shadyDataForNode(n$[i]);\n          n._prevAssignedSlot = n.assignedSlot; // only clear if it was previously set to this slot;\n          // this helps ensure that if the node has otherwise been distributed\n          // ignore it.\n\n          if (n.assignedSlot === slot) {\n            n.assignedSlot = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addAssignedToFlattenedNodes\",\n    value: function _addAssignedToFlattenedNodes(flattened, assigned) {\n      for (var i = 0, n; i < assigned.length && (n = assigned[i]); i++) {\n        if (n.localName == 'slot') {\n          var nestedAssigned = shadyDataForNode(n).assignedNodes;\n\n          if (nestedAssigned && nestedAssigned.length) {\n            this._addAssignedToFlattenedNodes(flattened, nestedAssigned);\n          }\n        } else {\n          flattened.push(assigned[i]);\n        }\n      }\n    }\n  }, {\n    key: \"_fireSlotChange\",\n    value: function _fireSlotChange(slot) {\n      // NOTE: cannot bubble correctly here so not setting bubbles: true\n      // Safari tech preview does not bubble but chrome does\n      // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n      slot[NATIVE_PREFIX + 'dispatchEvent'](new Event('slotchange'));\n      var slotData = shadyDataForNode(slot);\n\n      if (slotData.assignedSlot) {\n        this._fireSlotChange(slotData.assignedSlot);\n      }\n    } // Reify dom such that it is at its correct rendering position\n    // based on logical distribution.\n    // NOTE: here we only compose parents of <slot> elements and not the\n    // shadowRoot into the host. The latter is performend via a fast path\n    // in the `logical-mutation`.insertBefore.\n\n  }, {\n    key: \"_compose\",\n    value: function _compose() {\n      var slots = this._slotList;\n      var composeList = [];\n\n      for (var i = 0; i < slots.length; i++) {\n        var parent = slots[i][SHADY_PREFIX + 'parentNode'];\n        /* compose node only if:\n          (1) parent does not have a shadowRoot since shadowRoot has already\n          composed into the host\n          (2) we're not already composing it\n          [consider (n^2) but rare better than Set]\n        */\n\n        var parentData = shadyDataForNode(parent);\n\n        if (!(parentData && parentData.root) && composeList.indexOf(parent) < 0) {\n          composeList.push(parent);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < composeList.length; _i3++) {\n        var node = composeList[_i3];\n        var targetNode = node === this ? this.host : node;\n\n        this._updateChildNodes(targetNode, this._composeNode(node));\n      }\n    } // Returns the list of nodes which should be rendered inside `node`.\n\n  }, {\n    key: \"_composeNode\",\n    value: function _composeNode(node) {\n      var children = [];\n\n      for (var n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {\n        // Note: if we see a slot here, the nodes are guaranteed to need to be\n        // composed here. This is because if there is redistribution, it has\n        // already been handled by this point.\n        if (this._isInsertionPoint(n)) {\n          var flattenedNodes = shadyDataForNode(n).flattenedNodes;\n\n          for (var j = 0; j < flattenedNodes.length; j++) {\n            var distributedNode = flattenedNodes[j];\n            children.push(distributedNode);\n          }\n        } else {\n          children.push(n);\n        }\n      }\n\n      return children;\n    }\n  }, {\n    key: \"_isInsertionPoint\",\n    value: function _isInsertionPoint(node) {\n      return node.localName == 'slot';\n    } // Ensures that the rendered node list inside `container` is `children`.\n\n  }, {\n    key: \"_updateChildNodes\",\n    value: function _updateChildNodes(container, children) {\n      var composed = nativeChildNodesArray(container);\n      var splices = calculateSplices(children, composed); // process removals\n\n      for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\n        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n          // check if the node is still where we expect it is before trying\n          // to remove it; this can happen if we move a node and\n          // then schedule its previous host for distribution resulting in\n          // the node being removed here.\n          if (n[NATIVE_PREFIX + 'parentNode'] === container) {\n            container[NATIVE_PREFIX + 'removeChild'](n);\n          } // TODO(sorvell): avoid the need for splicing here.\n\n\n          composed.splice(s.index + d, 1);\n        }\n\n        d -= s.addedCount;\n      } // process adds\n\n\n      for (var _i4 = 0, _s, next; _i4 < splices.length && (_s = splices[_i4]); _i4++) {\n        //eslint-disable-line no-redeclare\n        next = composed[_s.index];\n\n        for (var _j = _s.index, _n2; _j < _s.index + _s.addedCount; _j++) {\n          _n2 = children[_j];\n          container[NATIVE_PREFIX + 'insertBefore'](_n2, next);\n          composed.splice(_j, 0, _n2);\n        }\n      }\n    }\n  }, {\n    key: \"_ensureSlotData\",\n    value: function _ensureSlotData() {\n      this._pendingSlots = this._pendingSlots || [];\n      this._slotList = this._slotList || [];\n      this._slotMap = this._slotMap || {};\n    }\n  }, {\n    key: \"_addSlots\",\n    value: function _addSlots(slots) {\n      var _this$_pendingSlots;\n\n      this._ensureSlotData();\n\n      (_this$_pendingSlots = this._pendingSlots).push.apply(_this$_pendingSlots, _toConsumableArray(slots));\n    }\n  }, {\n    key: \"_validateSlots\",\n    value: function _validateSlots() {\n      if (this._pendingSlots && this._pendingSlots.length) {\n        this._mapSlots(this._pendingSlots);\n\n        this._pendingSlots = [];\n      }\n    }\n    /**\n     * Adds the given slots. Slots are maintained in an dom-ordered list.\n     * In addition a map of name to slot is updated.\n     */\n\n  }, {\n    key: \"_mapSlots\",\n    value: function _mapSlots(slots) {\n      var slotNamesToSort;\n\n      for (var i = 0; i < slots.length; i++) {\n        var slot = slots[i]; // ensure insertionPoints's and their parents have logical dom info.\n        // save logical tree info\n        // a. for shadyRoot\n        // b. for insertion points (fallback)\n        // c. for parents of insertion points\n\n        link_nodes_recordChildNodes(slot);\n        var slotParent = slot[SHADY_PREFIX + 'parentNode'];\n        link_nodes_recordChildNodes(slotParent);\n        var slotParentData = shadyDataForNode(slotParent);\n        slotParentData.__childSlotCount = (slotParentData.__childSlotCount || 0) + 1;\n\n        var name = this._nameForSlot(slot);\n\n        if (this._slotMap[name]) {\n          slotNamesToSort = slotNamesToSort || {};\n          slotNamesToSort[name] = true;\n\n          this._slotMap[name].push(slot);\n        } else {\n          this._slotMap[name] = [slot];\n        }\n\n        this._slotList.push(slot);\n      }\n\n      if (slotNamesToSort) {\n        for (var n in slotNamesToSort) {\n          this._slotMap[n] = this._sortSlots(this._slotMap[n]);\n        }\n      }\n    }\n  }, {\n    key: \"_nameForSlot\",\n    value: function _nameForSlot(slot) {\n      var name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;\n      slot.__slotName = name;\n      return name;\n    }\n    /**\n     * Slots are kept in an ordered list. Slots with the same name\n     * are sorted here by tree order.\n     */\n\n  }, {\n    key: \"_sortSlots\",\n    value: function _sortSlots(slots) {\n      // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,\n      // but the code here could be used to polyfill the preceeding/following info\n      // in `compareDocumentPosition`.\n      return slots.sort(function (a, b) {\n        var listA = ancestorList(a);\n        var listB = ancestorList(b);\n\n        for (var i = 0; i < listA.length; i++) {\n          var nA = listA[i];\n          var nB = listB[i];\n\n          if (nA !== nB) {\n            var c$ = childNodesArray(nA[SHADY_PREFIX + 'parentNode']);\n            return c$.indexOf(nA) - c$.indexOf(nB);\n          }\n        }\n      });\n    }\n    /**\n     * Removes from tracked slot data any slots contained within `container` and\n     * then updates the tracked data (_slotList and _slotMap).\n     * Any removed slots also have their `assignedNodes` removed from comopsed dom.\n     */\n\n  }, {\n    key: \"_removeContainedSlots\",\n    value: function _removeContainedSlots(container) {\n      if (!this._slotList) {\n        return;\n      }\n\n      this._validateSlots();\n\n      var didRemove;\n      var map = this._slotMap;\n\n      for (var n in map) {\n        var slots = map[n];\n\n        for (var i = 0; i < slots.length; i++) {\n          var slot = slots[i];\n\n          if (utils_contains(container, slot)) {\n            slots.splice(i, 1);\n\n            var x = this._slotList.indexOf(slot);\n\n            if (x >= 0) {\n              this._slotList.splice(x, 1);\n\n              var slotParentData = shadyDataForNode(slot[SHADY_PREFIX + 'parentNode']);\n\n              if (slotParentData && slotParentData.__childSlotCount) {\n                slotParentData.__childSlotCount--;\n              }\n            }\n\n            i--;\n\n            this._removeFlattenedNodes(slot);\n\n            didRemove = true;\n          }\n        }\n      }\n\n      return didRemove;\n    }\n  }, {\n    key: \"_updateSlotName\",\n    value: function _updateSlotName(slot) {\n      if (!this._slotList) {\n        return;\n      } // make sure slotMap is initialized with this slot\n\n\n      this._validateSlots();\n\n      var oldName = slot.__slotName;\n\n      var name = this._nameForSlot(slot);\n\n      if (name === oldName) {\n        return;\n      } // remove from existing tracking\n\n\n      var slots = this._slotMap[oldName];\n      var i = slots.indexOf(slot);\n\n      if (i >= 0) {\n        slots.splice(i, 1);\n      } // add to new location and sort if nedessary\n\n\n      var list = this._slotMap[name] || (this._slotMap[name] = []);\n      list.push(slot);\n\n      if (list.length > 1) {\n        this._slotMap[name] = this._sortSlots(list);\n      }\n    }\n  }, {\n    key: \"_removeFlattenedNodes\",\n    value: function _removeFlattenedNodes(slot) {\n      var data = shadyDataForNode(slot);\n      var n$ = data.flattenedNodes;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var node = n$[i];\n          var parent = node[NATIVE_PREFIX + 'parentNode'];\n\n          if (parent) {\n            parent[NATIVE_PREFIX + 'removeChild'](node);\n          }\n        }\n      }\n\n      data.flattenedNodes = [];\n      data.assignedNodes = [];\n    }\n  }, {\n    key: \"_hasInsertionPoint\",\n    value: function _hasInsertionPoint() {\n      this._validateSlots();\n\n      return Boolean(this._slotList && this._slotList.length);\n    }\n  }]);\n\n  return ShadyRoot;\n}();\n\npatch_shadyRoot_patchShadyRoot(attach_shadow_ShadyRoot.prototype);\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\n\nvar attach_shadow_attachShadow = function attachShadow(host, options) {\n  if (!host) {\n    throw new Error('Must provide a host.');\n  }\n\n  if (!options) {\n    throw new Error('Not enough arguments.');\n  }\n\n  var root; // Optimization for booting up a shadowRoot from a fragment rather than\n  // creating one.\n\n  if (options['shadyUpgradeFragment'] && canUpgrade()) {\n    root = options['shadyUpgradeFragment'];\n    root.__proto__ = ShadowRoot.prototype;\n\n    root._init(host, options);\n\n    link_nodes_recordChildNodes(root, root); // Note: qsa is native when used with noPatch.\n\n    /** @type {?NodeList<Element>} */\n\n    var slotsAdded = root['__noInsertionPoint'] ? null : root.querySelectorAll('slot'); // Reset scoping information so normal scoing rules apply after this.\n\n    root['__noInsertionPoint'] = undefined; // if a slot is added, must render containing root.\n\n    if (slotsAdded && slotsAdded.length) {\n      root._addSlots(slotsAdded);\n\n      root._asyncRender();\n    }\n    /** @type {ShadowRoot} */\n\n\n    root.host[NATIVE_PREFIX + 'appendChild'](root);\n  } else {\n    root = new attach_shadow_ShadyRoot(ShadyRootConstructionToken, host, options);\n  }\n\n  return root;\n}; // Mitigate connect/disconnect spam by wrapping custom element classes.\n\nif (window['customElements'] && settings.inUse && !settings['preferPerformance']) {\n  // process connect/disconnect after roots have rendered to avoid\n  // issues with reaction stack.\n  var connectMap = new Map();\n\n  rootRendered = function rootRendered() {\n    // allow elements to connect\n    // save map state (without needing polyfills on IE11)\n    var r = [];\n    connectMap.forEach(function (v, k) {\n      r.push([k, v]);\n    });\n    connectMap.clear();\n\n    for (var i = 0; i < r.length; i++) {\n      var e = r[i][0],\n          value = r[i][1];\n\n      if (value) {\n        e['__shadydom_connectedCallback']();\n      } else {\n        e['__shadydom_disconnectedCallback']();\n      }\n    }\n  }; // Document is in loading state and flag is set (deferConnectionCallbacks)\n  // so process connection stack when `readystatechange` fires.\n\n\n  if (isRendering) {\n    document.addEventListener('readystatechange', function () {\n      isRendering = false;\n      rootRendered();\n    }, {\n      once: true\n    });\n  }\n  /*\n   * (1) elements can only be connected/disconnected if they are in the expected\n   * state.\n   * (2) never run connect/disconnect during rendering to avoid reaction stack issues.\n   */\n\n\n  var ManageConnect = function ManageConnect(base, connected, disconnected) {\n    var counter = 0;\n    var connectFlag = \"__isConnected\".concat(counter++);\n\n    if (connected || disconnected) {\n      /** @this {!HTMLElement} */\n      base.prototype.connectedCallback = base.prototype['__shadydom_connectedCallback'] = function () {\n        // if rendering defer connected\n        // otherwise connect only if we haven't already\n        if (isRendering) {\n          connectMap.set(this, true);\n        } else if (!this[connectFlag]) {\n          this[connectFlag] = true;\n\n          if (connected) {\n            connected.call(this);\n          }\n        }\n      };\n      /** @this {!HTMLElement} */\n\n\n      base.prototype.disconnectedCallback = base.prototype['__shadydom_disconnectedCallback'] = function () {\n        // if rendering, cancel a pending connection and queue disconnect,\n        // otherwise disconnect only if a connection has been allowed\n        if (isRendering) {\n          // This is necessary only because calling removeChild\n          // on a node that requires distribution leaves it in the DOM tree\n          // until distribution.\n          // NOTE: remember this is checking the patched isConnected to determine\n          // if the node is in the logical tree.\n          if (!this.isConnected) {\n            connectMap.set(this, false);\n          }\n        } else if (this[connectFlag]) {\n          this[connectFlag] = false;\n\n          if (disconnected) {\n            disconnected.call(this);\n          }\n        }\n      };\n    }\n\n    return base;\n  };\n\n  var originalDefine = window['customElements']['define'];\n\n  var define = function define(name, constructor) {\n    var connected = constructor.prototype.connectedCallback;\n    var disconnected = constructor.prototype.disconnectedCallback;\n    originalDefine.call(window['customElements'], name, ManageConnect(constructor, connected, disconnected)); // unpatch connected/disconnected on class; custom elements tears this off\n    // so the patch is maintained, but if the user calls these methods for\n    // e.g. testing, they will be as expected.\n\n    constructor.prototype.connectedCallback = connected;\n    constructor.prototype.disconnectedCallback = disconnected;\n  }; // Note, it would be better to only patch the CustomElementRegistry.prototype,\n  // but ShadyCSS patches define directly.\n\n\n  window.customElements.define = define; // Still patch the registry directly since Safari 10 loses the patch\n  // unless this is done.\n\n  Object.defineProperty(window['CustomElementRegistry'].prototype, 'define', {\n    value: define,\n    configurable: true\n  });\n}\n/** @return {!ShadyRoot|undefined} */\n\n\nvar attach_shadow_ownerShadyRootForNode = function ownerShadyRootForNode(node) {\n  var root = node[SHADY_PREFIX + 'getRootNode']();\n\n  if (utils_isShadyRoot(root)) {\n    return root;\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/wrapper.js\nfunction wrapper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction wrapper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction wrapper_createClass(Constructor, protoProps, staticProps) { if (protoProps) wrapper_defineProperties(Constructor.prototype, protoProps); if (staticProps) wrapper_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n/** @implements {IWrapper} */\n\nvar wrapper_Wrapper =\n/*#__PURE__*/\nfunction () {\n  /** @param {!Node} node */\n  function Wrapper(node) {\n    wrapper_classCallCheck(this, Wrapper);\n\n    this.node = node;\n  } // node\n\n\n  wrapper_createClass(Wrapper, [{\n    key: \"addEventListener\",\n    value: function addEventListener(name, fn, options) {\n      return this.node[SHADY_PREFIX + 'addEventListener'](name, fn, options);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name, fn, options) {\n      return this.node[SHADY_PREFIX + 'removeEventListener'](name, fn, options);\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      return this.node[SHADY_PREFIX + 'appendChild'](node);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, ref_node) {\n      return this.node[SHADY_PREFIX + 'insertBefore'](node, ref_node);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      return this.node[SHADY_PREFIX + 'removeChild'](node);\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(node, ref_node) {\n      return this.node[SHADY_PREFIX + 'replaceChild'](node, ref_node);\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      return this.node[SHADY_PREFIX + 'cloneNode'](deep);\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode(options) {\n      return this.node[SHADY_PREFIX + 'getRootNode'](options);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      return this.node[SHADY_PREFIX + 'contains'](node);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      return this.node[SHADY_PREFIX + 'dispatchEvent'](event);\n    } // element\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      this.node[SHADY_PREFIX + 'setAttribute'](name, value);\n    } // NOTE: not needed, just here for balance\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      return this.node[NATIVE_PREFIX + 'getAttribute'](name);\n    } // NOTE: not needed, just here for balance\n\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(name) {\n      return this.node[NATIVE_PREFIX + 'hasAttribute'](name);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      this.node[SHADY_PREFIX + 'removeAttribute'](name);\n    }\n  }, {\n    key: \"attachShadow\",\n    value: function attachShadow(options) {\n      return this.node[SHADY_PREFIX + 'attachShadow'](options);\n    }\n    /** @return {!Node|undefined} */\n\n  }, {\n    key: \"focus\",\n    // NOTE: not needed, just here for balance\n\n    /** @override */\n    value: function focus() {\n      this.node[NATIVE_PREFIX + 'focus']();\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.node[SHADY_PREFIX + 'blur']();\n    } // document\n\n  }, {\n    key: \"importNode\",\n    value: function importNode(node, deep) {\n      if (this.node.nodeType === Node.DOCUMENT_NODE) {\n        return this.node[SHADY_PREFIX + 'importNode'](node, deep);\n      }\n    }\n  }, {\n    key: \"getElementById\",\n    value: function getElementById(id) {\n      if (this.node.nodeType === Node.DOCUMENT_NODE) {\n        return this.node[SHADY_PREFIX + 'getElementById'](id);\n      }\n    } // query\n\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(selector) {\n      return this.node[SHADY_PREFIX + 'querySelector'](selector);\n    }\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(selector, useNative) {\n      return this.node[SHADY_PREFIX + 'querySelectorAll'](selector, useNative);\n    } // slot\n\n  }, {\n    key: \"assignedNodes\",\n    value: function assignedNodes(options) {\n      if (this.node.localName === 'slot') {\n        return this.node[SHADY_PREFIX + 'assignedNodes'](options);\n      }\n    }\n  }, {\n    key: \"activeElement\",\n    get: function get() {\n      if (utils_isShadyRoot(this.node) || this.node.nodeType === Node.DOCUMENT_NODE) {\n        var e = this.node[SHADY_PREFIX + 'activeElement'];\n        return e;\n      }\n    }\n    /**\n     * Installed for compatibility with browsers (older Chrome/Safari) that do\n     * not have a configurable `activeElement` accessor. Enables noPatch and\n     * patch mode both to consistently use ShadyDOM.wrap(document)._activeElement.\n     * @override\n     * @return {!Node|undefined}\n     */\n\n  }, {\n    key: \"_activeElement\",\n    get: function get() {\n      return this.activeElement;\n    }\n  }, {\n    key: \"host\",\n    get: function get() {\n      if (utils_isShadyRoot(this.node)) {\n        return (\n          /** @type {!ShadowRoot} */\n          this.node.host\n        );\n      }\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'parentNode'];\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'firstChild'];\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'lastChild'];\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'nextSibling'];\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'previousSibling'];\n    }\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'childNodes'];\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'parentElement'];\n    }\n  }, {\n    key: \"firstElementChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'firstElementChild'];\n    }\n  }, {\n    key: \"lastElementChild\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'lastElementChild'];\n    }\n  }, {\n    key: \"nextElementSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'nextElementSibling'];\n    }\n  }, {\n    key: \"previousElementSibling\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'previousElementSibling'];\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'children'];\n    }\n  }, {\n    key: \"childElementCount\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'childElementCount'];\n    }\n  }, {\n    key: \"shadowRoot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'shadowRoot'];\n    }\n  }, {\n    key: \"assignedSlot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'assignedSlot'];\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'isConnected'];\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'innerHTML'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'innerHTML'] = value;\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'textContent'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'textContent'] = value;\n    }\n  }, {\n    key: \"slot\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'slot'];\n    },\n    set: function set(value) {\n      this.node[SHADY_PREFIX + 'slot'] = value;\n    }\n  }, {\n    key: \"className\",\n    get: function get() {\n      return this.node[SHADY_PREFIX + 'className'];\n    },\n    set: function set(value) {\n      return this.node[SHADY_PREFIX + 'className'] = value;\n    }\n  }]);\n\n  return Wrapper;\n}();\n\neventPropertyNames.forEach(function (name) {\n  Object.defineProperty(wrapper_Wrapper.prototype, name, {\n    /** @this {Wrapper} */\n    get: function get() {\n      return this.node[SHADY_PREFIX + name];\n    },\n\n    /** @this {Wrapper} */\n    set: function set(value) {\n      this.node[SHADY_PREFIX + name] = value;\n    },\n    configurable: true\n  });\n});\n\nvar wrapperMap = new WeakMap();\nfunction wrap(obj) {\n  if (utils_isShadyRoot(obj) || obj instanceof wrapper_Wrapper) {\n    return obj;\n  }\n\n  var wrapper = wrapperMap.get(obj);\n\n  if (!wrapper) {\n    wrapper = new wrapper_Wrapper(obj);\n    wrapperMap.set(obj, wrapper);\n  }\n\n  return wrapper;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/EventTarget.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar EventTargetPatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  dispatchEvent: function dispatchEvent(event) {\n    flush();\n    return this[NATIVE_PREFIX + 'dispatchEvent'](event);\n  },\n  addEventListener: patch_events_addEventListener,\n  removeEventListener: patch_events_removeEventListener\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slotable.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar SlotablePatches = getOwnPropertyDescriptors({\n  /** @this {Node} */\n  get assignedSlot() {\n    // Force any parent's shadowRoot to flush so that distribution occurs\n    // and this node has an assignedSlot.\n    var parent = this[SHADY_PREFIX + 'parentNode'];\n    var ownerRoot = parent && parent[SHADY_PREFIX + 'shadowRoot'];\n\n    if (ownerRoot) {\n      ownerRoot._render();\n    }\n\n    var nodeData = shadyDataForNode(this);\n    return nodeData && nodeData.assignedSlot || null;\n  }\n\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Element.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\nvar Element_doc = window.document;\n/**\n * Should be called whenever an attribute changes. If the `slot` attribute\n * changes, provokes rendering if necessary. If a `<slot>` element's `name`\n * attribute changes, updates the root's slot map and renders.\n * @param {Node} node\n * @param {string} name\n */\n\nfunction distributeAttributeChange(node, name) {\n  if (name === 'slot') {\n    var parent = node[SHADY_PREFIX + 'parentNode'];\n\n    if (utils_hasShadowRootWithSlot(parent)) {\n      shadyDataForNode(parent).root._asyncRender();\n    }\n  } else if (node.localName === 'slot' && name === 'name') {\n    var root = attach_shadow_ownerShadyRootForNode(node);\n\n    if (root) {\n      root._updateSlotName(node);\n\n      root._asyncRender();\n    }\n  }\n}\n\nvar ElementPatches = getOwnPropertyDescriptors({\n  /** @this {Element} */\n  get previousElementSibling() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.previousSibling !== undefined) {\n      var n = this[SHADY_PREFIX + 'previousSibling'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'previousSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'previousElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get nextElementSibling() {\n    var nodeData = shadyDataForNode(this);\n\n    if (nodeData && nodeData.nextSibling !== undefined) {\n      var n = this[SHADY_PREFIX + 'nextSibling'];\n\n      while (n && n.nodeType !== Node.ELEMENT_NODE) {\n        n = n[SHADY_PREFIX + 'nextSibling'];\n      }\n\n      return n;\n    } else {\n      return this[NATIVE_PREFIX + 'nextElementSibling'];\n    }\n  },\n\n  /** @this {Element} */\n  get slot() {\n    return this.getAttribute('slot');\n  },\n\n  /** @this {Element} */\n  set slot(value) {\n    this[SHADY_PREFIX + 'setAttribute']('slot', value);\n  },\n\n  // Note: Can be patched on element prototype on all browsers.\n  // Must be patched on instance on browsers that support native Shadow DOM\n  // but do not have builtin accessors (old Chrome).\n\n  /** @this {Element} */\n  get shadowRoot() {\n    var nodeData = shadyDataForNode(this);\n    return nodeData && nodeData.publicRoot || null;\n  },\n\n  /** @this {Element} */\n  get className() {\n    return this.getAttribute('class') || '';\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} value\n   */\n  set className(value) {\n    this[SHADY_PREFIX + 'setAttribute']('class', value);\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   * @param {string} value\n   */\n  setAttribute: function setAttribute(attr, value) {\n    if (this.ownerDocument !== Element_doc) {\n      this[NATIVE_PREFIX + 'setAttribute'](attr, value);\n    } else if (!scopeClassAttribute(this, attr, value)) {\n      this[NATIVE_PREFIX + 'setAttribute'](attr, value);\n      distributeAttributeChange(this, attr);\n    }\n  },\n\n  /**\n   * @this {Element}\n   * @param {string} attr\n   */\n  removeAttribute: function removeAttribute(attr) {\n    this[NATIVE_PREFIX + 'removeAttribute'](attr);\n    distributeAttributeChange(this, attr);\n  },\n\n  /**\n   * @this {Element}\n   * @param {!{mode: string}} options\n   */\n  attachShadow: function attachShadow(options) {\n    return attach_shadow_attachShadow(this, options);\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/HTMLElement.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar HTMLElementPatches = getOwnPropertyDescriptors({\n  /** @this {HTMLElement} */\n  blur: function blur() {\n    var nodeData = shadyDataForNode(this);\n    var root = nodeData && nodeData.root;\n    var shadowActive = root && root.activeElement;\n\n    if (shadowActive) {\n      shadowActive[SHADY_PREFIX + 'blur']();\n    } else {\n      this[NATIVE_PREFIX + 'blur']();\n    }\n  }\n});\neventPropertyNames.forEach(function (property) {\n  HTMLElementPatches[property] = {\n    /** @this {HTMLElement} */\n    set: function set(fn) {\n      var shadyData = ensureShadyDataForNode(this);\n      var eventName = property.substring(2);\n\n      if (!shadyData.__onCallbackListeners) {\n        shadyData.__onCallbackListeners = {};\n      }\n\n      shadyData.__onCallbackListeners[property] && this.removeEventListener(eventName, shadyData.__onCallbackListeners[property]);\n      this[SHADY_PREFIX + 'addEventListener'](eventName, fn);\n      shadyData.__onCallbackListeners[property] = fn;\n    },\n\n    /** @this {HTMLElement} */\n    get: function get() {\n      var shadyData = shadyDataForNode(this);\n      return shadyData && shadyData.__onCallbackListeners && shadyData.__onCallbackListeners[property];\n    },\n    configurable: true\n  };\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slot.js\nfunction Slot_typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { Slot_typeof = function _typeof(obj) { return typeof obj; }; } else { Slot_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return Slot_typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar SlotPatches = getOwnPropertyDescriptors({\n  /**\n   * @this {HTMLSlotElement}\n   * @param {Object=} options\n   */\n  assignedNodes: function assignedNodes(options) {\n    if (this.localName === 'slot') {\n      // Force any containing shadowRoot to flush so that distribution occurs\n      // and this node has assignedNodes.\n      var root = this[SHADY_PREFIX + 'getRootNode']();\n\n      if (root && utils_isShadyRoot(root)) {\n        root._render();\n      }\n\n      var nodeData = shadyDataForNode(this);\n      return nodeData ? (options && options.flatten ? nodeData.flattenedNodes : nodeData.assignedNodes) || [] : [];\n    }\n  },\n\n  /**\n   * @this {HTMLSlotElement}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  addEventListener: function addEventListener(type, fn, optionsOrCapture) {\n    // NOTE, check if this is a `slot` because these patches are installed on\n    // Element where browsers don't have `<slot>`\n    if (this.localName !== 'slot' || type === 'slotchange') {\n      patch_events_addEventListener.call(this, type, fn, optionsOrCapture);\n    } else {\n      if (Slot_typeof(optionsOrCapture) !== 'object') {\n        optionsOrCapture = {\n          capture: Boolean(optionsOrCapture)\n        };\n      }\n\n      var parent = this[SHADY_PREFIX + 'parentNode'];\n\n      if (!parent) {\n        throw new Error('ShadyDOM cannot attach event to slot unless it has a `parentNode`');\n      }\n\n      optionsOrCapture.__shadyTarget = this;\n      parent[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);\n    }\n  },\n\n  /**\n   * @this {HTMLSlotElement}\n   * @param {string} type\n   * @param {Function} fn\n   * @param {Object|boolean=} optionsOrCapture\n   */\n  removeEventListener: function removeEventListener(type, fn, optionsOrCapture) {\n    // NOTE, check if this is a `slot` because these patches are installed on\n    // Element where browsers don't have `<slot>`\n    if (this.localName !== 'slot' || type === 'slotchange') {\n      patch_events_removeEventListener.call(this, type, fn, optionsOrCapture);\n    } else {\n      if (Slot_typeof(optionsOrCapture) !== 'object') {\n        optionsOrCapture = {\n          capture: Boolean(optionsOrCapture)\n        };\n      }\n\n      var parent = this[SHADY_PREFIX + 'parentNode'];\n\n      if (!parent) {\n        throw new Error('ShadyDOM cannot attach event to slot unless it has a `parentNode`');\n      }\n\n      optionsOrCapture.__shadyTarget = this;\n      parent[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Document.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar Document_doc = window.document;\nvar DocumentPatches = getOwnPropertyDescriptors({\n  // note: Though not technically correct, we fast path `importNode`\n  // when called on a node not owned by the main document.\n  // This allows, for example, elements that cannot\n  // contain custom elements and are therefore not likely to contain shadowRoots\n  // to cloned natively. This is a fairly significant performance win.\n\n  /**\n   * @this {Document}\n   * @param {Node} node\n   * @param {boolean} deep\n   */\n  importNode: function importNode(node, deep) {\n    // A template element normally has no children with shadowRoots, so make\n    // sure we always make a deep copy to correctly construct the template.content\n    if (node.ownerDocument !== Document_doc || node.localName === 'template') {\n      return this[NATIVE_PREFIX + 'importNode'](node, deep);\n    }\n\n    var n = this[NATIVE_PREFIX + 'importNode'](node, false);\n\n    if (deep) {\n      for (var c = node[SHADY_PREFIX + 'firstChild'], nc; c; c = c[SHADY_PREFIX + 'nextSibling']) {\n        nc = this[SHADY_PREFIX + 'importNode'](c, true);\n        n[SHADY_PREFIX + 'appendChild'](nc);\n      }\n    }\n\n    return n;\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Window.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar WindowPatches = getOwnPropertyDescriptors({\n  // NOTE: ensure these methods are bound to `window` so that `this` is correct\n  // when called directly from global context without a receiver; e.g.\n  // `addEventListener(...)`.\n  addEventListener: patch_events_addEventListener.bind(window),\n  removeEventListener: patch_events_removeEventListener.bind(window)\n});\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-prototypes.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n // Some browsers (IE/Edge) have non-standard HTMLElement accessors.\n\nvar NonStandardHTMLElement = {};\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement')) {\n  NonStandardHTMLElement.parentElement = NodePatches.parentElement;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'contains')) {\n  NonStandardHTMLElement.contains = NodePatches.contains;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'children')) {\n  NonStandardHTMLElement.children = ParentNodePatches.children;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML')) {\n  NonStandardHTMLElement.innerHTML = ElementOrShadowRootPatches.innerHTML;\n}\n\nif (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'className')) {\n  NonStandardHTMLElement.className = ElementPatches.className;\n} // Avoid patching `innerHTML` if it does not exist on Element (IE)\n// and we can patch accessors (hasDescriptors).\n\n\nvar ElementShouldHaveInnerHTML = !settings.hasDescriptors || 'innerHTML' in Element.prototype; // setup patching\n\nvar patchMap = {\n  EventTarget: [EventTargetPatches],\n  Node: [NodePatches, !window.EventTarget ? EventTargetPatches : null],\n  Text: [SlotablePatches],\n  Element: [ElementPatches, ParentNodePatches, SlotablePatches, ElementShouldHaveInnerHTML ? ElementOrShadowRootPatches : null, !window.HTMLSlotElement ? SlotPatches : null],\n  HTMLElement: [HTMLElementPatches, NonStandardHTMLElement],\n  HTMLSlotElement: [SlotPatches],\n  DocumentFragment: [ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches],\n  Document: [DocumentPatches, ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches, DocumentOrShadowRootPatches],\n  Window: [WindowPatches]\n};\n\nvar getPatchPrototype = function getPatchPrototype(name) {\n  return window[name] && window[name].prototype;\n}; // Note, must avoid patching accessors on prototypes when descriptors are not correct\n// because the CustomElements polyfill checks if these exist before patching instances.\n// CustomElements polyfill *only* cares about these accessors.\n\n\nvar disallowedNativePatches = settings.hasDescriptors ? null : ['innerHTML', 'textContent'];\n/** @param {string=} prefix */\n\nvar patch_prototypes_applyPatches = function applyPatches(prefix) {\n  var disallowed = prefix ? null : disallowedNativePatches;\n\n  var _loop = function _loop(p) {\n    var proto = getPatchPrototype(p);\n    patchMap[p].forEach(function (patch) {\n      return proto && patch && patchProperties(proto, patch, prefix, disallowed);\n    });\n  };\n\n  for (var p in patchMap) {\n    _loop(p);\n  }\n};\nvar patch_prototypes_addShadyPrefixedProperties = function addShadyPrefixedProperties() {\n  // perform shady patches\n  patch_prototypes_applyPatches(SHADY_PREFIX); // install `_activeElement` because some browsers (older Chrome/Safari) do not have\n  // a 'configurable' `activeElement` accesssor.\n\n  var descriptor = DocumentOrShadowRootPatches.activeElement;\n  Object.defineProperty(document, '_activeElement', descriptor); // On Window, we're patching `addEventListener` which is a weird auto-bound\n  // property that is not directly on the Window prototype.\n\n  patchProperties(Window.prototype, WindowPatches, SHADY_PREFIX);\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shadydom.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\n\n\n\n\n\n\n\n\n\nif (settings.inUse) {\n  var ShadyDOM = {\n    // TODO(sorvell): remove when Polymer does not depend on this.\n    'inUse': settings.inUse,\n    // NOTE: old browsers without prototype accessors (very old Chrome\n    // and Safari) need manually patched accessors to properly set\n    // `innerHTML` and `textContent` when an element is:\n    // (1) inside a shadowRoot\n    // (2) does not have special (slot) children itself\n    // (3) and setting the property needs to provoke distribution (because\n    // a nested slot is added/removed)\n    'patch': function patch(node) {\n      patchInsideElementAccessors(node);\n      patchOutsideElementAccessors(node);\n      return node;\n    },\n    'isShadyRoot': utils_isShadyRoot,\n    'enqueue': enqueue,\n    'flush': flush,\n    'flushInitial': function flushInitial(root) {\n      root._flushInitial();\n    },\n    'settings': settings,\n    'filterMutations': filterMutations,\n    'observeChildren': observe_changes_observeChildren,\n    'unobserveChildren': observe_changes_unobserveChildren,\n    // Set to true to defer native custom elements connection until the\n    // document has fully parsed. This enables custom elements that create\n    // shadowRoots to be defined while the document is loading. Elements\n    // customized as they are created by the parser will successfully\n    // render with this flag on.\n    'deferConnectionCallbacks': settings['deferConnectionCallbacks'],\n    // Set to true to speed up the polyfill slightly at the cost of correctness\n    // * does not patch querySelector/All on Document or DocumentFragment\n    // * does not wrap connected/disconnected callbacks to de-dup these\n    // when using native customElements\n    // * does not wait to process children of elements with shadowRoots\n    // meaning shadowRoots should not be created while an element is parsing\n    // (e.g. if a custom element that creates a shadowRoot is defined before\n    // a candidate element in the document below it.\n    'preferPerformance': settings['preferPerformance'],\n    // Integration point with ShadyCSS to disable styling MutationObserver,\n    // as ShadyDOM will now handle dynamic scoping.\n    'handlesDynamicScoping': true,\n    'wrap': settings.noPatch ? wrap : function (n) {\n      return n;\n    },\n    'Wrapper': wrapper_Wrapper,\n    'composedPath': patch_events_composedPath,\n    // Set to true to avoid patching regular platform property names. When set,\n    // Shadow DOM compatible behavior is only available when accessing DOM\n    // API using `ShadyDOM.wrap`, e.g. `ShadyDOM.wrap(element).shadowRoot`.\n    // This setting provides a small performance boost, but requires all DOM API\n    // access that requires Shadow DOM behavior to be proxied via `ShadyDOM.wrap`.\n    'noPatch': settings.noPatch,\n    'nativeMethods': nativeMethods,\n    'nativeTree': nativeTree\n  };\n  window['ShadyDOM'] = ShadyDOM; // Modifies native prototypes for Node, Element, etc. to\n  // make native platform behavior available at prefixed names, e.g.\n  // `utils.NATIVE_PREFIX + 'firstChild'` or `__shady_native_firstChild`.\n  // This allows the standard names to be safely patched while retaining the\n  // ability for native behavior to be used. This polyfill manipulates DOM\n  // by using this saved native behavior.\n  // Note, some browsers do not have proper element descriptors for\n  // accessors; in this case, native behavior for these accessors is simulated\n  // via a TreeWalker.\n\n  patch_native_addNativePrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to make ShadowDOM\n  // behavior available at prefixed names, e.g.\n  // `utils.SHADY_PREFIX + 'firstChild` or `__shady_firstChild`. This is done\n  // so this polyfill can perform Shadow DOM style DOM manipulation.\n  // Because patching normal platform property names is optional, these prefixed\n  // names are used internally.\n\n  patch_prototypes_addShadyPrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to patch\n  // regular platform property names to have Shadow DOM compatible API behavior.\n  // This applies the utils.SHADY_PREFIX behavior to normal names. For example,\n  // if `noPatch` is not set, then `el.__shady_firstChild` is equivalent to\n  // `el.firstChild`.\n  // NOTE, on older browsers (old Chrome/Safari) native accessors cannot be\n  // patched on prototypes (e.g. Node.prototype.firstChild cannot be modified).\n  // On these browsers, instance level patching is performed where needed; this\n  // instance patching is only done when `noPatch` is *not* set.\n\n  if (!settings.noPatch) {\n    patch_prototypes_applyPatches(); // Patch click event behavior only if we're patching\n\n    patchClick();\n  } // For simplicity, patch events unconditionally.\n  // Patches the event system to have Shadow DOM compatible behavior (e.g.\n  // event retargeting). When `noPatch` is set, retargeting is only available\n  // when adding event listeners and dispatching events via `ShadyDOM.wrap`\n  // (e.g. `ShadyDOM.wrap(element).addEventListener(...)`).\n\n\n  patchEvents();\n  window.ShadowRoot =\n  /** @type {function(new:ShadowRoot)} */\n  attach_shadow_ShadyRoot;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3NoYWR5LWRhdGEuanM/ODY3NiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3V0aWxzLmpzPzQ3YTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9mbHVzaC5qcz9kZmU4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvb2JzZXJ2ZS1jaGFuZ2VzLmpzPzQ4ZjEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9pbm5lckhUTUwuanM/NDk4NiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoLW5hdGl2ZS5qcz9iM2RmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2gtaW5zdGFuY2VzLmpzPzU0ZjYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaC1ldmVudHMuanM/NjNlYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL2FycmF5LXNwbGljZS5qcz9kZjMyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvbGluay1ub2Rlcy5qcz8xYTVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvc3R5bGUtc2NvcGluZy5qcz80NGZmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2hlcy9Ob2RlLmpzPzMzMDQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL1BhcmVudE5vZGUuanM/NzM0NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvRG9jdW1lbnRPckZyYWdtZW50LmpzP2MxNGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL0RvY3VtZW50T3JTaGFkb3dSb290LmpzPzQ3M2UiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL0VsZW1lbnRPclNoYWRvd1Jvb3QuanM/OTMwMyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvU2hhZG93Um9vdC5qcz85OGY0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2gtc2hhZHlSb290LmpzP2VlN2IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9hdHRhY2gtc2hhZG93LmpzPzFmNWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy93cmFwcGVyLmpzP2I1NWYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL0V2ZW50VGFyZ2V0LmpzP2NlNmUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL1Nsb3RhYmxlLmpzPzE1ODIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL0VsZW1lbnQuanM/OWVlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvSFRNTEVsZW1lbnQuanM/MzllNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvU2xvdC5qcz9mOTQxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2hlcy9Eb2N1bWVudC5qcz9hZGExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2hlcy9XaW5kb3cuanM/YzI2NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoLXByb3RvdHlwZXMuanM/ZWJlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3NoYWR5ZG9tLmpzPzAyOGQiXSwibmFtZXMiOlsiU2hhZHlEYXRhIiwiZW5zdXJlU2hhZHlEYXRhRm9yTm9kZSIsIm5vZGUiLCJfX3NoYWR5Iiwic2hhZHlEYXRhRm9yTm9kZSIsInNldHRpbmdzIiwid2luZG93IiwiaGFzTmF0aXZlU2hhZG93RE9NIiwiQm9vbGVhbiIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJhdHRhY2hTaGFkb3ciLCJOb2RlIiwiZ2V0Um9vdE5vZGUiLCJkZXNjIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaGFzRGVzY3JpcHRvcnMiLCJjb25maWd1cmFibGUiLCJnZXQiLCJpblVzZSIsIm5vUGF0Y2giLCJwcmVmZXJQZXJmb3JtYW5jZSIsIklTX0lFIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibWF0Y2giLCJjYW5VcGdyYWRlIiwiaXNUcmFja2luZ0xvZ2ljYWxDaGlsZE5vZGVzIiwibm9kZURhdGEiLCJmaXJzdENoaWxkIiwidW5kZWZpbmVkIiwiaXNTaGFkeVJvb3QiLCJvYmoiLCJfbG9jYWxOYW1lIiwiaGFzU2hhZG93Um9vdFdpdGhTbG90Iiwicm9vdCIsIl9oYXNJbnNlcnRpb25Qb2ludCIsInAiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiZWxlbWVudCIsInNlbGVjdG9yIiwiY2FsbCIsIm1peGluIiwidGFyZ2V0Iiwic291cmNlIiwiaSIsInR3aWRkbGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY29udGVudCIsInF1ZXVlIiwiTXV0YXRpb25PYnNlcnZlciIsImxlbmd0aCIsInNoaWZ0IiwiZSIsInRleHRDb250ZW50Iiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJtaWNyb3Rhc2siLCJjYWxsYmFjayIsInB1c2giLCJoYXNEb2N1bWVudENvbnRhaW5zIiwiY29udGFpbnMiLCJjb250YWluZXIiLCJTSEFEWV9QUkVGSVgiLCJnZXROb2RlSFRNTENvbGxlY3Rpb25OYW1lIiwiZ2V0QXR0cmlidXRlIiwiaXNWYWxpZEhUTUxDb2xsZWN0aW9uTmFtZSIsIm5hbWUiLCJpc05hTiIsImNyZWF0ZVBvbHlmaWxsZWRIVE1MQ29sbGVjdGlvbiIsIm5vZGVzIiwibCIsIml0ZW0iLCJpbmRleCIsIm5hbWVkSXRlbSIsIm5vZGVOYW1lIiwiTkFUSVZFX1BSRUZJWCIsIm5hdGl2ZUNoaWxkTm9kZXNBcnJheSIsInBhcmVudCIsInJlc3VsdCIsIm4iLCJjaGlsZE5vZGVzQXJyYXkiLCJwYXRjaFByb3BlcnRpZXMiLCJwcm90byIsImRlc2NyaXB0b3JzIiwicHJlZml4IiwiZGlzYWxsb3dlZFBhdGNoZXMiLCJuZXdEZXNjcmlwdG9yIiwiaW5kZXhPZiIsInZhbHVlIiwiZGVmaW5lUHJvcGVydHkiLCJOYXRpdmVIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5TmFtZXMiLCJmb3JFYWNoIiwiZmx1c2hMaXN0Iiwic2NoZWR1bGVkIiwiZW5xdWV1ZSIsInV0aWxzIiwiZmx1c2giLCJkaWRGbHVzaCIsIkFzeW5jT2JzZXJ2ZXIiLCJfc2NoZWR1bGVkIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsImNhbGxiYWNrcyIsIlNldCIsIm11dGF0aW9ucyIsInRha2VSZWNvcmRzIiwiY2IiLCJvYnNlcnZlQ2hpbGRyZW4iLCJzZCIsIm9ic2VydmVyIiwiYWRkIiwiX2NhbGxiYWNrIiwiX29ic2VydmVyIiwiX25vZGUiLCJ1bm9ic2VydmVDaGlsZHJlbiIsImhhbmRsZSIsInNpemUiLCJmaWx0ZXJNdXRhdGlvbnMiLCJ0YXJnZXRSb290Tm9kZSIsIm1hcCIsIm11dGF0aW9uIiwibXV0YXRpb25JblNjb3BlIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiY3JlYXRlIiwibSIsImVzY2FwZUF0dHJSZWdFeHAiLCJlc2NhcGVEYXRhUmVnRXhwIiwiZXNjYXBlUmVwbGFjZSIsImMiLCJlc2NhcGVBdHRyIiwicyIsInJlcGxhY2UiLCJlc2NhcGVEYXRhIiwibWFrZVNldCIsImFyciIsInNldCIsInZvaWRFbGVtZW50cyIsInBsYWludGV4dFBhcmVudHMiLCJnZXRPdXRlckhUTUwiLCJwYXJlbnROb2RlIiwibm9kZVR5cGUiLCJFTEVNRU5UX05PREUiLCJ0YWdOYW1lIiwibG9jYWxOYW1lIiwiYXR0cnMiLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImdldElubmVySFRNTCIsIlRFWFRfTk9ERSIsImRhdGEiLCJDT01NRU5UX05PREUiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImMkIiwiY2hpbGROb2RlcyIsImNoaWxkIiwibmF0aXZlTWV0aG9kcyIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwibmF0aXZlVHJlZSIsImluc3RhbGxOYXRpdmVBY2Nlc3NvciIsImluc3RhbGxOYXRpdmVNZXRob2QiLCJmbiIsImRlZmluZU5hdGl2ZUFjY2Vzc29ycyIsInByb3AiLCJjb3B5UHJvcGVydGllcyIsImxpc3QiLCJkZXNjcmlwdG9yIiwibm9kZVdhbGtlciIsImNyZWF0ZVRyZWVXYWxrZXIiLCJOb2RlRmlsdGVyIiwiU0hPV19BTEwiLCJlbGVtZW50V2Fsa2VyIiwiU0hPV19FTEVNRU5UIiwiaW5lcnREb2MiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImNsZWFyTm9kZSIsIlBhcmVudE5vZGVBY2Nlc3NvcnMiLCJQYXJlbnROb2RlTWV0aG9kcyIsImFkZE5hdGl2ZVByZWZpeGVkUHJvcGVydGllcyIsImV2ZW50UHJvcHMiLCJFdmVudFRhcmdldCIsIldpbmRvdyIsImN1cnJlbnROb2RlIiwibGFzdENoaWxkIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJwYXJlbnRFbGVtZW50IiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsInRleHRXYWxrZXIiLCJTSE9XX1RFWFQiLCJuZXh0Tm9kZSIsIm5vZGVWYWx1ZSIsIlBhcmVudE5vZGVXYWxrZXJEZXNjcmlwdG9ycyIsImZpcnN0RWxlbWVudENoaWxkIiwibGFzdEVsZW1lbnRDaGlsZCIsImNoaWxkcmVuIiwiY2hpbGRFbGVtZW50Q291bnQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaW5uZXJIVE1MIiwiY29udGFpbmVyTmFtZSIsImh0bWxDb250YWluZXIiLCJuYW1lc3BhY2VVUkkiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwibmV3Q29udGVudCIsImNsYXNzTmFtZSIsInNldEF0dHJpYnV0ZSIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJEb2N1bWVudEZyYWdtZW50IiwiRG9jdW1lbnQiLCJJbnNpZGVEZXNjcmlwdG9ycyIsInNoYWRvd1Jvb3QiLCJUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzIiwiT3V0c2lkZURlc2NyaXB0b3JzIiwiZW51bWVyYWJsZSIsIm5vSW5zdGFuY2VQYXRjaGluZyIsInBhdGNoT3V0c2lkZUVsZW1lbnRBY2Nlc3NvcnMiLCJfX291dHNpZGVBY2Nlc3NvcnMiLCJwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMiLCJfX2luc2lkZUFjY2Vzc29ycyIsImV2ZW50V3JhcHBlcnNOYW1lIiwiRGF0ZSIsIm5vdyIsImNvbXBvc2VkR2V0dGVyIiwiY29tcG9zZWRQcm9wIiwiRXZlbnQiLCJldiIsInN1cHBvcnRzRXZlbnRPcHRpb25zIiwic3VwcG9ydGVkIiwiZXZlbnRPcHRpb25zIiwiY2FwdHVyZSIsImxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJzZUV2ZW50T3B0aW9ucyIsIm9wdGlvbnNPckNhcHR1cmUiLCJvbmNlIiwicGFzc2l2ZSIsInNoYWR5VGFyZ2V0IiwiX19zaGFkeVRhcmdldCIsIm5hdGl2ZUV2ZW50T3B0aW9ucyIsImFsd2F5c0NvbXBvc2VkIiwidW5wYXRjaGVkRXZlbnRzIiwiZ2V0Um9vdE5vZGVXaXRoRmFsbGJhY2siLCJldmVudFRhcmdldCIsInBhdGhDb21wb3NlciIsInN0YXJ0Tm9kZSIsImNvbXBvc2VkIiwiY29tcG9zZWRQYXRoIiwiY3VycmVudCIsInN0YXJ0Um9vdCIsImhvc3QiLCJldmVudCIsIl9fY29tcG9zZWRQYXRoIiwicmV0YXJnZXQiLCJyZWZOb2RlIiwicGF0aCIsInJlZk5vZGVQYXRoIiwicCQiLCJhbmNlc3RvciIsImxhc3RSb290Iiwicm9vdElkeCIsIkV2ZW50UGF0Y2hlcyIsIl9fY29tcG9zZWQiLCJ0eXBlIiwiaXNUcnVzdGVkIiwiY3VycmVudFRhcmdldCIsInJlbGF0ZWRUYXJnZXQiLCJfX3JlbGF0ZWRUYXJnZXQiLCJfX3JlbGF0ZWRUYXJnZXRDb21wb3NlZFBhdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJfX3Byb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9faW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwibWl4aW5Db21wb3NlZEZsYWciLCJCYXNlIiwia2xhenoiLCJvcHRpb25zIiwiX19wcm90b19fIiwibm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0IiwiaGFzUmV0YXJnZXRlZCIsImZpcmVIYW5kbGVycyIsInBoYXNlIiwiaHMiLCJfX2hhbmRsZXJzIiwicmV0YXJnZXROb25CdWJibGluZ0V2ZW50IiwiQVRfVEFSR0VUIiwibGFzdEZpcmVkUm9vdCIsImxpc3RlbmVyU2V0dGluZ3NFcXVhbCIsInNhdmVkTGlzdGVuZXIiLCJzYXZlZE5vZGUiLCJzYXZlZFR5cGUiLCJzYXZlZENhcHR1cmUiLCJzYXZlZE9uY2UiLCJzYXZlZFBhc3NpdmUiLCJmaW5kTGlzdGVuZXIiLCJ3cmFwcGVycyIsImdldEV2ZW50V3JhcHBlcnMiLCJldmVudExpa2UiLCJ0YXJnZXROZWVkc1BhdGhDaGVjayIsImZuT3JPYmoiLCJoYW5kbGVyVHlwZSIsImhhbmRsZUV2ZW50Iiwid3JhcHBlckZuIiwicGF0Y2hFdmVudCIsImxhc3RDdXJyZW50VGFyZ2V0RGVzYyIsImV2ZW50UGhhc2UiLCJCVUJCTElOR19QSEFTRSIsIkNBUFRVUklOR19QSEFTRSIsImJ1YmJsZXMiLCJyZXQiLCJpZHgiLCJzcGxpY2UiLCJhY3RpdmF0ZUZvY3VzRXZlbnRPdmVycmlkZXMiLCJFdmVudFBhdGNoZXNEZXNjcmlwdG9ycyIsIlNIQURZX1BST1RPIiwiU0hBRFlfU09VUkNFX1BST1RPIiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd25Qcm9wZXJ0eSIsInBhdGNoZWRQcm90byIsIlBhdGNoZWRFdmVudCIsIlBhdGNoZWRDdXN0b21FdmVudCIsIkN1c3RvbUV2ZW50IiwiUGF0Y2hlZE1vdXNlRXZlbnQiLCJNb3VzZUV2ZW50IiwicGF0Y2hFdmVudHMiLCJwYXRjaENsaWNrIiwiY29tcG9zZWRDbGlja0ZuIiwiY2FuY2VsYWJsZSIsImNsaWNrIiwiZXZlbnRQcm9wZXJ0eU5hbWVzIiwic3Vic3RyaW5nIiwibmV3U3BsaWNlIiwicmVtb3ZlZCIsImFkZGVkQ291bnQiLCJFRElUX0xFQVZFIiwiRURJVF9VUERBVEUiLCJFRElUX0FERCIsIkVESVRfREVMRVRFIiwiY2FsY0VkaXREaXN0YW5jZXMiLCJjdXJyZW50U3RhcnQiLCJjdXJyZW50RW5kIiwib2xkIiwib2xkU3RhcnQiLCJvbGRFbmQiLCJyb3dDb3VudCIsImNvbHVtbkNvdW50IiwiZGlzdGFuY2VzIiwiaiIsImVxdWFscyIsIm5vcnRoIiwid2VzdCIsInNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyIsImVkaXRzIiwibm9ydGhXZXN0IiwibWluIiwicmV2ZXJzZSIsImNhbGNTcGxpY2VzIiwicHJlZml4Q291bnQiLCJzdWZmaXhDb3VudCIsIm1pbkxlbmd0aCIsIk1hdGgiLCJzaGFyZWRQcmVmaXgiLCJzaGFyZWRTdWZmaXgiLCJvcHMiLCJzcGxpY2VzIiwib2xkSW5kZXgiLCJzZWFyY2hMZW5ndGgiLCJpbmRleDEiLCJpbmRleDIiLCJjb3VudCIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCJjYWxjdWxhdGVTcGxpY2VzIiwicHJldmlvdXMiLCJsaW5rTm9kZSIsImNvbnRhaW5lckRhdGEiLCJyZWZfbm9kZSIsInJlZl9ub2RlRGF0YSIsInBzZCIsIm5zZCIsInJlY29yZEluc2VydEJlZm9yZSIsImZpcnN0IiwicmVjb3JkUmVtb3ZlQ2hpbGQiLCJyZWNvcmRDaGlsZE5vZGVzIiwiYWRvcHRlZFBhcmVudCIsInNjb3BpbmdTaGltIiwiZ2V0U2NvcGluZ1NoaW0iLCJzY29wZUNsYXNzQXR0cmlidXRlIiwiYWRkU2hhZHlTY29waW5nIiwibmV3U2NvcGVOYW1lIiwicmVtb3ZlU2hhZHlTY29waW5nIiwiY3VycmVudFNjb3BlTmFtZSIsInJlcGxhY2VTaGFkeVNjb3BpbmciLCJvbGRTY29wZU5hbWUiLCJjdXJyZW50U2NvcGVJc0NvcnJlY3QiLCJjb3JyZWN0U2NvcGUiLCJjdXJyZW50U2NvcGUiLCJjdXJyZW50U2NvcGVGb3JOb2RlIiwidHJlZVZpc2l0b3IiLCJ2aXNpdG9yRm4iLCJkb2MiLCJuYXRpdmVJc0Nvbm5lY3RlZEFjY2Vzc29ycyIsIm5hdGl2ZUlzQ29ubmVjdGVkIiwicmVtb3ZlT3duZXJTaGFkeVJvb3QiLCJoYXNDYWNoZWRPd25lclJvb3QiLCJvd25lclNoYWR5Um9vdCIsImZpcnN0Q29tcG9zZWROb2RlIiwiZmxhdHRlbmVkIiwiZmxhdHRlbmVkTm9kZXMiLCJzY2hlZHVsZU9ic2VydmVyIiwiYWRkZWROb2RlIiwicmVtb3ZlZE5vZGUiLCJzY2hlZHVsZSIsIk5vZGVQYXRjaGVzIiwiaXNDb25uZWN0ZWQiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwidGMiLCJqb2luIiwiaW5zZXJ0QmVmb3JlIiwicmVmRGF0YSIsInNsb3RzQWRkZWQiLCJvd25lclJvb3QiLCJvd25lclNoYWR5Um9vdEZvck5vZGUiLCJza2lwVW5zY29waW5nIiwiYWxsb3dOYXRpdmVJbnNlcnQiLCJuZWVkc1Njb3BpbmciLCJuZWVkc1Nsb3RGaW5kaW5nIiwiX2FkZFNsb3RzIiwiX2FzeW5jUmVuZGVyIiwicGFyZW50RGF0YSIsImFkb3B0Tm9kZSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJwcmV2ZW50TmF0aXZlUmVtb3ZlIiwicmVtb3ZpbmdJbnNlcnRpb25Qb2ludCIsIl9yZW1vdmVDb250YWluZWRTbG90cyIsImNoYW5nZVNsb3RDb250ZW50IiwicmVwbGFjZUNoaWxkIiwiY2xvbmVOb2RlIiwiZGVlcCIsIkFUVFJJQlVURV9OT0RFIiwibmMiLCJxdWVyeSIsIm1hdGNoZXIiLCJoYWx0ZXIiLCJxdWVyeUNoaWxkTm9kZXMiLCJxdWVyeUVsZW1lbnQiLCJQYXJlbnROb2RlUGF0Y2hlcyIsIlF1ZXJ5UGF0Y2hlcyIsInVzZU5hdGl2ZSIsIm8iLCJzbGljZSIsIlBhcmVudE5vZGVEb2N1bWVudE9yRnJhZ21lbnRQYXRjaGVzIiwiYXNzaWduIiwiRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcyIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJnZXREb2N1bWVudEFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiRG9jdW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzIiwiYWN0aXZlIiwiYWN0aXZlUm9vdCIsIkVsZW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzIiwiU2hhZG93Um9vdFBhdGNoZXMiLCJwYXRjaFNoYWR5QWNjZXNzb3JzIiwicGF0Y2hTaGFkeVJvb3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiU2hhZHlSb290Q29uc3RydWN0aW9uVG9rZW4iLCJDQVRDSEFMTF9OQU1FIiwiU0hBRFlST09UX05BTUUiLCJNT0RFX0NMT1NFRCIsImlzUmVuZGVyaW5nIiwicmVhZHlTdGF0ZSIsInJvb3RSZW5kZXJlZCIsImFuY2VzdG9yTGlzdCIsImFuY2VzdG9ycyIsInVuc2hpZnQiLCJTaGFkeVJvb3QiLCJ0b2tlbiIsIlR5cGVFcnJvciIsIl9yZW5kZXJQZW5kaW5nIiwiX2hhc1JlbmRlcmVkIiwiX3Nsb3RMaXN0IiwiX3Nsb3RNYXAiLCJfcGVuZGluZ1Nsb3RzIiwiX2luaXQiLCJtb2RlIiwiaG9zdERhdGEiLCJwdWJsaWNSb290Iiwicm9vdERhdGEiLCJfcmVuZGVyIiwicmVuZGVyUm9vdCIsIl9nZXREaXN0cmlidXRpb25QYXJlbnQiLCJfX2NoaWxkU2xvdENvdW50IiwiX2dldFBlbmRpbmdEaXN0cmlidXRpb25Sb290IiwiX3JlbmRlclNlbGYiLCJ3YXNSZW5kZXJpbmciLCJfZGlzdHJpYnV0ZSIsIl9jb21wb3NlIiwiYXNzaWduZWRTbG90IiwiX3ZhbGlkYXRlU2xvdHMiLCJzbG90IiwiX2NsZWFyU2xvdEFzc2lnbmVkTm9kZXMiLCJfZGlzdHJpYnV0ZU5vZGVUb1Nsb3QiLCJzbG90RGF0YSIsImFzc2lnbmVkTm9kZXMiLCJzbG90UGFyZW50RGF0YSIsInNsb3RQYXJlbnRSb290IiwiX2FkZEFzc2lnbmVkVG9GbGF0dGVuZWROb2RlcyIsInByZXZBc3NpZ25lZE5vZGVzIiwiX3ByZXZpb3VzbHlBc3NpZ25lZE5vZGVzIiwiX3ByZXZBc3NpZ25lZFNsb3QiLCJkaXJ0eSIsIl9maXJlU2xvdENoYW5nZSIsImZvcmNlZFNsb3QiLCJvbGRTbG90IiwibiQiLCJhc3NpZ25lZCIsIm5lc3RlZEFzc2lnbmVkIiwic2xvdHMiLCJjb21wb3NlTGlzdCIsInRhcmdldE5vZGUiLCJfdXBkYXRlQ2hpbGROb2RlcyIsIl9jb21wb3NlTm9kZSIsIl9pc0luc2VydGlvblBvaW50IiwiZGlzdHJpYnV0ZWROb2RlIiwiZCIsIm5leHQiLCJfZW5zdXJlU2xvdERhdGEiLCJfbWFwU2xvdHMiLCJzbG90TmFtZXNUb1NvcnQiLCJzbG90UGFyZW50IiwiX25hbWVGb3JTbG90IiwiX3NvcnRTbG90cyIsIl9fc2xvdE5hbWUiLCJzb3J0IiwiYSIsImIiLCJsaXN0QSIsImxpc3RCIiwibkEiLCJuQiIsImRpZFJlbW92ZSIsIngiLCJfcmVtb3ZlRmxhdHRlbmVkTm9kZXMiLCJvbGROYW1lIiwiU2hhZG93Um9vdCIsImNvbm5lY3RNYXAiLCJNYXAiLCJyIiwidiIsImsiLCJjbGVhciIsIk1hbmFnZUNvbm5lY3QiLCJiYXNlIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGVkIiwiY291bnRlciIsImNvbm5lY3RGbGFnIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsIm9yaWdpbmFsRGVmaW5lIiwiZGVmaW5lIiwiY29uc3RydWN0b3IiLCJjdXN0b21FbGVtZW50cyIsIldyYXBwZXIiLCJET0NVTUVOVF9OT0RFIiwid3JhcHBlck1hcCIsIldlYWtNYXAiLCJ3cmFwIiwid3JhcHBlciIsIkV2ZW50VGFyZ2V0UGF0Y2hlcyIsImRpc3BhdGNoRXZlbnQiLCJTbG90YWJsZVBhdGNoZXMiLCJkaXN0cmlidXRlQXR0cmlidXRlQ2hhbmdlIiwiX3VwZGF0ZVNsb3ROYW1lIiwiRWxlbWVudFBhdGNoZXMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJIVE1MRWxlbWVudFBhdGNoZXMiLCJibHVyIiwic2hhZG93QWN0aXZlIiwicHJvcGVydHkiLCJzaGFkeURhdGEiLCJldmVudE5hbWUiLCJfX29uQ2FsbGJhY2tMaXN0ZW5lcnMiLCJTbG90UGF0Y2hlcyIsImZsYXR0ZW4iLCJEb2N1bWVudFBhdGNoZXMiLCJpbXBvcnROb2RlIiwiV2luZG93UGF0Y2hlcyIsImJpbmQiLCJOb25TdGFuZGFyZEhUTUxFbGVtZW50IiwiRWxlbWVudFNob3VsZEhhdmVJbm5lckhUTUwiLCJwYXRjaE1hcCIsIlRleHQiLCJIVE1MU2xvdEVsZW1lbnQiLCJnZXRQYXRjaFByb3RvdHlwZSIsImRpc2FsbG93ZWROYXRpdmVQYXRjaGVzIiwiYXBwbHlQYXRjaGVzIiwiZGlzYWxsb3dlZCIsInBhdGNoIiwiYWRkU2hhZHlQcmVmaXhlZFByb3BlcnRpZXMiLCJTaGFkeURPTSIsIl9mbHVzaEluaXRpYWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7QUFXTyxJQUFNQSxTQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUVFO0FBRkYsNkJBR1c7QUFDUCxhQUFPLEVBQVA7QUFDRDtBQUxIOztBQUFBO0FBQUE7QUFRTyxTQUFTQyxzQkFBVCxDQUFnQ0MsSUFBaEMsRUFBc0M7QUFDM0MsTUFBSSxDQUFDQSxJQUFJLENBQUNDLE9BQVYsRUFBbUI7QUFDakJELFFBQUksQ0FBQ0MsT0FBTCxHQUFlLElBQUlILFNBQUosRUFBZjtBQUNEOztBQUNELFNBQU9FLElBQUksQ0FBQ0MsT0FBWjtBQUNEO0FBRU0sU0FBU0MsZ0JBQVQsQ0FBMEJGLElBQTFCLEVBQWdDO0FBQ3JDLFNBQU9BLElBQUksSUFBSUEsSUFBSSxDQUFDQyxPQUFwQjtBQUNELEM7O0FDNUJEOzs7Ozs7Ozs7QUFTQTtBQUVBOztBQUNPLElBQU1FLFFBQVEsR0FBR0MsTUFBTSxDQUFDLFVBQUQsQ0FBTixJQUFzQixFQUF2QztBQUVQRCxRQUFRLENBQUNFLGtCQUFULEdBQThCQyxPQUFPLENBQUNDLE9B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QVU7QUFDWCxHQTVGdUIsQ0E4RnhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBRCxhQUFXO0FBRVhoVixRQUFNLENBQUMraUIsVUFBUDtBQUFvQjtBQUF3Q3JFLHlCQUE1RDtBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9zaGFkeWRvbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cblxuZXhwb3J0IGNsYXNzIFNoYWR5RGF0YSB7XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlLl9fc2hhZHkpIHtcbiAgICBub2RlLl9fc2hhZHkgPSBuZXcgU2hhZHlEYXRhKCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuX19zaGFkeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYWR5RGF0YUZvck5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLl9fc2hhZHk7XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuL3NoYWR5LWRhdGEuanMnO1xuXG4vKiogQHR5cGUgeyFPYmplY3R9ICovXG5leHBvcnQgY29uc3Qgc2V0dGluZ3MgPSB3aW5kb3dbJ1NoYWR5RE9NJ10gfHwge307XG5cbnNldHRpbmdzLmhhc05hdGl2ZVNoYWRvd0RPTSA9IEJvb2xlYW4oRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ICYmIE5vZGUucHJvdG90eXBlLmdldFJvb3ROb2RlKTtcblxuY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsICdmaXJzdENoaWxkJyk7XG5cbnNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzID0gQm9vbGVhbihkZXNjICYmIGRlc2MuY29uZmlndXJhYmxlICYmIGRlc2MuZ2V0KTtcbnNldHRpbmdzLmluVXNlID0gc2V0dGluZ3NbJ2ZvcmNlJ10gfHwgIXNldHRpbmdzLmhhc05hdGl2ZVNoYWRvd0RPTTtcbnNldHRpbmdzLm5vUGF0Y2ggPSBzZXR0aW5nc1snbm9QYXRjaCddIHx8IGZhbHNlO1xuc2V0dGluZ3MucHJlZmVyUGVyZm9ybWFuY2UgPSBzZXR0aW5nc1sncHJlZmVyUGVyZm9ybWFuY2UnXTtcblxuY29uc3QgSVNfSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCdUcmlkZW50Jyk7XG5zZXR0aW5ncy5JU19JRSA9IElTX0lFO1xuXG5leHBvcnQgY29uc3QgY2FuVXBncmFkZSA9ICgpID0+ICFzZXR0aW5ncy5JU19JRTtcblxuZXhwb3J0IGNvbnN0IGlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2RlcyA9IChub2RlKSA9PiB7XG4gIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgcmV0dXJuIChub2RlRGF0YSAmJiBub2RlRGF0YS5maXJzdENoaWxkICE9PSB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgY29uc3QgaXNTaGFkeVJvb3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiBCb29sZWFuKG9iai5fbG9jYWxOYW1lID09PSAnU2hhZHlSb290Jyk7XG59XG5cbmV4cG9ydCBjb25zdCBoYXNTaGFkb3dSb290V2l0aFNsb3QgPSAobm9kZSkgPT4ge1xuICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIGxldCByb290ID0gbm9kZURhdGEgJiYgbm9kZURhdGEucm9vdDtcbiAgcmV0dXJuIChyb290ICYmIHJvb3QuX2hhc0luc2VydGlvblBvaW50KCkpO1xufVxuXG5sZXQgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xubGV0IG1hdGNoZXMgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVzU2VsZWN0b3IgPSAoZWxlbWVudCwgc2VsZWN0b3IpID0+IHtcbiAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbmV4cG9ydCBjb25zdCBtaXhpbiA9ICh0YXJnZXQsIHNvdXJjZSkgPT4ge1xuICBmb3IgKHZhciBpIGluIHNvdXJjZSkge1xuICAgIHRhcmdldFtpXSA9IHNvdXJjZVtpXTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBOT1RFLCBwcmVmZXIgTXV0YXRpb25PYnNlcnZlciBvdmVyIFByb21pc2UgZm9yIG1pY3JvdGFzayB0aW1pbmdcbi8vIGZvciBjb25zaXN0ZW5jeSB4LXBsYXRmb3JtLlxubGV0IHR3aWRkbGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5sZXQgY29udGVudCA9IDA7XG5sZXQgcXVldWUgPSBbXTtcbm5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIC8vIGNhdGNoIGVycm9ycyBpbiB1c2VyIGNvZGUuLi5cbiAgICB0cnkge1xuICAgICAgcXVldWUuc2hpZnQoKSgpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gZW5xdWV1ZSBhbm90aGVyIHJlY29yZCBhbmQgdGhyb3dcbiAgICAgIHR3aWRkbGUudGV4dENvbnRlbnQgPSBjb250ZW50Kys7XG4gICAgICB0aHJvdyhlKTtcbiAgICB9XG4gIH1cbn0pLm9ic2VydmUodHdpZGRsZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgdG8gZ2V0IG1pY3JvdGFzayBhc3luYyB0aW1pbmcuXG5leHBvcnQgY29uc3QgbWljcm90YXNrID0gKGNhbGxiYWNrKSA9PiB7XG4gIHF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICB0d2lkZGxlLnRleHRDb250ZW50ID0gY29udGVudCsrO1xufVxuXG5leHBvcnQgY29uc3QgaGFzRG9jdW1lbnRDb250YWlucyA9IEJvb2xlYW4oZG9jdW1lbnQuY29udGFpbnMpO1xuXG5leHBvcnQgY29uc3QgY29udGFpbnMgPSAoY29udGFpbmVyLCBub2RlKSA9PiB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGVbU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGdldE5vZGVIVE1MQ29sbGVjdGlvbk5hbWUgPSAobm9kZSkgPT5cbiAgICBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSB8fCBub2RlLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXG5jb25zdCBpc1ZhbGlkSFRNTENvbGxlY3Rpb25OYW1lID0gKG5hbWUpID0+IG5hbWUgIT09ICdsZW5ndGgnICYmIGlzTmFOKG5hbWUpO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUG9seWZpbGxlZEhUTUxDb2xsZWN0aW9uID0gKG5vZGVzKSA9PiB7XG4gIC8vIE5vdGU6IGxvb3AgaW4gcmV2ZXJzZSBzbyB0aGF0IHRoZSBmaXJzdCBuYW1lZCBpdGVtIG1hdGNoZXMgdGhlIG5hbWVkIHByb3BlcnR5XG4gIGZvciAobGV0IGwgPSBub2Rlcy5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tsXTtcbiAgICBjb25zdCBuYW1lID0gZ2V0Tm9kZUhUTUxDb2xsZWN0aW9uTmFtZShub2RlKTtcblxuICAgIGlmIChuYW1lICYmIGlzVmFsaWRIVE1MQ29sbGVjdGlvbk5hbWUobmFtZSkpIHtcbiAgICAgIG5vZGVzW25hbWVdID0gbm9kZTtcbiAgICB9XG4gIH1cbiAgbm9kZXMuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzW2luZGV4XTtcbiAgfVxuICBub2Rlcy5uYW1lZEl0ZW0gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKGlzVmFsaWRIVE1MQ29sbGVjdGlvbk5hbWUobmFtZSkgJiYgbm9kZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IG5vZGVOYW1lID0gZ2V0Tm9kZUhUTUxDb2xsZWN0aW9uTmFtZShub2RlKTtcblxuICAgICAgaWYgKG5vZGVOYW1lID09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBub2Rlcztcbn1cblxuZXhwb3J0IGNvbnN0IE5BVElWRV9QUkVGSVggPSAnX19zaGFkeV9uYXRpdmVfJztcbmV4cG9ydCBjb25zdCBTSEFEWV9QUkVGSVggPSAnX19zaGFkeV8nO1xuXG5leHBvcnQgY29uc3QgbmF0aXZlQ2hpbGROb2Rlc0FycmF5ID0gKHBhcmVudCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgbj1wYXJlbnRbTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG4gPSBuW05BVElWRV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgIHJlc3VsdC5wdXNoKG4pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBjb25zdCBjaGlsZE5vZGVzQXJyYXkgPSAocGFyZW50KSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBuPXBhcmVudFtTSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuID0gbltTSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgIHJlc3VsdC5wdXNoKG4pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUGF0Y2ggYSBncm91cCBvZiBhY2Nlc3NvcnMgb24gYW4gb2JqZWN0IG9ubHkgaWYgaXQgZXhpc3RzIG9yIGlmIHRoZSBgZm9yY2VgXG4gKiBhcmd1bWVudCBpcyB0cnVlLlxuICogQHBhcmFtIHshT2JqZWN0fSBwcm90b1xuICogQHBhcmFtIHshT2JqZWN0fSBkZXNjcmlwdG9yc1xuICogQHBhcmFtIHtzdHJpbmc9fSBwcmVmaXhcbiAqIEBwYXJhbSB7QXJyYXk9fSBkaXNhbGxvd2VkUGF0Y2hlc1xuICovXG5leHBvcnQgY29uc3QgcGF0Y2hQcm9wZXJ0aWVzID0gKHByb3RvLCBkZXNjcmlwdG9ycywgcHJlZml4ID0gJycsIGRpc2FsbG93ZWRQYXRjaGVzKSA9PiB7XG4gIGZvciAobGV0IHAgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBuZXdEZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbcF07XG4gICAgaWYgKGRpc2FsbG93ZWRQYXRjaGVzICYmIGRpc2FsbG93ZWRQYXRjaGVzLmluZGV4T2YocCkgPj0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5ld0Rlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBjb25zdCBuYW1lID0gcHJlZml4ICsgcDtcbiAgICAvLyBOT1RFOiB3ZSBwcmVmZXIgd3JpdGluZyBkaXJlY3RseSBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAvLyBoYXZlIGRlc2NyaXB0b3JzIHRoYXQgYXJlIHdyaXRhYmxlIGJ1dCBub3QgY29uZmlndXJhYmxlIChlLmcuXG4gICAgLy8gYGFwcGVuZENoaWxkYCBvbiBvbGRlciBicm93c2VycylcbiAgICBpZiAobmV3RGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgcHJvdG9bbmFtZV0gPSBuZXdEZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOT1RFOiB0aGlzIGNhbiB0aHJvdyBpZiAnZm9yY2UnIGlzIHVzZWQgc28gY2F0Y2ggdGhlIGVycm9yLlxuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCBuZXdEZXNjcmlwdG9yKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyB0aGlzIGVycm9yIGlzIGhhcm1sZXNzIHNvIHdlIGp1c3QgdHJhcCBpdC5cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEB0eXBlIHshZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gKi9cbmV4cG9ydCBjb25zdCBOYXRpdmVIVE1MRWxlbWVudCA9XG4gICAgKHdpbmRvd1snY3VzdG9tRWxlbWVudHMnXSAmJiB3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ11bJ25hdGl2ZUhUTUxFbGVtZW50J10pIHx8XG4gICAgSFRNTEVsZW1lbnQ7XG5cbi8vIG5vdGUsIHRoaXMgaXMgbm90IGEgcGVyZmVjdCBwb2x5ZmlsbCBzaW5jZSBpdCBkb2Vzbid0IGluY2x1ZGUgc3ltYm9sc1xuLyoqIEByZXR1cm4geyFPYmplY3Q8IU9iamVjdFByb3BlcnR5RGVzY3JpcHRvcj59ICovXG5leHBvcnQgY29uc3QgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IChvYmopID0+IHtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSB7fTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgZGVzY3JpcHRvcnNbbmFtZV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbmFtZSk7XG4gIH0pO1xuICByZXR1cm4gZGVzY3JpcHRvcnM7XG59O1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIHJlbmRlciBlbnF1ZXVlci9mbHVzaGVyXG5sZXQgZmx1c2hMaXN0ID0gW107XG5sZXQgc2NoZWR1bGVkO1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWUoY2FsbGJhY2spIHtcbiAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIHV0aWxzLm1pY3JvdGFzayhmbHVzaCk7XG4gIH1cbiAgZmx1c2hMaXN0LnB1c2goY2FsbGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2goKSB7XG4gIHNjaGVkdWxlZCA9IGZhbHNlO1xuICBsZXQgZGlkRmx1c2ggPSBCb29sZWFuKGZsdXNoTGlzdC5sZW5ndGgpO1xuICB3aGlsZSAoZmx1c2hMaXN0Lmxlbmd0aCkge1xuICAgIGZsdXNoTGlzdC5zaGlmdCgpKCk7XG4gIH1cbiAgcmV0dXJuIGRpZEZsdXNoO1xufVxuXG5mbHVzaFsnbGlzdCddID0gZmx1c2hMaXN0O1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge2Vuc3VyZVNoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4vc2hhZHktZGF0YS5qcyc7XG5cbmNsYXNzIEFzeW5jT2JzZXJ2ZXIge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBzY2hlZHVsZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHV0aWxzLm1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKCkge1xuICAgIGlmICh0aGlzLl9zY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgbGV0IG11dGF0aW9ucyA9IHRoaXMudGFrZVJlY29yZHMoKTtcbiAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICBjYihtdXRhdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YWtlUmVjb3JkcygpIHtcbiAgICBpZiAodGhpcy5hZGRlZE5vZGVzLmxlbmd0aCB8fCB0aGlzLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGxldCBtdXRhdGlvbnMgPSBbe1xuICAgICAgICBhZGRlZE5vZGVzOiB0aGlzLmFkZGVkTm9kZXMsXG4gICAgICAgIHJlbW92ZWROb2RlczogdGhpcy5yZW1vdmVkTm9kZXNcbiAgICAgIH1dO1xuICAgICAgdGhpcy5hZGRlZE5vZGVzID0gW107XG4gICAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgcmV0dXJuIG11dGF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbn1cblxuLy8gVE9ETyhzb3J2ZWxsKTogY29uc2lkZXIgaW5zdGVhZCBwb2x5ZmlsbGluZyBNdXRhdGlvbk9ic2VydmVyXG4vLyBkaXJlY3RseSBzbyB0aGF0IHVzZXJzIGRvIG5vdCBoYXZlIHRvIGZvcmsgdGhlaXIgY29kZS5cbi8vIFN1cHBvcnRpbmcgdGhlIGVudGlyZSBhcGkgbWF5IGJlIGNoYWxsZW5naW5nOiBlLmcuIGZpbHRlcmluZyBvdXRcbi8vIHJlbW92ZWQgbm9kZXMgaW4gdGhlIHdyb25nIHNjb3BlIGFuZCBzZWVpbmcgbm9uLWRpc3RyaWJ1dGluZ1xuLy8gc3VidHJlZSBjaGlsZCBtdXRhdGlvbnMuXG5leHBvcnQgbGV0IG9ic2VydmVDaGlsZHJlbiA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHNkID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgaWYgKCFzZC5vYnNlcnZlcikge1xuICAgIHNkLm9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIoKTtcbiAgfVxuICBzZC5vYnNlcnZlci5jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgbGV0IG9ic2VydmVyID0gc2Qub2JzZXJ2ZXI7XG4gIHJldHVybiB7XG4gICAgX2NhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBfb2JzZXJ2ZXI6IG9ic2VydmVyLFxuICAgIF9ub2RlOiBub2RlLFxuICAgIHRha2VSZWNvcmRzKCkge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLnRha2VSZWNvcmRzKClcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBsZXQgdW5vYnNlcnZlQ2hpbGRyZW4gPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgbGV0IG9ic2VydmVyID0gaGFuZGxlICYmIGhhbmRsZS5fb2JzZXJ2ZXI7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmNhbGxiYWNrcy5kZWxldGUoaGFuZGxlLl9jYWxsYmFjayk7XG4gICAgaWYgKCFvYnNlcnZlci5jYWxsYmFja3Muc2l6ZSkge1xuICAgICAgZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShoYW5kbGUuX25vZGUpLm9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlck11dGF0aW9ucyhtdXRhdGlvbnMsIHRhcmdldCkge1xuICAvKiogQGNvbnN0IHtOb2RlfSAqL1xuICBjb25zdCB0YXJnZXRSb290Tm9kZSA9IHRhcmdldC5nZXRSb290Tm9kZSgpO1xuICByZXR1cm4gbXV0YXRpb25zLm1hcChmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIC8qKiBAY29uc3Qge2Jvb2xlYW59ICovXG4gICAgY29uc3QgbXV0YXRpb25JblNjb3BlID0gKHRhcmdldFJvb3ROb2RlID09PSBtdXRhdGlvbi50YXJnZXQuZ2V0Um9vdE5vZGUoKSk7XG4gICAgaWYgKG11dGF0aW9uSW5TY29wZSAmJiBtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICBsZXQgbm9kZXMgPSBBcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAodGFyZ2V0Um9vdE5vZGUgPT09IG4uZ2V0Um9vdE5vZGUoKSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgbXV0YXRpb24gPSBPYmplY3QuY3JlYXRlKG11dGF0aW9uKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG11dGF0aW9uLCAnYWRkZWROb2RlcycsIHtcbiAgICAgICAgICB2YWx1ZTogbm9kZXMsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbXV0YXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtdXRhdGlvbkluU2NvcGUpIHtcbiAgICAgIHJldHVybiBtdXRhdGlvbjtcbiAgICB9XG4gIH0pLmZpbHRlcihmdW5jdGlvbihtKSB7IHJldHVybiBtfSk7XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4vLyBDcmliYmVkIGZyb20gU2hhZG93RE9NIHBvbHlmaWxsXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi9tYXN0ZXIvc3JjL1NoYWRvd0RPTS93cmFwcGVycy9IVE1MRWxlbWVudC5qcyNMMjhcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBpbm5lckhUTUwgYW5kIG91dGVySFRNTFxuXG4vLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtZW5kLmh0bWwjZXNjYXBpbmdTdHJpbmdcbmxldCBlc2NhcGVBdHRyUmVnRXhwID0gL1smXFx1MDBBMFwiXS9nO1xubGV0IGVzY2FwZURhdGFSZWdFeHAgPSAvWyZcXHUwMEEwPD5dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJlcGxhY2UoYykge1xuICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICcmJzpcbiAgICAgIHJldHVybiAnJmFtcDsnO1xuICAgIGNhc2UgJzwnOlxuICAgICAgcmV0dXJuICcmbHQ7JztcbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgY2FzZSAnXCInOlxuICAgICAgcmV0dXJuICcmcXVvdDsnO1xuICAgIGNhc2UgJ1xcdTAwQTAnOlxuICAgICAgcmV0dXJuICcmbmJzcDsnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUF0dHIocykge1xuICByZXR1cm4gcy5yZXBsYWNlKGVzY2FwZUF0dHJSZWdFeHAsIGVzY2FwZVJlcGxhY2UpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVEYXRhKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShlc2NhcGVEYXRhUmVnRXhwLCBlc2NhcGVSZXBsYWNlKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNldChhcnIpIHtcbiAgbGV0IHNldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHNldFthcnJbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc2V0O1xufVxuXG4vLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrLyN2b2lkLWVsZW1lbnRzXG5sZXQgdm9pZEVsZW1lbnRzID0gbWFrZVNldChbXG4gICdhcmVhJyxcbiAgJ2Jhc2UnLFxuICAnYnInLFxuICAnY29sJyxcbiAgJ2NvbW1hbmQnLFxuICAnZW1iZWQnLFxuICAnaHInLFxuICAnaW1nJyxcbiAgJ2lucHV0JyxcbiAgJ2tleWdlbicsXG4gICdsaW5rJyxcbiAgJ21ldGEnLFxuICAncGFyYW0nLFxuICAnc291cmNlJyxcbiAgJ3RyYWNrJyxcbiAgJ3dicidcbl0pO1xuXG5sZXQgcGxhaW50ZXh0UGFyZW50cyA9IG1ha2VTZXQoW1xuICAnc3R5bGUnLFxuICAnc2NyaXB0JyxcbiAgJ3htcCcsXG4gICdpZnJhbWUnLFxuICAnbm9lbWJlZCcsXG4gICdub2ZyYW1lcycsXG4gICdwbGFpbnRleHQnLFxuICAnbm9zY3JpcHQnXG5dKTtcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50Tm9kZVxuICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPdXRlckhUTUwobm9kZSwgcGFyZW50Tm9kZSwgY2FsbGJhY2spIHtcbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgbGV0IHRhZ05hbWUgPSBub2RlLmxvY2FsTmFtZTtcbiAgICAgIGxldCBzID0gJzwnICsgdGFnTmFtZTtcbiAgICAgIGxldCBhdHRycyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBhdHRyOyAoYXR0ciA9IGF0dHJzW2ldKTsgaSsrKSB7XG4gICAgICAgIHMgKz0gJyAnICsgYXR0ci5uYW1lICsgJz1cIicgKyBlc2NhcGVBdHRyKGF0dHIudmFsdWUpICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHMgKz0gJz4nO1xuICAgICAgaWYgKHZvaWRFbGVtZW50c1t0YWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzICsgZ2V0SW5uZXJIVE1MKG5vZGUsIGNhbGxiYWNrKSArICc8LycgKyB0YWdOYW1lICsgJz4nO1xuICAgIH1cbiAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICBsZXQgZGF0YSA9IC8qKiBAdHlwZSB7VGV4dH0gKi8gKG5vZGUpLmRhdGE7XG4gICAgICBpZiAocGFyZW50Tm9kZSAmJiBwbGFpbnRleHRQYXJlbnRzW3BhcmVudE5vZGUubG9jYWxOYW1lXSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlc2NhcGVEYXRhKGRhdGEpO1xuICAgIH1cbiAgICBjYXNlIE5vZGUuQ09NTUVOVF9OT0RFOiB7XG4gICAgICByZXR1cm4gJzwhLS0nICsgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSkuZGF0YSArICctLT4nO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihub2RlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElubmVySFRNTChub2RlLCBjYWxsYmFjaykge1xuICBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBub2RlID0gIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKG5vZGUpLmNvbnRlbnQ7XG4gIH1cbiAgbGV0IHMgPSAnJztcbiAgbGV0IGMkID0gY2FsbGJhY2sgPyBjYWxsYmFjayhub2RlKSA6IG5vZGUuY2hpbGROb2RlcztcbiAgZm9yIChsZXQgaT0wLCBsPWMkLmxlbmd0aCwgY2hpbGQ7IChpPGwpICYmIChjaGlsZD1jJFtpXSk7IGkrKykge1xuICAgIHMgKz0gZ2V0T3V0ZXJIVE1MKGNoaWxkLCBub2RlLCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge3BhdGNoUHJvcGVydGllc30gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge2dldElubmVySFRNTH0gZnJvbSAnLi9pbm5lckhUTUwuanMnO1xuXG5jb25zdCBoYXNEZXNjcmlwdG9ycyA9IHV0aWxzLnNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzO1xuZXhwb3J0IGNvbnN0IE5BVElWRV9QUkVGSVggPSB1dGlscy5OQVRJVkVfUFJFRklYO1xuXG4vLyBPYmplY3Qgb24gd2hpY2ggcmF3IG5hdGl2ZSBtZXRob2RzIGFyZSBzdG9yZWQuXG4vLyBlLmcuIGBuYXRpdmVNZXRob2RzLnF1ZXJ5U2VsZWN0b3IuY2FsbChub2RlLCBzZWxlY3RvcilgXG4vLyBzYW1lIGFzIGBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpYFxuZXhwb3J0IGNvbnN0IG5hdGl2ZU1ldGhvZHMgPSB7XG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgcXVlcnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzW05BVElWRV9QUkVGSVggKyAncXVlcnlTZWxlY3RvciddKHNlbGVjdG9yKTtcbiAgfSxcbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXNbTkFUSVZFX1BSRUZJWCArICdxdWVyeVNlbGVjdG9yQWxsJ10oc2VsZWN0b3IpO1xuICB9XG59O1xuLy8gT2JqZWN0IG9uIHdoaWNoIHJhdyBuYXRpdmUgYWNjZXNzb3JzIGFyZSBhdmFpbGFibGUgdmlhIGBhY2Nlc3Nvck5hbWUobm9kZSlgLlxuLy8gZS5nLiBgbmF0aXZlVHJlZS5maXJzdENoaWxkKG5vZGUpYFxuLy8gc2FtZSBhcyBgbm9kZS5maXJzdENoaWxkYFxuZXhwb3J0IGNvbnN0IG5hdGl2ZVRyZWUgPSB7fTtcblxuY29uc3QgaW5zdGFsbE5hdGl2ZUFjY2Vzc29yID0gKG5hbWUpID0+IHtcbiAgbmF0aXZlVHJlZVtuYW1lXSA9IChub2RlKSA9PiBub2RlW05BVElWRV9QUkVGSVggKyBuYW1lXTtcbn1cblxuY29uc3QgaW5zdGFsbE5hdGl2ZU1ldGhvZCA9IChuYW1lLCBmbikgPT4ge1xuICBpZiAoIW5hdGl2ZU1ldGhvZHNbbmFtZV0pIHtcbiAgICBuYXRpdmVNZXRob2RzW25hbWVdID0gZm47XG4gIH1cbn1cblxuXG5jb25zdCBkZWZpbmVOYXRpdmVBY2Nlc3NvcnMgPSAocHJvdG8sIGRlc2NyaXB0b3JzKSA9PiB7XG4gIHBhdGNoUHJvcGVydGllcyhwcm90bywgZGVzY3JpcHRvcnMsIE5BVElWRV9QUkVGSVgpO1xuICAvLyBtYWtlIG5hdGl2ZSBhY2Nlc3NvcnMgYXZhaWxhYmxlIHRvIHVzZXJzXG4gIGZvciAobGV0IHByb3AgaW4gZGVzY3JpcHRvcnMpIHtcbiAgICBpbnN0YWxsTmF0aXZlQWNjZXNzb3IocHJvcCk7XG4gIH1cbn1cblxuY29uc3QgY29weVByb3BlcnRpZXMgPSAocHJvdG8sIGxpc3QgPSBbXSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gbGlzdFtpXTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSk7XG4gICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgTkFUSVZFX1BSRUZJWCArIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgLy8gbWFrZSBuYXRpdmUgbWV0aG9kcy9hY2Nlc3NvcnMgYXZhaWxhYmxlIHRvIHVzZXJzXG4gICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICBpbnN0YWxsTmF0aXZlTWV0aG9kKG5hbWUsIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFsbE5hdGl2ZUFjY2Vzc29yKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQHR5cGUgeyFUcmVlV2Fsa2VyfSAqL1xuY29uc3Qgbm9kZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZG9jdW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19BTEwsXG4gIG51bGwsIGZhbHNlKTtcblxuLyoqIEB0eXBlIHshVHJlZVdhbGtlcn0gKi9cbmNvbnN0IGVsZW1lbnRXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcbiAgbnVsbCwgZmFsc2UpO1xuXG4vKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbmNvbnN0IGluZXJ0RG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdpbmVydCcpO1xuXG5jb25zdCBjbGVhck5vZGUgPSBub2RlID0+IHtcbiAgbGV0IGZpcnN0Q2hpbGQ7XG4gIHdoaWxlICgoZmlyc3RDaGlsZCA9IG5vZGVbTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ10pKSB7XG4gICAgbm9kZVtOQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10oZmlyc3RDaGlsZCk7XG4gIH1cbn1cblxuY29uc3QgUGFyZW50Tm9kZUFjY2Vzc29ycyA9IFtcbiAgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgJ2xhc3RFbGVtZW50Q2hpbGQnLFxuICAnY2hpbGRyZW4nLFxuICAnY2hpbGRFbGVtZW50Q291bnQnLFxuXTtcblxuY29uc3QgUGFyZW50Tm9kZU1ldGhvZHMgPSBbXG4gICdxdWVyeVNlbGVjdG9yJyxcbiAgJ3F1ZXJ5U2VsZWN0b3JBbGwnXG4gIC8vICdhcHBlbmQnLCAncHJlcGVuZCdcbl07XG5cbmV4cG9ydCBjb25zdCBhZGROYXRpdmVQcmVmaXhlZFByb3BlcnRpZXMgPSAoKSA9PiB7XG5cbiAgLy8gRXZlbnRUYXJnZXRcbiAgY29uc3QgZXZlbnRQcm9wcyA9IFtcbiAgICAnZGlzcGF0Y2hFdmVudCcsXG4gICAgJ2FkZEV2ZW50TGlzdGVuZXInLFxuICAgICdyZW1vdmVFdmVudExpc3RlbmVyJ1xuICBdO1xuICBpZiAod2luZG93LkV2ZW50VGFyZ2V0KSB7XG4gICAgY29weVByb3BlcnRpZXMod2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgZXZlbnRQcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgY29weVByb3BlcnRpZXMoTm9kZS5wcm90b3R5cGUsIGV2ZW50UHJvcHMpO1xuICAgIGNvcHlQcm9wZXJ0aWVzKFdpbmRvdy5wcm90b3R5cGUsIGV2ZW50UHJvcHMpO1xuICB9XG5cblxuICAvLyBOb2RlXG4gIGlmIChoYXNEZXNjcmlwdG9ycykge1xuICAgIGNvcHlQcm9wZXJ0aWVzKE5vZGUucHJvdG90eXBlLCBbXG4gICAgICAncGFyZW50Tm9kZScsXG4gICAgICAnZmlyc3RDaGlsZCcsXG4gICAgICAnbGFzdENoaWxkJyxcbiAgICAgICdwcmV2aW91c1NpYmxpbmcnLFxuICAgICAgJ25leHRTaWJsaW5nJyxcbiAgICAgICdjaGlsZE5vZGVzJyxcbiAgICAgICdwYXJlbnRFbGVtZW50JyxcbiAgICAgICd0ZXh0Q29udGVudCcsXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lTmF0aXZlQWNjZXNzb3JzKE5vZGUucHJvdG90eXBlLCB7XG4gICAgICBwYXJlbnROb2RlOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIG5vZGVXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBub2RlV2Fsa2VyLnBhcmVudE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZpcnN0Q2hpbGQ6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIG5vZGVXYWxrZXIuZmlyc3RDaGlsZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGFzdENoaWxkOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIG5vZGVXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBub2RlV2Fsa2VyLmxhc3RDaGlsZCgpO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1NpYmxpbmc6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIG5vZGVXYWxrZXIucHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBuZXh0U2libGluZzoge1xuICAgICAgICAvKiogQHRoaXMge05vZGV9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbm9kZVdhbGtlci5uZXh0U2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogbWFrZSB0aGlzIGEgTm9kZUxpc3Qgb3Igd2hhdGV2ZXJcbiAgICAgIGNoaWxkTm9kZXM6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgICBsZXQgbiA9IG5vZGVXYWxrZXIuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG4pO1xuICAgICAgICAgICAgbiA9IG5vZGVXYWxrZXIubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyZW50RWxlbWVudDoge1xuICAgICAgICAvKiogQHRoaXMge05vZGV9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gZWxlbWVudFdhbGtlci5wYXJlbnROb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0ZXh0Q29udGVudDoge1xuICAgICAgICAvKiogQHRoaXMge05vZGV9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuICAgICAgICAgIHN3aXRjaCAodGhpcy5ub2RlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBUaGlzIGNhbm5vdCBiZSBhIHNpbmdsZSBUcmVlV2Fsa2VyIHRoYXQncyByZXVzZWRcbiAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgZm9yIFNhZmFyaSA5LCBidXQgaXQncyB1bmNsZWFyIHdoeS5cbiAgICAgICAgICAgICAgY29uc3QgdGV4dFdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodGhpcywgTm9kZUZpbHRlci5TSE9XX1RFWFQsXG4gICAgICAgICAgICAgICAgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICBsZXQgY29udGVudCA9ICcnLCBuO1xuICAgICAgICAgICAgICB3aGlsZSAoIChuID0gdGV4dFdhbGtlci5uZXh0Tm9kZSgpKSApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBjYW4ndCB1c2UgdGV4dENvbnRlbnQgc2luY2Ugd2UgcGF0Y2ggaXQgb24gTm9kZS5wcm90b3R5cGUhXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgc2hvdWxkIHByb2JhYmx5IHBhdGNoIGl0IG9ubHkgb24gZWxlbWVudC5cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IG4ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTmVlZGVkIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3BlciBhY2Nlc3NvcnMgKGUuZy4gb2xkIHZlcnNpb25zIG9mIENocm9tZSlcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgICBjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAgICAgICAgY2xlYXJOb2RlKHRoaXMpO1xuICAgICAgICAgICAgICAvLyBEb2N1bWVudCBmcmFnbWVudHMgbXVzdCBoYXZlIG5vIGNoaWxkbm9kZXMgaWYgc2V0dGluZyBhIGJsYW5rIHN0cmluZ1xuICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCB8fCB0aGlzLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IG9sZCBDaHJvbWUgdmVyc2lvbnMgcmVxdWlyZSAybmQgYXJndW1lbnQgaGVyZVxuICAgICAgICAgICAgICAgIHRoaXNbTkFUSVZFX1BSRUZJWCArICdpbnNlcnRCZWZvcmUnXShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBjYW4ndCBkbyB0aGlzIGlmIHBhdGNoIG5vZGVWYWx1ZS5cbiAgICAgICAgICAgICAgdGhpcy5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb3B5UHJvcGVydGllcyhOb2RlLnByb3RvdHlwZSwgW1xuICAgICdhcHBlbmRDaGlsZCcsXG4gICAgJ2luc2VydEJlZm9yZScsXG4gICAgJ3JlbW92ZUNoaWxkJyxcbiAgICAncmVwbGFjZUNoaWxkJyxcbiAgICAnY2xvbmVOb2RlJyxcbiAgICAnY29udGFpbnMnXG4gIF0pO1xuXG4gIC8vIE5PVEUsIG9uIHNvbWUgYnJvd3NlcnMgSUUgMTEgLyBFZGdlIDE1IHNvbWUgcHJvcGVydGllcyBhcmUgaW5jb3JyZWN0bHkgb24gSFRNTEVsZW1lbnRcbiAgY29weVByb3BlcnRpZXMoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBbXG4gICAgJ3BhcmVudEVsZW1lbnQnLFxuICAgICdjb250YWlucydcbiAgXSk7XG5cbiAgY29uc3QgUGFyZW50Tm9kZVdhbGtlckRlc2NyaXB0b3JzID0ge1xuICAgIGZpcnN0RWxlbWVudENoaWxkOiB7XG4gICAgICAvKiogQHRoaXMge1BhcmVudE5vZGV9ICovXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGVsZW1lbnRXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZWxlbWVudFdhbGtlci5maXJzdENoaWxkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsYXN0RWxlbWVudENoaWxkOiB7XG4gICAgICAvKiogQHRoaXMge1BhcmVudE5vZGV9ICovXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGVsZW1lbnRXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZWxlbWVudFdhbGtlci5sYXN0Q2hpbGQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuOiB7XG4gICAgICAvKiogQHRoaXMge1BhcmVudE5vZGV9ICovXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgbGV0IG4gPSBlbGVtZW50V2Fsa2VyLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKG4pO1xuICAgICAgICAgIG4gPSBlbGVtZW50V2Fsa2VyLm5leHRTaWJsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNyZWF0ZVBvbHlmaWxsZWRIVE1MQ29sbGVjdGlvbihub2Rlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGlsZEVsZW1lbnRDb3VudDoge1xuICAgICAgLyoqIEB0aGlzIHtQYXJlbnROb2RlfSAqL1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRWxlbWVudFxuICBpZiAoaGFzRGVzY3JpcHRvcnMpIHtcbiAgICBjb3B5UHJvcGVydGllcyhFbGVtZW50LnByb3RvdHlwZSwgUGFyZW50Tm9kZUFjY2Vzc29ycyk7XG5cbiAgICBjb3B5UHJvcGVydGllcyhFbGVtZW50LnByb3RvdHlwZSwgW1xuICAgICAgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAgICAgJ25leHRFbGVtZW50U2libGluZycsXG4gICAgICAnaW5uZXJIVE1MJyxcbiAgICAgICdjbGFzc05hbWUnXG4gICAgXSk7XG5cbiAgICAvLyBOT1RFLCBvbiBzb21lIGJyb3dzZXJzIElFIDExIC8gRWRnZSAxNSBzb21lIHByb3BlcnRpZXMgYXJlIGluY29ycmVjdGx5IG9uIEhUTUxFbGVtZW50XG4gICAgY29weVByb3BlcnRpZXMoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBbXG4gICAgICAnY2hpbGRyZW4nLFxuICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAnY2xhc3NOYW1lJ1xuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZU5hdGl2ZUFjY2Vzc29ycyhFbGVtZW50LnByb3RvdHlwZSwgUGFyZW50Tm9kZVdhbGtlckRlc2NyaXB0b3JzKTtcbiAgICBkZWZpbmVOYXRpdmVBY2Nlc3NvcnMoRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAgIHByZXZpb3VzRWxlbWVudFNpYmxpbmc6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgZWxlbWVudFdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRXYWxrZXIucHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBuZXh0RWxlbWVudFNpYmxpbmc6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgZWxlbWVudFdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRXYWxrZXIubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGlubmVySFRNTDoge1xuICAgICAgICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0SW5uZXJIVE1MKHRoaXMsIHV0aWxzLm5hdGl2ZUNoaWxkTm9kZXNBcnJheSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5lZWRlZCBvbiBicm93c2VycyB0aGF0IGRvIG5vdCBwcm9wZXIgYWNjZXNzb3JzIChlLmcuIG9sZCB2ZXJzaW9ucyBvZiBDaHJvbWUpXG4gICAgICAgIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnID9cbiAgICAgICAgICAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMpLmNvbnRlbnQgOiB0aGlzO1xuICAgICAgICAgIGNsZWFyTm9kZShjb250ZW50KTtcbiAgICAgICAgICBjb25zdCBjb250YWluZXJOYW1lID0gdGhpcy5sb2NhbE5hbWUgfHwgJ2Rpdic7XG4gICAgICAgICAgbGV0IGh0bWxDb250YWluZXI7XG4gICAgICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZVVSSSB8fCB0aGlzLm5hbWVzcGFjZVVSSSA9PT0gaW5lcnREb2MubmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBodG1sQ29udGFpbmVyID0gaW5lcnREb2MuY3JlYXRlRWxlbWVudChjb250YWluZXJOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbENvbnRhaW5lciA9IGluZXJ0RG9jLmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5hbWVzcGFjZVVSSSwgY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWxDb250YWluZXIuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnID9cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8oaHRtbENvbnRhaW5lcikuY29udGVudCA6IGh0bWxDb250YWluZXI7XG4gICAgICAgICAgbGV0IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKChmaXJzdENoaWxkID0gbmV3Q29udGVudFtOQVRJVkVfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXSkpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG9sZCBDaHJvbWUgdmVyc2lvbnMgcmVxdWlyZSAybmQgYXJndW1lbnQgaGVyZVxuICAgICAgICAgICAgY29udGVudFtOQVRJVkVfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKGZpcnN0Q2hpbGQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xhc3NOYW1lOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvcHlQcm9wZXJ0aWVzKEVsZW1lbnQucHJvdG90eXBlLCBbXG4gICAgJ3NldEF0dHJpYnV0ZScsXG4gICAgJ2dldEF0dHJpYnV0ZScsXG4gICAgJ2hhc0F0dHJpYnV0ZScsXG4gICAgJ3JlbW92ZUF0dHJpYnV0ZScsXG4gICAgLy8gb24gb2xkZXIgU2FmYXJpLCB0aGVzZSBhcmUgb24gRWxlbWVudC5cbiAgICAnZm9jdXMnLFxuICAgICdibHVyJyxcbiAgXSk7XG4gIGNvcHlQcm9wZXJ0aWVzKEVsZW1lbnQucHJvdG90eXBlLCBQYXJlbnROb2RlTWV0aG9kcyk7XG5cbiAgLy8gSFRNTEVsZW1lbnRcbiAgY29weVByb3BlcnRpZXMoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBbXG4gICAgJ2ZvY3VzJyxcbiAgICAnYmx1cidcbiAgXSk7XG5cbiAgLy8gSFRNTFRlbXBsYXRlRWxlbWVudFxuICBpZiAod2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICBjb3B5UHJvcGVydGllcyh3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudC5wcm90b3R5cGUsIFsnaW5uZXJIVE1MJ10pO1xuICB9XG5cbiAgLy8gRG9jdW1lbnRGcmFnbWVudFxuICBpZiAoaGFzRGVzY3JpcHRvcnMpIHtcbiAgICAvLyBOT1RFLCBJRSAxMSBkb2VzIG5vdCBoYXZlIG9uIERvY3VtZW50RnJhZ21lbnRcbiAgICAvLyBmaXJzdEVsZW1lbnRDaGlsZFxuICAgIC8vIGxhc3RFbGVtZW50Q2hpbGRcbiAgICBjb3B5UHJvcGVydGllcyhEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSwgUGFyZW50Tm9kZUFjY2Vzc29ycyk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lTmF0aXZlQWNjZXNzb3JzKERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLCBQYXJlbnROb2RlV2Fsa2VyRGVzY3JpcHRvcnMpO1xuICB9XG5cbiAgY29weVByb3BlcnRpZXMoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVNZXRob2RzKTtcblxuICAvLyBEb2N1bWVudFxuICBpZiAoaGFzRGVzY3JpcHRvcnMpIHtcbiAgICBjb3B5UHJvcGVydGllcyhEb2N1bWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVBY2Nlc3NvcnMpO1xuICAgIGNvcHlQcm9wZXJ0aWVzKERvY3VtZW50LnByb3RvdHlwZSwgW1xuICAgICAgJ2FjdGl2ZUVsZW1lbnQnXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lTmF0aXZlQWNjZXNzb3JzKERvY3VtZW50LnByb3RvdHlwZSwgUGFyZW50Tm9kZVdhbGtlckRlc2NyaXB0b3JzKTtcbiAgfVxuXG4gIGNvcHlQcm9wZXJ0aWVzKERvY3VtZW50LnByb3RvdHlwZSwgW1xuICAgICdpbXBvcnROb2RlJyxcbiAgICAnZ2V0RWxlbWVudEJ5SWQnXG4gIF0pO1xuICBjb3B5UHJvcGVydGllcyhEb2N1bWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVNZXRob2RzKTtcblxufTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtlbnN1cmVTaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuL3NoYWR5LWRhdGEuanMnO1xuXG5leHBvcnQgY29uc3QgSW5zaWRlRGVzY3JpcHRvcnMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBjaGlsZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdjaGlsZE5vZGVzJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnbGFzdENoaWxkJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgY2hpbGRFbGVtZW50Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NoaWxkRWxlbWVudENvdW50J107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NoaWxkcmVuJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgZmlyc3RFbGVtZW50Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0RWxlbWVudENoaWxkJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgbGFzdEVsZW1lbnRDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnbGFzdEVsZW1lbnRDaGlsZCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHNoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3NoYWRvd1Jvb3QnXTtcbiAgfSxcblxufSk7XG5cbmV4cG9ydCBjb25zdCBUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICd0ZXh0Q29udGVudCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgc2V0IHRleHRDb250ZW50KHZhbHVlKSB7XG4gICAgdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAndGV4dENvbnRlbnQnXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGlubmVySFRNTCgpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnaW5uZXJIVE1MJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBzZXQgaW5uZXJIVE1MKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2lubmVySFRNTCddID0gdmFsdWU7XG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IE91dHNpZGVEZXNjcmlwdG9ycyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHBhcmVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudEVsZW1lbnQnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBwYXJlbnROb2RlKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgcHJldmlvdXNTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwcmV2aW91c1NpYmxpbmcnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBuZXh0RWxlbWVudFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRFbGVtZW50U2libGluZyddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHByZXZpb3VzRWxlbWVudFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBjbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NsYXNzTmFtZSddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgc2V0IGNsYXNzTmFtZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdjbGFzc05hbWUnXSA9IHZhbHVlO1xuICB9XG5cbn0pO1xuXG5mb3IgKGxldCBwcm9wIGluIEluc2lkZURlc2NyaXB0b3JzKSB7XG4gIEluc2lkZURlc2NyaXB0b3JzW3Byb3BdLmVudW1lcmFibGUgPSBmYWxzZTtcbn1cblxuZm9yIChsZXQgcHJvcCBpbiBUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzKSB7XG4gIFRleHRDb250ZW50SW5uZXJIVE1MRGVzY3JpcHRvcnNbcHJvcF0uZW51bWVyYWJsZSA9IGZhbHNlO1xufVxuXG5mb3IgKGxldCBwcm9wIGluIE91dHNpZGVEZXNjcmlwdG9ycykge1xuICBPdXRzaWRlRGVzY3JpcHRvcnNbcHJvcF0uZW51bWVyYWJsZSA9IGZhbHNlO1xufVxuXG5jb25zdCBub0luc3RhbmNlUGF0Y2hpbmcgPSB1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycyB8fCB1dGlscy5zZXR0aW5ncy5ub1BhdGNoO1xuXG4vLyBlbnN1cmUgYW4gZWxlbWVudCBoYXMgcGF0Y2hlZCBcIm91dHNpZGVcIiBhY2Nlc3NvcnM7IG5vLW9wIHdoZW4gbm90IG5lZWRlZFxuZXhwb3J0IGxldCBwYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzID0gbm9JbnN0YW5jZVBhdGNoaW5nID9cbiAgZnVuY3Rpb24oKSB7fSA6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZCA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUoZWxlbWVudCk7XG4gICAgaWYgKCFzZC5fX291dHNpZGVBY2Nlc3NvcnMpIHtcbiAgICAgIHNkLl9fb3V0c2lkZUFjY2Vzc29ycyA9IHRydWU7XG4gICAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMoZWxlbWVudCwgT3V0c2lkZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gIH1cblxuLy8gZW5zdXJlIGFuIGVsZW1lbnQgaGFzIHBhdGNoZWQgXCJpbnNpZGVcIiBhY2Nlc3NvcnM7IG5vLW9wIHdoZW4gbm90IG5lZWRlZFxuZXhwb3J0IGxldCBwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMgPSBub0luc3RhbmNlUGF0Y2hpbmcgP1xuICBmdW5jdGlvbigpIHt9IDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGNvbnN0IHNkID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShlbGVtZW50KTtcbiAgICBpZiAoIXNkLl9faW5zaWRlQWNjZXNzb3JzKSB7XG4gICAgICBzZC5fX2luc2lkZUFjY2Vzc29ycyA9IHRydWU7XG4gICAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMoZWxlbWVudCwgSW5zaWRlRGVzY3JpcHRvcnMpO1xuICAgICAgLy8gTk9URTogVGhlcmUgYXJlIGNvbXBhdGliaWxpdHkgaXNzdWVzIHdpdGggcGF0Y2hlcyBmb3IgYHRleHRDb250ZW50YFxuICAgICAgLy8gYW5kIGBpbm5lckhUTUxgIGJldHdlZW4gQ0UgYW5kIFNELiBTaW5jZSBTRCBwYXRjaGVzIGFyZSBhcHBsaWVkXG4gICAgICAvLyB2aWEgYFNoYWR5RE9NLnBhdGNoYCBhbmQgQ0UgcGF0Y2hlcyBhcmUgYXBwbGllZCBhcyB0aGUgdHJlZSBpcyB3YWxrZWQsXG4gICAgICAvLyBTRCBwYXRjaGVzIG92ZXJ3cml0ZSBDRSBwYXRjaGVzLlxuICAgICAgLy8gKiBXaGVuIFNEIGlzIGluIHBhdGNoaW5nIG1vZGUsIFNEIGNhbGxzIHRocm91Z2ggdG8gbmF0aXZlXG4gICAgICAvLyBtZXRob2RzIG5vdCBwYXRjaGVkIGJ5IENFIChzaW5jZSBTRCBpcyBhdCB0aGUgYm90dG9tKSBhbmQgQ0UgZG9lcyBub3RcbiAgICAgIC8vIHVwZ3JhZGUsIGNvbm5lY3QsIG9yIGRpc2Nvbm5lY3QgZWxlbWVudHMuIFRoZXJlZm9yZSBkbyAqbm90IHBhdGNoKlxuICAgICAgLy8gdGhlc2UgYWNjZXNzb3JzIGluIHRoaXMgY2FzZS5cbiAgICAgIC8vICogV2hlbiBTRCBpcyBpbiBgbm9QYXRjaGAgbW9kZSwgdGhlIFNEIHBhdGNoZXMgY2FsbCB0aHJvdWdoIHRvXG4gICAgICAvLyBcIm5hdGl2ZVwiIG1ldGhvZHMgdGhhdCBhcmUgcGF0Y2hlZCBieSBDRSAoc2luY2UgQ0UgaXMgYXQgdGhlIGJvdHRvbSkuXG4gICAgICAvLyBUaGVyZWZvcmUgY29udGludWUgdG8gcGF0Y2ggaW4gdGhpcyBjYXNlLlxuICAgICAgLy8gSWYgY3VzdG9tRWxlbWVudHMgaXMgbm90IGxvYWRlZCwgdGhlbiB0aGVzZSBhY2Nlc3NvcnMgc2hvdWxkIGJlXG4gICAgICAvLyBwYXRjaGVkIHNvIHRoZXkgd29yayBjb3JyZWN0bHkuXG4gICAgICBpZiAoIXdpbmRvd1snY3VzdG9tRWxlbWVudHMnXSB8fCB1dGlscy5zZXR0aW5ncy5ub1BhdGNoKSB7XG4gICAgICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhlbGVtZW50LCBUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7c2hhZHlEYXRhRm9yTm9kZX0gZnJvbSAnLi9zaGFkeS1kYXRhLmpzJztcblxuLypcbk1ha2UgdGhpcyBuYW1lIHVuaXF1ZSBzbyBpdCBpcyB1bmxpa2VseSB0byBjb25mbGljdCB3aXRoIHByb3BlcnRpZXMgb24gb2JqZWN0cyBwYXNzZWQgdG8gYGFkZEV2ZW50TGlzdGVuZXJgXG5odHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWRvbS9pc3N1ZXMvMTczXG4qL1xuY29uc3QgLyoqIHN0cmluZyAqLyBldmVudFdyYXBwZXJzTmFtZSA9IGBfX2V2ZW50V3JhcHBlcnMke0RhdGUubm93KCl9YDtcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oIUV2ZW50KTogYm9vbGVhbn0gKi9cbmNvbnN0IGNvbXBvc2VkR2V0dGVyID0gKCgpID0+IHtcbiAgY29uc3QgY29tcG9zZWRQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFdmVudC5wcm90b3R5cGUsICdjb21wb3NlZCcpO1xuICByZXR1cm4gY29tcG9zZWRQcm9wID8gKGV2KSA9PiBjb21wb3NlZFByb3AuZ2V0LmNhbGwoZXYpIDogbnVsbDtcbn0pKCk7XG5cbmNvbnN0IHN1cHBvcnRzRXZlbnRPcHRpb25zID0gKCgpID0+IHtcbiAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICBsZXQgZXZlbnRPcHRpb25zID0ge1xuICAgIGdldCBjYXB0dXJlKCkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbGlzdGVuZXIgPSAoKSA9PiB7fVxuICAvLyBOT1RFOiBUaGVzZSB3aWxsIGJlIHVucGF0Y2hlZCBhdCB0aGlzIHBvaW50LlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBldmVudE9wdGlvbnMpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIGxpc3RlbmVyLCBldmVudE9wdGlvbnMpO1xuICByZXR1cm4gc3VwcG9ydGVkO1xufSkoKTtcblxuY29uc3QgcGFyc2VFdmVudE9wdGlvbnMgPSAob3B0aW9uc09yQ2FwdHVyZSkgPT4ge1xuICBsZXQgY2FwdHVyZSwgb25jZSwgcGFzc2l2ZSwgc2hhZHlUYXJnZXQ7XG4gIGlmIChvcHRpb25zT3JDYXB0dXJlICYmIHR5cGVvZiBvcHRpb25zT3JDYXB0dXJlID09PSAnb2JqZWN0Jykge1xuICAgIGNhcHR1cmUgPSBCb29sZWFuKG9wdGlvbnNPckNhcHR1cmUuY2FwdHVyZSk7XG4gICAgb25jZSA9IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZS5vbmNlKTtcbiAgICBwYXNzaXZlID0gQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlLnBhc3NpdmUpO1xuICAgIHNoYWR5VGFyZ2V0ID0gb3B0aW9uc09yQ2FwdHVyZS5fX3NoYWR5VGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIGNhcHR1cmUgPSBCb29sZWFuKG9wdGlvbnNPckNhcHR1cmUpO1xuICAgIG9uY2UgPSBmYWxzZTtcbiAgICBwYXNzaXZlID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaGFkeVRhcmdldCxcbiAgICBjYXB0dXJlLFxuICAgIG9uY2UsXG4gICAgcGFzc2l2ZSxcbiAgICBuYXRpdmVFdmVudE9wdGlvbnM6IHN1cHBvcnRzRXZlbnRPcHRpb25zID8gb3B0aW9uc09yQ2FwdHVyZSA6IGNhcHR1cmVcbiAgfVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYmNvbXBvbmVudHMvaXNzdWVzLzUxMyNpc3N1ZWNvbW1lbnQtMjI0MTgzOTM3XG5jb25zdCBhbHdheXNDb21wb3NlZCA9IHtcbiAgJ2JsdXInOiB0cnVlLFxuICAnZm9jdXMnOiB0cnVlLFxuICAnZm9jdXNpbic6IHRydWUsXG4gICdmb2N1c291dCc6IHRydWUsXG4gICdjbGljayc6IHRydWUsXG4gICdkYmxjbGljayc6IHRydWUsXG4gICdtb3VzZWRvd24nOiB0cnVlLFxuICAnbW91c2VlbnRlcic6IHRydWUsXG4gICdtb3VzZWxlYXZlJzogdHJ1ZSxcbiAgJ21vdXNlbW92ZSc6IHRydWUsXG4gICdtb3VzZW91dCc6IHRydWUsXG4gICdtb3VzZW92ZXInOiB0cnVlLFxuICAnbW91c2V1cCc6IHRydWUsXG4gICd3aGVlbCc6IHRydWUsXG4gICdiZWZvcmVpbnB1dCc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlkb3duJzogdHJ1ZSxcbiAgJ2tleXVwJzogdHJ1ZSxcbiAgJ2NvbXBvc2l0aW9uc3RhcnQnOiB0cnVlLFxuICAnY29tcG9zaXRpb251cGRhdGUnOiB0cnVlLFxuICAnY29tcG9zaXRpb25lbmQnOiB0cnVlLFxuICAndG91Y2hzdGFydCc6IHRydWUsXG4gICd0b3VjaGVuZCc6IHRydWUsXG4gICd0b3VjaG1vdmUnOiB0cnVlLFxuICAndG91Y2hjYW5jZWwnOiB0cnVlLFxuICAncG9pbnRlcm92ZXInOiB0cnVlLFxuICAncG9pbnRlcmVudGVyJzogdHJ1ZSxcbiAgJ3BvaW50ZXJkb3duJzogdHJ1ZSxcbiAgJ3BvaW50ZXJtb3ZlJzogdHJ1ZSxcbiAgJ3BvaW50ZXJ1cCc6IHRydWUsXG4gICdwb2ludGVyY2FuY2VsJzogdHJ1ZSxcbiAgJ3BvaW50ZXJvdXQnOiB0cnVlLFxuICAncG9pbnRlcmxlYXZlJzogdHJ1ZSxcbiAgJ2dvdHBvaW50ZXJjYXB0dXJlJzogdHJ1ZSxcbiAgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6IHRydWUsXG4gICdkcmFnc3RhcnQnOiB0cnVlLFxuICAnZHJhZyc6IHRydWUsXG4gICdkcmFnZW50ZXInOiB0cnVlLFxuICAnZHJhZ2xlYXZlJzogdHJ1ZSxcbiAgJ2RyYWdvdmVyJzogdHJ1ZSxcbiAgJ2Ryb3AnOiB0cnVlLFxuICAnZHJhZ2VuZCc6IHRydWUsXG4gICdET01BY3RpdmF0ZSc6IHRydWUsXG4gICdET01Gb2N1c0luJzogdHJ1ZSxcbiAgJ0RPTUZvY3VzT3V0JzogdHJ1ZSxcbiAgJ2tleXByZXNzJzogdHJ1ZVxufTtcblxuY29uc3QgdW5wYXRjaGVkRXZlbnRzID0ge1xuICAnRE9NQXR0ck1vZGlmaWVkJzogdHJ1ZSxcbiAgJ0RPTUF0dHJpYnV0ZU5hbWVDaGFuZ2VkJzogdHJ1ZSxcbiAgJ0RPTUNoYXJhY3RlckRhdGFNb2RpZmllZCc6IHRydWUsXG4gICdET01FbGVtZW50TmFtZUNoYW5nZWQnOiB0cnVlLFxuICAnRE9NTm9kZUluc2VydGVkJzogdHJ1ZSxcbiAgJ0RPTU5vZGVJbnNlcnRlZEludG9Eb2N1bWVudCc6IHRydWUsXG4gICdET01Ob2RlUmVtb3ZlZCc6IHRydWUsXG4gICdET01Ob2RlUmVtb3ZlZEZyb21Eb2N1bWVudCc6IHRydWUsXG4gICdET01TdWJ0cmVlTW9kaWZpZWQnOiB0cnVlXG59XG5cbi8qKlxuICogU29tZSBFdmVudFRhcmdldCBzdWJjbGFzc2VzIGFyZSBub3QgTm9kZSBzdWJjbGFzc2VzLCBhbmQgeW91IGNhbm5vdCBjYWxsXG4gKiBgZ2V0Um9vdE5vZGUoKWAgb24gdGhlbS5cbiAqXG4gKiBAcGFyYW0geyEoTm9kZXxFdmVudFRhcmdldCl9IGV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHshKE5vZGV8RXZlbnRUYXJnZXQpfVxuICovXG5mdW5jdGlvbiBnZXRSb290Tm9kZVdpdGhGYWxsYmFjayhldmVudFRhcmdldCkge1xuICBpZiAoZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgcmV0dXJuIGV2ZW50VGFyZ2V0W3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV2ZW50VGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhdGhDb21wb3NlcihzdGFydE5vZGUsIGNvbXBvc2VkKSB7XG4gIGxldCBjb21wb3NlZFBhdGggPSBbXTtcbiAgbGV0IGN1cnJlbnQgPSBzdGFydE5vZGU7XG4gIGxldCBzdGFydFJvb3QgPSBnZXRSb290Tm9kZVdpdGhGYWxsYmFjayhzdGFydE5vZGUpO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIGNvbXBvc2VkUGF0aC5wdXNoKGN1cnJlbnQpO1xuICAgIGlmIChjdXJyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdhc3NpZ25lZFNsb3QnXSkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Fzc2lnbmVkU2xvdCddO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGN1cnJlbnQuaG9zdCAmJiAoY29tcG9zZWQgfHwgY3VycmVudCAhPT0gc3RhcnRSb290KSkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQuaG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnRbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgICB9XG4gIH1cbiAgLy8gZXZlbnQgY29tcG9zZWRQYXRoIGluY2x1ZGVzIHdpbmRvdyB3aGVuIHN0YXJ0Tm9kZSdzIG93bmVyUm9vdCBpcyBkb2N1bWVudFxuICBpZiAoY29tcG9zZWRQYXRoW2NvbXBvc2VkUGF0aC5sZW5ndGggLSAxXSA9PT0gZG9jdW1lbnQpIHtcbiAgICBjb21wb3NlZFBhdGgucHVzaCh3aW5kb3cpO1xuICB9XG4gIHJldHVybiBjb21wb3NlZFBhdGg7XG59XG5cbmV4cG9ydCBjb25zdCBjb21wb3NlZFBhdGggPSAoZXZlbnQpID0+IHtcbiAgaWYgKCFldmVudC5fX2NvbXBvc2VkUGF0aCkge1xuICAgIGV2ZW50Ll9fY29tcG9zZWRQYXRoID0gcGF0aENvbXBvc2VyKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIGV2ZW50Ll9fY29tcG9zZWRQYXRoO1xufVxuXG5mdW5jdGlvbiByZXRhcmdldChyZWZOb2RlLCBwYXRoKSB7XG4gIGlmICghdXRpbHMuaXNTaGFkeVJvb3QpIHtcbiAgICByZXR1cm4gcmVmTm9kZTtcbiAgfVxuICAvLyBJZiBBTkNFU1RPUidzIHJvb3QgaXMgbm90IGEgc2hhZG93IHJvb3Qgb3IgQU5DRVNUT1IncyByb290IGlzIEJBU0Unc1xuICAvLyBzaGFkb3ctaW5jbHVkaW5nIGluY2x1c2l2ZSBhbmNlc3RvciwgcmV0dXJuIEFOQ0VTVE9SLlxuICBsZXQgcmVmTm9kZVBhdGggPSBwYXRoQ29tcG9zZXIocmVmTm9kZSwgdHJ1ZSk7XG4gIGxldCBwJCA9IHBhdGg7XG4gIGZvciAobGV0IGk9MCwgYW5jZXN0b3IsIGxhc3RSb290LCByb290LCByb290SWR4OyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICBhbmNlc3RvciA9IHAkW2ldO1xuICAgIHJvb3QgPSBnZXRSb290Tm9kZVdpdGhGYWxsYmFjayhhbmNlc3Rvcik7XG4gICAgaWYgKHJvb3QgIT09IGxhc3RSb290KSB7XG4gICAgICByb290SWR4ID0gcmVmTm9kZVBhdGguaW5kZXhPZihyb290KTtcbiAgICAgIGxhc3RSb290ID0gcm9vdDtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5pc1NoYWR5Um9vdChyb290KSB8fCByb290SWR4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gIH1cbn1cblxubGV0IEV2ZW50UGF0Y2hlcyA9IHtcblxuICAvKipcbiAgICogQHRoaXMge0V2ZW50fVxuICAgKi9cbiAgZ2V0IGNvbXBvc2VkKCkge1xuICAgIGlmICh0aGlzLl9fY29tcG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gaWYgdGhlcmUncyBhbiBvcmlnaW5hbCBgY29tcG9zZWRgIGdldHRlciBvbiB0aGUgRXZlbnQgcHJvdG90eXBlLCB1c2UgdGhhdFxuICAgICAgaWYgKGNvbXBvc2VkR2V0dGVyKSB7XG4gICAgICAgIC8vIFRPRE8od2ViLXBhZGF3YW4pOiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHlkb20vaXNzdWVzLzI3NVxuICAgICAgICB0aGlzLl9fY29tcG9zZWQgPSB0aGlzLnR5cGUgPT09ICdmb2N1c2luJyB8fCB0aGlzLnR5cGUgPT09ICdmb2N1c291dCcgfHwgY29tcG9zZWRHZXR0ZXIodGhpcyk7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgdHJ1c3RlZCwgb3IgYGlzVHJ1c3RlZGAgaXMgbm90IHN1cHBvcnRlZCwgY2hlY2sgdGhlIGxpc3Qgb2YgYWx3YXlzIGNvbXBvc2VkIGV2ZW50c1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVHJ1c3RlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fX2NvbXBvc2VkID0gYWx3YXlzQ29tcG9zZWRbdGhpcy50eXBlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUV2ZW50fSAqLyh0aGlzKS5fX2NvbXBvc2VkIHx8IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RXZlbnR9XG4gICAqL1xuICBjb21wb3NlZFBhdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9fY29tcG9zZWRQYXRoKSB7XG4gICAgICB0aGlzLl9fY29tcG9zZWRQYXRoID0gcGF0aENvbXBvc2VyKHRoaXNbJ19fdGFyZ2V0J10sIHRoaXMuY29tcG9zZWQpO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHshRXZlbnR9ICovKHRoaXMpLl9fY29tcG9zZWRQYXRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RXZlbnR9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiByZXRhcmdldCh0aGlzLmN1cnJlbnRUYXJnZXQgfHwgdGhpc1snX19wcmV2aW91c0N1cnJlbnRUYXJnZXQnXSwgdGhpcy5jb21wb3NlZFBhdGgoKSk7XG4gIH0sXG5cbiAgLy8gaHR0cDovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL3NoYWRvdy8jZXZlbnQtcmVsYXRlZHRhcmdldC1yZXRhcmdldGluZ1xuICAvKipcbiAgICogQHRoaXMge0V2ZW50fVxuICAgKi9cbiAgZ2V0IHJlbGF0ZWRUYXJnZXQoKSB7XG4gICAgaWYgKCF0aGlzLl9fcmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghdGhpcy5fX3JlbGF0ZWRUYXJnZXRDb21wb3NlZFBhdGgpIHtcbiAgICAgIHRoaXMuX19yZWxhdGVkVGFyZ2V0Q29tcG9zZWRQYXRoID0gcGF0aENvbXBvc2VyKHRoaXMuX19yZWxhdGVkVGFyZ2V0LCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgZGVlcGVzdCBub2RlIGluIHJlbGF0ZWRUYXJnZXQgY29tcG9zZWQgcGF0aCB0aGF0IGlzIGluIHRoZSBzYW1lIHJvb3Qgd2l0aCB0aGUgY3VycmVudFRhcmdldFxuICAgIHJldHVybiByZXRhcmdldCh0aGlzLmN1cnJlbnRUYXJnZXQgfHwgdGhpc1snX19wcmV2aW91c0N1cnJlbnRUYXJnZXQnXSwgLyoqIEB0eXBlIHshRXZlbnR9ICovKHRoaXMpLl9fcmVsYXRlZFRhcmdldENvbXBvc2VkUGF0aCk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7RXZlbnR9XG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX19wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0V2ZW50fVxuICAgKi9cbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIEV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9faW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9fcHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBtaXhpbkNvbXBvc2VkRmxhZyhCYXNlKSB7XG4gIC8vIE5PVEU6IGF2b2lkaW5nIHVzZSBvZiBgY2xhc3NgIGhlcmUgc28gdGhhdCB0cmFuc3BpbGVkIG91dHB1dCBkb2VzIG5vdFxuICAvLyB0cnkgdG8gZG8gYEJhc2UuY2FsbGAgd2l0aCBhIGRvbSBjb25zdHJ1dG9yLlxuICBsZXQga2xhenogPSBmdW5jdGlvbih0eXBlLCBvcHRpb25zKSB7XG4gICAgbGV0IGV2ZW50ID0gbmV3IEJhc2UodHlwZSwgb3B0aW9ucyk7XG4gICAgZXZlbnQuX19jb21wb3NlZCA9IG9wdGlvbnMgJiYgQm9vbGVhbihvcHRpb25zWydjb21wb3NlZCddKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLy8gcHV0IGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgb24gc3ViY2xhc3NcbiAga2xhenouX19wcm90b19fID0gQmFzZTtcbiAga2xhenoucHJvdG90eXBlID0gQmFzZS5wcm90b3R5cGU7XG4gIHJldHVybiBrbGF6ejtcbn1cblxubGV0IG5vbkJ1YmJsaW5nRXZlbnRzVG9SZXRhcmdldCA9IHtcbiAgJ2ZvY3VzJzogdHJ1ZSxcbiAgJ2JsdXInOiB0cnVlXG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcyBiZWVuIHJldGFyZ2V0ZWQgYnkgY29tcGFyaW5nIG9yaWdpbmFsIGB0YXJnZXRgLCBhbmQgY2FsY3VsYXRlZCBgdGFyZ2V0YFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9yaWdpbmFsIHRhcmdldCBhbmQgY2FsY3VsYXRlZCB0YXJnZXQgYXJlIHRoZSBzYW1lXG4gKi9cbmZ1bmN0aW9uIGhhc1JldGFyZ2V0ZWQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50WydfX3RhcmdldCddICE9PSBldmVudC50YXJnZXQgfHwgZXZlbnQuX19yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5yZWxhdGVkVGFyZ2V0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGhhc2VcbiAqL1xuZnVuY3Rpb24gZmlyZUhhbmRsZXJzKGV2ZW50LCBub2RlLCBwaGFzZSkge1xuICBsZXQgaHMgPSBub2RlLl9faGFuZGxlcnMgJiYgbm9kZS5fX2hhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgbm9kZS5fX2hhbmRsZXJzW2V2ZW50LnR5cGVdW3BoYXNlXTtcbiAgaWYgKGhzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGZuOyAoZm4gPSBoc1tpXSk7IGkrKykge1xuICAgICAgaWYgKGhhc1JldGFyZ2V0ZWQoZXZlbnQpICYmIGV2ZW50LnRhcmdldCA9PT0gZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmbi5jYWxsKG5vZGUsIGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5fX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldGFyZ2V0Tm9uQnViYmxpbmdFdmVudChlKSB7XG4gIGxldCBwYXRoID0gZS5jb21wb3NlZFBhdGgoKTtcbiAgbGV0IG5vZGU7XG4gIC8vIG92ZXJyaWRlIGBjdXJyZW50VGFyZ2V0YCB0byBsZXQgcGF0Y2hlZCBgdGFyZ2V0YCBjYWxjdWxhdGUgY29ycmVjdGx5XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY3VycmVudFRhcmdldCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbm9kZSA9IHBhdGhbaV07XG4gICAgLy8gY2FwdHVyZSBwaGFzZSBmaXJlcyBhbGwgY2FwdHVyZSBoYW5kbGVyc1xuICAgIGZpcmVIYW5kbGVycyhlLCBub2RlLCAnY2FwdHVyZScpO1xuICAgIGlmIChlLl9fcHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHRoZSBldmVudCBwaGFzZSB0byBgQVRfVEFSR0VUYCBhcyBpbiBzcGVjXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnZXZlbnRQaGFzZScsIHtnZXQoKSB7IHJldHVybiBFdmVudC5BVF9UQVJHRVQgfX0pO1xuXG4gIC8vIHRoZSBldmVudCBvbmx5IG5lZWRzIHRvIGJlIGZpcmVkIHdoZW4gb3duZXIgcm9vdHMgY2hhbmdlIHdoZW4gaXRlcmF0aW5nIHRoZSBldmVudCBwYXRoXG4gIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3Qgc2VlbiBvd25lciByb290XG4gIGxldCBsYXN0RmlyZWRSb290O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gcGF0aFtpXTtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGVEYXRhICYmIG5vZGVEYXRhLnJvb3Q7XG4gICAgaWYgKGkgPT09IDAgfHwgKHJvb3QgJiYgcm9vdCA9PT0gbGFzdEZpcmVkUm9vdCkpIHtcbiAgICAgIGZpcmVIYW5kbGVycyhlLCBub2RlLCAnYnViYmxlJyk7XG4gICAgICAvLyBkb24ndCBib3RoZXIgd2l0aCB3aW5kb3csIGl0IGRvZXNuJ3QgaGF2ZSBgZ2V0Um9vdE5vZGVgIGFuZCB3aWxsIGJlIGxhc3QgaW4gdGhlIHBhdGggYW55d2F5XG4gICAgICBpZiAobm9kZSAhPT0gd2luZG93KSB7XG4gICAgICAgIGxhc3RGaXJlZFJvb3QgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKCk7XG4gICAgICB9XG4gICAgICBpZiAoZS5fX3Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxpc3RlbmVyU2V0dGluZ3NFcXVhbChzYXZlZExpc3RlbmVyLCBub2RlLCB0eXBlLCBjYXB0dXJlLCBvbmNlLCBwYXNzaXZlKSB7XG4gIGxldCB7XG4gICAgbm9kZTogc2F2ZWROb2RlLFxuICAgIHR5cGU6IHNhdmVkVHlwZSxcbiAgICBjYXB0dXJlOiBzYXZlZENhcHR1cmUsXG4gICAgb25jZTogc2F2ZWRPbmNlLFxuICAgIHBhc3NpdmU6IHNhdmVkUGFzc2l2ZVxuICB9ID0gc2F2ZWRMaXN0ZW5lcjtcbiAgcmV0dXJuIG5vZGUgPT09IHNhdmVkTm9kZSAmJlxuICAgIHR5cGUgPT09IHNhdmVkVHlwZSAmJlxuICAgIGNhcHR1cmUgPT09IHNhdmVkQ2FwdHVyZSAmJlxuICAgIG9uY2UgPT09IHNhdmVkT25jZSAmJlxuICAgIHBhc3NpdmUgPT09IHNhdmVkUGFzc2l2ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMaXN0ZW5lcih3cmFwcGVycywgbm9kZSwgdHlwZSwgY2FwdHVyZSwgb25jZSwgcGFzc2l2ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RlbmVyU2V0dGluZ3NFcXVhbCh3cmFwcGVyc1tpXSwgbm9kZSwgdHlwZSwgY2FwdHVyZSwgb25jZSwgcGFzc2l2ZSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogRmlyZWZveCBjYW4gdGhyb3cgb24gYWNjZXNzaW5nIGV2ZW50V3JhcHBlcnMgaW5zaWRlIG9mIGByZW1vdmVFdmVudExpc3RlbmVyYCBkdXJpbmcgYSBzZWxlbml1bSBydW5cbiAqIFRyeS9DYXRjaCBhY2Nlc3NpbmcgZXZlbnRXcmFwcGVycyB0byB3b3JrIGFyb3VuZFxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM1MzA3NFxuICovXG5mdW5jdGlvbiBnZXRFdmVudFdyYXBwZXJzKGV2ZW50TGlrZSkge1xuICBsZXQgd3JhcHBlcnMgPSBudWxsO1xuICB0cnkge1xuICAgIHdyYXBwZXJzID0gZXZlbnRMaWtlW2V2ZW50V3JhcHBlcnNOYW1lXTtcbiAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICByZXR1cm4gd3JhcHBlcnM7XG59XG5cbmZ1bmN0aW9uIHRhcmdldE5lZWRzUGF0aENoZWNrKG5vZGUpIHtcbiAgcmV0dXJuIHV0aWxzLmlzU2hhZHlSb290KG5vZGUpIHx8IG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCc7XG59XG5cbi8qKlxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbk9yT2JqLCBvcHRpb25zT3JDYXB0dXJlKSB7XG4gIGNvbnN0IHtjYXB0dXJlLCBvbmNlLCBwYXNzaXZlLCBzaGFkeVRhcmdldCwgbmF0aXZlRXZlbnRPcHRpb25zfSA9XG4gICAgcGFyc2VFdmVudE9wdGlvbnMob3B0aW9uc09yQ2FwdHVyZSk7XG4gIGlmICghZm5Pck9iaikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZXJUeXBlID0gdHlwZW9mIGZuT3JPYmo7XG5cbiAgLy8gYmFpbCBpZiBgZm5Pck9iamAgaXMgbm90IGEgZnVuY3Rpb24sIG5vdCBhbiBvYmplY3RcbiAgaWYgKGhhbmRsZXJUeXBlICE9PSAnZnVuY3Rpb24nICYmIGhhbmRsZXJUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGJhaWwgaWYgYGZuT3JPYmpgIGlzIGFuIG9iamVjdCB3aXRob3V0IGEgYGhhbmRsZUV2ZW50YCBtZXRob2RcbiAgaWYgKGhhbmRsZXJUeXBlID09PSAnb2JqZWN0JyAmJiAoIWZuT3JPYmouaGFuZGxlRXZlbnQgfHwgdHlwZW9mIGZuT3JPYmouaGFuZGxlRXZlbnQgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHVucGF0Y2hlZEV2ZW50c1t0eXBlXSkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnYWRkRXZlbnRMaXN0ZW5lciddKHR5cGUsIGZuT3JPYmosIG5hdGl2ZUV2ZW50T3B0aW9ucyk7XG4gIH1cblxuICAvLyBoYWNrIHRvIGxldCBTaGFkeVJvb3RzIGhhdmUgZXZlbnQgbGlzdGVuZXJzXG4gIC8vIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgb24gaG9zdCwgYnV0IGBjdXJyZW50VGFyZ2V0YFxuICAvLyB3aWxsIGJlIHNldCB0byBzaGFkeXJvb3QgZm9yIGV2ZW50IGxpc3RlbmVyXG4gIGxldCB0YXJnZXQgPSBzaGFkeVRhcmdldCB8fCB0aGlzO1xuXG4gIGxldCB3cmFwcGVycyA9IGZuT3JPYmpbZXZlbnRXcmFwcGVyc05hbWVdO1xuICBpZiAod3JhcHBlcnMpIHtcbiAgICAvLyBUaGUgY2FsbGJhY2sgYGZuYCBtaWdodCBiZSB1c2VkIGZvciBtdWx0aXBsZSBub2Rlcy9ldmVudHMuIFNpbmNlIHdlIGdlbmVyYXRlXG4gICAgLy8gYSB3cmFwcGVyIGZ1bmN0aW9uLCB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaXQgd2hlbiB3ZSByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgIC8vIEl0J3MgbW9yZSBlZmZpY2llbnQgdG8gc3RvcmUgdGhlIG5vZGUvdHlwZS9vcHRpb25zIGluZm9ybWF0aW9uIGFzIEFycmF5IGluXG4gICAgLy8gYGZuYCBpdHNlbGYgcmF0aGVyIHRoYW4gdGhlIG5vZGUgKHdlIGFzc3VtZSB0aGF0IHRoZSBzYW1lIGNhbGxiYWNrIGlzIHVzZWRcbiAgICAvLyBmb3IgZmV3IG5vZGVzIGF0IG1vc3QsIHdoZXJlYXMgYSBub2RlIHdpbGwgbGlrZWx5IGhhdmUgbWFueSBldmVudCBsaXN0ZW5lcnMpLlxuICAgIC8vIE5PVEUodmFsZHJpbikgaW52b2tpbmcgZXh0ZXJuYWwgZnVuY3Rpb25zIGlzIGNvc3RseSwgaW5saW5lIGhhcyBiZXR0ZXIgcGVyZi5cbiAgICAvLyBTdG9wIGlmIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5cbiAgICBpZiAoZmluZExpc3RlbmVyKHdyYXBwZXJzLCB0YXJnZXQsIHR5cGUsIGNhcHR1cmUsIG9uY2UsIHBhc3NpdmUpID4gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm5Pck9ialtldmVudFdyYXBwZXJzTmFtZV0gPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGNvbnN0IHdyYXBwZXJGbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBTdXBwb3J0IGBvbmNlYCBvcHRpb24uXG4gICAgaWYgKG9uY2UpIHtcbiAgICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3JlbW92ZUV2ZW50TGlzdGVuZXInXSh0eXBlLCBmbk9yT2JqLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgICB9XG4gICAgaWYgKCFlWydfX3RhcmdldCddKSB7XG4gICAgICBwYXRjaEV2ZW50KGUpO1xuICAgIH1cbiAgICBsZXQgbGFzdEN1cnJlbnRUYXJnZXREZXNjO1xuICAgIGlmICh0YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgIC8vIHJlcGxhY2UgYGN1cnJlbnRUYXJnZXRgIHRvIG1ha2UgYHRhcmdldGAgYW5kIGByZWxhdGVkVGFyZ2V0YCBjb3JyZWN0IGZvciBpbnNpZGUgdGhlIHNoYWRvd3Jvb3RcbiAgICAgIGxhc3RDdXJyZW50VGFyZ2V0RGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgJ2N1cnJlbnRUYXJnZXQnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY3VycmVudFRhcmdldCcsIHtnZXQoKSB7IHJldHVybiB0YXJnZXQgfSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgfVxuICAgIGVbJ19fcHJldmlvdXNDdXJyZW50VGFyZ2V0J10gPSBlWydjdXJyZW50VGFyZ2V0J107XG4gICAgLy8gQWx3YXlzIGNoZWNrIGlmIGEgc2hhZG93Um9vdCBvciBzbG90IGlzIGluIHRoZSBjdXJyZW50IGV2ZW50IHBhdGguXG4gICAgLy8gSWYgaXQgaXMgbm90LCB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBvbiBlaXRoZXIgdGhlIGhvc3Qgb2YgdGhlIHNoYWRvd1Jvb3RcbiAgICAvLyBvciBhIGNoaWxkcmVuIG9mIHRoZSBob3N0LlxuICAgIGlmICh0YXJnZXROZWVkc1BhdGhDaGVjayh0YXJnZXQpICYmIGUuY29tcG9zZWRQYXRoKCkuaW5kZXhPZih0YXJnZXQpID09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXJlIGFyZSB0d28gY3JpdGVyYSB0aGF0IHNob3VsZCBzdG9wIGV2ZW50cyBmcm9tIGZpcmluZyBvbiB0aGlzIG5vZGVcbiAgICAvLyAxLiB0aGUgZXZlbnQgaXMgbm90IGNvbXBvc2VkIGFuZCB0aGUgY3VycmVudCBub2RlIGlzIG5vdCBpbiB0aGUgc2FtZSByb290IGFzIHRoZSB0YXJnZXRcbiAgICAvLyAyLiB3aGVuIGJ1YmJsaW5nLCBpZiBhZnRlciByZXRhcmdldGluZywgcmVsYXRlZFRhcmdldCBhbmQgdGFyZ2V0IHBvaW50IHRvIHRoZSBzYW1lIG5vZGVcbiAgICBpZiAoZS5jb21wb3NlZCB8fCBlLmNvbXBvc2VkUGF0aCgpLmluZGV4T2YodGFyZ2V0KSA+IC0xKSB7XG4gICAgICBpZiAoaGFzUmV0YXJnZXRlZChlKSAmJiBlLnRhcmdldCA9PT0gZS5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgIGlmIChlLmV2ZW50UGhhc2UgPT09IEV2ZW50LkJVQkJMSU5HX1BIQVNFKSB7XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBwcmV2ZW50IG5vbi1idWJibGluZyBldmVudHMgZnJvbSB0cmlnZ2VyaW5nIGJ1YmJsaW5nIGhhbmRsZXJzIG9uIHNoYWRvd3Jvb3QsIGJ1dCBvbmx5IGlmIG5vdCBpbiBjYXB0dXJlIHBoYXNlXG4gICAgICBpZiAoZS5ldmVudFBoYXNlICE9PSBFdmVudC5DQVBUVVJJTkdfUEhBU0UgJiYgIWUuYnViYmxlcyAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0ICYmICEodGFyZ2V0IGluc3RhbmNlb2YgV2luZG93KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gaGFuZGxlclR5cGUgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBmbk9yT2JqLmNhbGwodGFyZ2V0LCBlKSA6XG4gICAgICAgIChmbk9yT2JqLmhhbmRsZUV2ZW50ICYmIGZuT3JPYmouaGFuZGxlRXZlbnQoZSkpO1xuICAgICAgaWYgKHRhcmdldCAhPT0gdGhpcykge1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBcImNvcnJlY3RcIiBgY3VycmVudFRhcmdldGBcbiAgICAgICAgaWYgKGxhc3RDdXJyZW50VGFyZ2V0RGVzYykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY3VycmVudFRhcmdldCcsIGxhc3RDdXJyZW50VGFyZ2V0RGVzYyk7XG4gICAgICAgICAgbGFzdEN1cnJlbnRUYXJnZXREZXNjID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZVsnY3VycmVudFRhcmdldCddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfTtcblxuICAvLyBTdG9yZSB0aGUgd3JhcHBlciBpbmZvcm1hdGlvbi5cbiAgZm5Pck9ialtldmVudFdyYXBwZXJzTmFtZV0ucHVzaCh7XG4gICAgLy8gbm90ZTogdXNlIHRhcmdldCBoZXJlIHdoaWNoIGlzIGVpdGhlciBhIHNoYWRvd1Jvb3RcbiAgICAvLyAod2hlbiB0aGUgaG9zdCBlbGVtZW50IGlzIHByb3h5J2luZyB0aGUgZXZlbnQpIG9yIHRoaXMgZWxlbWVudFxuICAgIG5vZGU6IHRhcmdldCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgb25jZTogb25jZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlLFxuICAgIHdyYXBwZXJGbjogd3JhcHBlckZuXG4gIH0pO1xuXG4gIGlmIChub25CdWJibGluZ0V2ZW50c1RvUmV0YXJnZXRbdHlwZV0pIHtcbiAgICB0aGlzLl9faGFuZGxlcnMgPSB0aGlzLl9faGFuZGxlcnMgfHwge307XG4gICAgdGhpcy5fX2hhbmRsZXJzW3R5cGVdID0gdGhpcy5fX2hhbmRsZXJzW3R5cGVdIHx8XG4gICAgICB7J2NhcHR1cmUnOiBbXSwgJ2J1YmJsZSc6IFtdfTtcbiAgICB0aGlzLl9faGFuZGxlcnNbdHlwZV1bY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnXS5wdXNoKHdyYXBwZXJGbik7XG4gIH0gZWxzZSB7XG4gICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2FkZEV2ZW50TGlzdGVuZXInXSh0eXBlLCB3cmFwcGVyRm4sIG5hdGl2ZUV2ZW50T3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuT3JPYmosIG9wdGlvbnNPckNhcHR1cmUpIHtcbiAgaWYgKCFmbk9yT2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtjYXB0dXJlLCBvbmNlLCBwYXNzaXZlLCBzaGFkeVRhcmdldCwgbmF0aXZlRXZlbnRPcHRpb25zfSA9XG4gICAgcGFyc2VFdmVudE9wdGlvbnMob3B0aW9uc09yQ2FwdHVyZSk7XG4gIGlmICh1bnBhdGNoZWRFdmVudHNbdHlwZV0pIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUV2ZW50TGlzdGVuZXInXSh0eXBlLCBmbk9yT2JqLCBuYXRpdmVFdmVudE9wdGlvbnMpO1xuICB9XG4gIGxldCB0YXJnZXQgPSBzaGFkeVRhcmdldCB8fCB0aGlzO1xuICAvLyBTZWFyY2ggdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gIGxldCB3cmFwcGVyRm4gPSB1bmRlZmluZWQ7XG4gIGxldCB3cmFwcGVycyA9IGdldEV2ZW50V3JhcHBlcnMoZm5Pck9iaik7XG4gIGlmICh3cmFwcGVycykge1xuICAgIGxldCBpZHggPSBmaW5kTGlzdGVuZXIod3JhcHBlcnMsIHRhcmdldCwgdHlwZSwgY2FwdHVyZSwgb25jZSwgcGFzc2l2ZSk7XG4gICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICB3cmFwcGVyRm4gPSB3cmFwcGVycy5zcGxpY2UoaWR4LCAxKVswXS53cmFwcGVyRm47XG4gICAgICAvLyBDbGVhbnVwLlxuICAgICAgaWYgKCF3cmFwcGVycy5sZW5ndGgpIHtcbiAgICAgICAgZm5Pck9ialtldmVudFdyYXBwZXJzTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVFdmVudExpc3RlbmVyJ10odHlwZSwgd3JhcHBlckZuIHx8IGZuT3JPYmosXG4gICAgbmF0aXZlRXZlbnRPcHRpb25zKTtcbiAgaWYgKHdyYXBwZXJGbiAmJiBub25CdWJibGluZ0V2ZW50c1RvUmV0YXJnZXRbdHlwZV0gJiZcbiAgICAgIHRoaXMuX19oYW5kbGVycyAmJiB0aGlzLl9faGFuZGxlcnNbdHlwZV0pIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLl9faGFuZGxlcnNbdHlwZV1bY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnXTtcbiAgICBjb25zdCBpZHggPSBhcnIuaW5kZXhPZih3cmFwcGVyRm4pO1xuICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgYXJyLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUZvY3VzRXZlbnRPdmVycmlkZXMoKSB7XG4gIGZvciAobGV0IGV2IGluIG5vbkJ1YmJsaW5nRXZlbnRzVG9SZXRhcmdldCkge1xuICAgIHdpbmRvd1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2FkZEV2ZW50TGlzdGVuZXInXShldiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFlWydfX3RhcmdldCddKSB7XG4gICAgICAgIHBhdGNoRXZlbnQoZSk7XG4gICAgICAgIHJldGFyZ2V0Tm9uQnViYmxpbmdFdmVudChlKTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgfVxufVxuXG5jb25zdCBFdmVudFBhdGNoZXNEZXNjcmlwdG9ycyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoRXZlbnRQYXRjaGVzKTtcblxuY29uc3QgU0hBRFlfUFJPVE8gPSAnX19zaGFkeV9wYXRjaGVkUHJvdG8nO1xuY29uc3QgU0hBRFlfU09VUkNFX1BST1RPID0gJ19fc2hhZHlfc291cmNlUHJvdG8nO1xuXG5mdW5jdGlvbiBwYXRjaEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50WydfX3RhcmdldCddID0gZXZlbnQudGFyZ2V0O1xuICBldmVudC5fX3JlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAvLyBhdHRlbXB0IHRvIHBhdGNoIHByb3RvdHlwZSAodmlhIGNhY2hlKVxuICBpZiAodXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCk7XG4gICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkocHJvdG8sIFNIQURZX1BST1RPKSkge1xuICAgICAgY29uc3QgcGF0Y2hlZFByb3RvID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICBwYXRjaGVkUHJvdG9bU0hBRFlfU09VUkNFX1BST1RPXSA9IHByb3RvO1xuICAgICAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKHBhdGNoZWRQcm90bywgRXZlbnRQYXRjaGVzRGVzY3JpcHRvcnMpO1xuICAgICAgcHJvdG9bU0hBRFlfUFJPVE9dID0gcGF0Y2hlZFByb3RvO1xuICAgIH1cbiAgICBldmVudC5fX3Byb3RvX18gPSBwcm90b1tTSEFEWV9QUk9UT107XG4gIC8vIGFuZCBmYWxsYmFjayB0byBwYXRjaGluZyBpbnN0YW5jZVxuICB9IGVsc2Uge1xuICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhldmVudCwgRXZlbnRQYXRjaGVzRGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmxldCBQYXRjaGVkRXZlbnQgPSBtaXhpbkNvbXBvc2VkRmxhZyhFdmVudCk7XG5sZXQgUGF0Y2hlZEN1c3RvbUV2ZW50ID0gbWl4aW5Db21wb3NlZEZsYWcoQ3VzdG9tRXZlbnQpO1xubGV0IFBhdGNoZWRNb3VzZUV2ZW50ID0gbWl4aW5Db21wb3NlZEZsYWcoTW91c2VFdmVudCk7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoRXZlbnRzKCkge1xuICBhY3RpdmF0ZUZvY3VzRXZlbnRPdmVycmlkZXMoKTtcbiAgd2luZG93LkV2ZW50ID0gUGF0Y2hlZEV2ZW50O1xuICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBQYXRjaGVkQ3VzdG9tRXZlbnQ7XG4gIHdpbmRvdy5Nb3VzZUV2ZW50ID0gUGF0Y2hlZE1vdXNlRXZlbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaENsaWNrKCkge1xuICAvLyBGaXggdXAgYEVsZW1lbnQucHJvdG90eXBlLmNsaWNrKClgIGlmIGBpc1RydXN0ZWRgIGlzIHN1cHBvcnRlZCwgYnV0IGBjb21wb3NlZGAgaXNuJ3RcbiAgaWYgKCFjb21wb3NlZEdldHRlciAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV2ZW50LnByb3RvdHlwZSwgJ2lzVHJ1c3RlZCcpKSB7XG4gICAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICAgIGNvbnN0IGNvbXBvc2VkQ2xpY2tGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZXYgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Rpc3BhdGNoRXZlbnQnXShldik7XG4gICAgfTtcbiAgICBpZiAoRWxlbWVudC5wcm90b3R5cGUuY2xpY2spIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLmNsaWNrID0gY29tcG9zZWRDbGlja0ZuO1xuICAgIH0gZWxzZSBpZiAoSFRNTEVsZW1lbnQucHJvdG90eXBlLmNsaWNrKSB7XG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuY2xpY2sgPSBjb21wb3NlZENsaWNrRm47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBldmVudFByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhEb2N1bWVudC5wcm90b3R5cGUpXG4gICAgLmZpbHRlcihuYW1lID0+IG5hbWUuc3Vic3RyaW5nKDAsMikgPT09ICdvbicpO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuZnVuY3Rpb24gbmV3U3BsaWNlKGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50KSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudFxuICB9O1xufVxuXG5jb25zdCBFRElUX0xFQVZFID0gMDtcbmNvbnN0IEVESVRfVVBEQVRFID0gMTtcbmNvbnN0IEVESVRfQUREID0gMjtcbmNvbnN0IEVESVRfREVMRVRFID0gMztcblxuLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbi8vIFwiZWRpdFwiIGRpc3RhbmNlLiBUaGUgb25lIGNoYW5nZSBpcyB0aGF0IFwidXBkYXRlc1wiIGFyZSB0cmVhdGVkIGFzIHR3b1xuLy8gZWRpdHMgLSBub3Qgb25lLiBXaXRoIEFycmF5IHNwbGljZXMsIGFuIHVwZGF0ZSBpcyByZWFsbHkgYSBkZWxldGVcbi8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbi8vIG1heGltdW0gYXJyYXkgaXRlbXMgaW4gdGhlIG9yaWdpbmFsIGFycmF5LiBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbi8vXG4vLyBXaXRoIDEtZWRpdCB1cGRhdGVzLCB0aGUgc2hvcnRlc3QgcGF0aCB3b3VsZCBiZSBqdXN0IHRvIHVwZGF0ZSBhbGwgc2V2ZW5cbi8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbi8vIGxlYXZlcyB0aGUgc3Vic3RyaW5nICcxMjMnIGludGFjdC5cbmZ1bmN0aW9uIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcbiAgbGV0IHJvd0NvdW50ID0gb2xkRW5kIC0gb2xkU3RhcnQgKyAxO1xuICBsZXQgY29sdW1uQ291bnQgPSBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ICsgMTtcbiAgbGV0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgLy8gXCJBZGRpdGlvblwiIHJvd3MuIEluaXRpYWxpemUgbnVsbCBjb2x1bW4uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGRpc3RhbmNlc1tpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gICAgZGlzdGFuY2VzW2ldWzBdID0gaTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgbnVsbCByb3dcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxuICAgIGRpc3RhbmNlc1swXVtqXSA9IGo7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBjb2x1bW5Db3VudDsgaisrKSB7XG4gICAgICBpZiAoZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgaiAtIDFdLCBvbGRbb2xkU3RhcnQgKyBpIC0gMV0pKVxuICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaSAtIDFdW2pdICsgMTtcbiAgICAgICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaV1baiAtIDFdICsgMTtcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gbm9ydGggPCB3ZXN0ID8gbm9ydGggOiB3ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZXM7XG59XG5cbi8vIFRoaXMgc3RhcnRzIGF0IHRoZSBmaW5hbCB3ZWlnaHQsIGFuZCB3YWxrcyBcImJhY2t3YXJkXCIgYnkgZmluZGluZ1xuLy8gdGhlIG1pbmltdW0gcHJldmlvdXMgd2VpZ2h0IHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBvcmlnaW4gb2YgdGhlIHdlaWdodFxuLy8gbWF0cml4LlxuZnVuY3Rpb24gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGRpc3RhbmNlcykge1xuICBsZXQgaSA9IGRpc3RhbmNlcy5sZW5ndGggLSAxO1xuICBsZXQgaiA9IGRpc3RhbmNlc1swXS5sZW5ndGggLSAxO1xuICBsZXQgY3VycmVudCA9IGRpc3RhbmNlc1tpXVtqXTtcbiAgbGV0IGVkaXRzID0gW107XG4gIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgIGlmIChpID09IDApIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgai0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChqID09IDApIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgaS0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBub3J0aFdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2ldW2ogLSAxXTtcblxuICAgIGxldCBtaW47XG4gICAgaWYgKHdlc3QgPCBub3J0aClcbiAgICAgIG1pbiA9IHdlc3QgPCBub3J0aFdlc3QgPyB3ZXN0IDogbm9ydGhXZXN0O1xuICAgIGVsc2VcbiAgICAgIG1pbiA9IG5vcnRoIDwgbm9ydGhXZXN0ID8gbm9ydGggOiBub3J0aFdlc3Q7XG5cbiAgICBpZiAobWluID09IG5vcnRoV2VzdCkge1xuICAgICAgaWYgKG5vcnRoV2VzdCA9PSBjdXJyZW50KSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcbiAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGotLTtcbiAgICB9IGVsc2UgaWYgKG1pbiA9PSB3ZXN0KSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGN1cnJlbnQgPSB3ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGN1cnJlbnQgPSBub3J0aDtcbiAgICB9XG4gIH1cblxuICBlZGl0cy5yZXZlcnNlKCk7XG4gIHJldHVybiBlZGl0cztcbn1cblxuLyoqXG4gKiBTcGxpY2UgUHJvamVjdGlvbiBmdW5jdGlvbnM6XG4gKlxuICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcbiAqIHdhcyB0cmFuc2Zvcm1lZCBpbnRvIGEgbmV3IGFycmF5IG9mIGl0ZW1zLiBDb25jZXB0dWFsbHkgaXQgaXMgYSBsaXN0IG9mXG4gKiB0dXBsZXMgb2ZcbiAqXG4gKiAgIDxpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudD5cbiAqXG4gKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcbiAqIHRoZSB8aW5kZXh8LCB8cmVtb3ZlZHwgc2VxdWVuY2Ugb2YgaXRlbXMgd2VyZSByZW1vdmVkLCBhbmQgY291bnRpbmcgZm9yd2FyZFxuICogZnJvbSB8aW5kZXh8LCB8YWRkZWRDb3VudHwgaXRlbXMgd2VyZSBhZGRlZC5cbiAqL1xuXG4vKipcbiAqIExhY2tpbmcgaW5kaXZpZHVhbCBzcGxpY2UgbXV0YXRpb24gaW5mb3JtYXRpb24sIHRoZSBtaW5pbWFsIHNldCBvZlxuICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuICogY2hvb3NlIHRoZSBzaG9ydGVzdCBwYXRoIHRocm91Z2ggaXQuXG4gKlxuICogQ29tcGxleGl0eTogTyhsICogcClcbiAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICBsZXQgcHJlZml4Q291bnQgPSAwO1xuICBsZXQgc3VmZml4Q291bnQgPSAwO1xuICBsZXQgc3BsaWNlO1xuXG4gIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG4gIGlmIChjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRTdGFydCA9PSAwKVxuICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcblxuICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICBzdWZmaXhDb3VudCA9IHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcblxuICBjdXJyZW50U3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuICBvbGRFbmQgLT0gc3VmZml4Q291bnQ7XG5cbiAgaWYgKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRFbmQgLSBvbGRTdGFydCA9PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAoY3VycmVudFN0YXJ0ID09IGN1cnJlbnRFbmQpIHtcbiAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgd2hpbGUgKG9sZFN0YXJ0IDwgb2xkRW5kKVxuICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkU3RhcnQrK10pO1xuXG4gICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gIH0gZWxzZSBpZiAob2xkU3RhcnQgPT0gb2xkRW5kKVxuICAgIHJldHVybiBbIG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KSBdO1xuXG4gIGxldCBvcHMgPSBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoXG4gICAgICBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgbGV0IHNwbGljZXMgPSBbXTtcbiAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICBsZXQgb2xkSW5kZXggPSBvbGRTdGFydDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2gob3BzW2ldKSB7XG4gICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgIGlmIChzcGxpY2UpIHtcbiAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgICAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfQUREOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzcGxpY2UpIHtcbiAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgfVxuICByZXR1cm4gc3BsaWNlcztcbn1cblxuZnVuY3Rpb24gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspXG4gICAgaWYgKCFlcXVhbHMoY3VycmVudFtpXSwgb2xkW2ldKSlcbiAgICAgIHJldHVybiBpO1xuICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgbGV0IGluZGV4MSA9IGN1cnJlbnQubGVuZ3RoO1xuICBsZXQgaW5kZXgyID0gb2xkLmxlbmd0aDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgd2hpbGUgKGNvdW50IDwgc2VhcmNoTGVuZ3RoICYmIGVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpXG4gICAgY291bnQrKztcblxuICByZXR1cm4gY291bnQ7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpIHtcbiAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gcHJldmlvdXNWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpIHtcbiAgcmV0dXJuIGNhbGNTcGxpY2VzKGN1cnJlbnQsIDAsIGN1cnJlbnQubGVuZ3RoLCBwcmV2aW91cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubGVuZ3RoKTtcbn1cblxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge3NoYWR5RGF0YUZvck5vZGUsIGVuc3VyZVNoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4vc2hhZHktZGF0YS5qcyc7XG5pbXBvcnQge3BhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycywgcGF0Y2hPdXRzaWRlRWxlbWVudEFjY2Vzc29yc30gZnJvbSAnLi9wYXRjaC1pbnN0YW5jZXMuanMnO1xuXG5mdW5jdGlvbiBsaW5rTm9kZShub2RlLCBjb250YWluZXIsIGNvbnRhaW5lckRhdGEsIHJlZl9ub2RlKSB7XG4gIHBhdGNoT3V0c2lkZUVsZW1lbnRBY2Nlc3NvcnMobm9kZSk7XG4gIHJlZl9ub2RlID0gcmVmX25vZGUgfHwgbnVsbDtcbiAgY29uc3Qgbm9kZURhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICBjb25zdCByZWZfbm9kZURhdGEgPSByZWZfbm9kZSA/IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUocmVmX25vZGUpIDogbnVsbDtcbiAgLy8gdXBkYXRlIHJlZl9ub2RlLnByZXZpb3VzU2libGluZyA8LT4gbm9kZVxuICBub2RlRGF0YS5wcmV2aW91c1NpYmxpbmcgPSByZWZfbm9kZSA/IHJlZl9ub2RlRGF0YS5wcmV2aW91c1NpYmxpbmcgOlxuICAgIGNvbnRhaW5lclt1dGlscy5TSEFEWV9QUkVGSVggKyAnbGFzdENoaWxkJ107XG4gIGxldCBwc2QgPSBzaGFkeURhdGFGb3JOb2RlKG5vZGVEYXRhLnByZXZpb3VzU2libGluZyk7XG4gIGlmIChwc2QpIHtcbiAgICBwc2QubmV4dFNpYmxpbmcgPSBub2RlO1xuICB9XG4gIC8vIHVwZGF0ZSBub2RlIDwtPiByZWZfbm9kZVxuICBsZXQgbnNkID0gc2hhZHlEYXRhRm9yTm9kZShub2RlRGF0YS5uZXh0U2libGluZyA9IHJlZl9ub2RlKTtcbiAgaWYgKG5zZCkge1xuICAgIG5zZC5wcmV2aW91c1NpYmxpbmcgPSBub2RlO1xuICB9XG4gIC8vIHVwZGF0ZSBub2RlIDwtPiBjb250YWluZXJcbiAgbm9kZURhdGEucGFyZW50Tm9kZSA9IGNvbnRhaW5lcjtcbiAgaWYgKHJlZl9ub2RlKSB7XG4gICAgaWYgKHJlZl9ub2RlID09PSBjb250YWluZXJEYXRhLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnRhaW5lckRhdGEuZmlyc3RDaGlsZCA9IG5vZGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lckRhdGEubGFzdENoaWxkID0gbm9kZTtcbiAgICBpZiAoIWNvbnRhaW5lckRhdGEuZmlyc3RDaGlsZCkge1xuICAgICAgY29udGFpbmVyRGF0YS5maXJzdENoaWxkID0gbm9kZTtcbiAgICB9XG4gIH1cbiAgLy8gcmVtb3ZlIGNhY2hpbmcgb2YgY2hpbGROb2Rlc1xuICBjb250YWluZXJEYXRhLmNoaWxkTm9kZXMgPSBudWxsO1xufVxuXG5leHBvcnQgY29uc3QgcmVjb3JkSW5zZXJ0QmVmb3JlID0gKG5vZGUsIGNvbnRhaW5lciwgcmVmX25vZGUpID0+IHtcbiAgcGF0Y2hJbnNpZGVFbGVtZW50QWNjZXNzb3JzKGNvbnRhaW5lcik7XG4gIGNvbnN0IGNvbnRhaW5lckRhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKGNvbnRhaW5lcik7XG4gIGlmIChjb250YWluZXJEYXRhLmZpcnN0Q2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnRhaW5lckRhdGEuY2hpbGROb2RlcyA9IG51bGw7XG4gIH1cbiAgLy8gaGFuZGxlIGRvY3VtZW50IGZyYWdtZW50c1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgLy8gTm90ZSwgZG9jdW1lbnRGcmFnbWVudHMgc2hvdWxkIG5vdCBoYXZlIGxvZ2ljYWwgRE9NIHNvIHRoZXJlJ3NcbiAgICAvLyBubyBuZWVkIHVwZGF0ZSB0aGF0LiBJdCBpcyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaGFkb3dSb290LCBidXQgd2UncmVcbiAgICAvLyBjaG9vc2luZyBub3QgdG8gc3VwcG9ydCB0aGF0LlxuICAgIGNvbnN0IGZpcnN0ID0gbm9kZVt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTtcbiAgICBmb3IgKGxldCBuID0gZmlyc3Q7IG47IChuID0gblt1dGlscy5OQVRJVkVfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pKSB7XG4gICAgICBsaW5rTm9kZShuLCBjb250YWluZXIsIGNvbnRhaW5lckRhdGEsIHJlZl9ub2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlua05vZGUobm9kZSwgY29udGFpbmVyLCBjb250YWluZXJEYXRhLCByZWZfbm9kZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlY29yZFJlbW92ZUNoaWxkID0gKG5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICBjb25zdCBub2RlRGF0YSA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIGNvbnN0IGNvbnRhaW5lckRhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKGNvbnRhaW5lcik7XG4gIGlmIChub2RlID09PSBjb250YWluZXJEYXRhLmZpcnN0Q2hpbGQpIHtcbiAgICBjb250YWluZXJEYXRhLmZpcnN0Q2hpbGQgPSBub2RlRGF0YS5uZXh0U2libGluZztcbiAgfVxuICBpZiAobm9kZSA9PT0gY29udGFpbmVyRGF0YS5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXJEYXRhLmxhc3RDaGlsZCA9IG5vZGVEYXRhLnByZXZpb3VzU2libGluZztcbiAgfVxuICBsZXQgcCA9IG5vZGVEYXRhLnByZXZpb3VzU2libGluZztcbiAgbGV0IG4gPSBub2RlRGF0YS5uZXh0U2libGluZztcbiAgaWYgKHApIHtcbiAgICBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHApLm5leHRTaWJsaW5nID0gbjtcbiAgfVxuICBpZiAobikge1xuICAgIGVuc3VyZVNoYWR5RGF0YUZvck5vZGUobikucHJldmlvdXNTaWJsaW5nID0gcDtcbiAgfVxuICAvLyBXaGVuIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCwgbG9naWNhbCBkYXRhIGlzIG5vIGxvbmdlciB0cmFja2VkLlxuICAvLyBFeHBsaWNpdGx5IHNldCBgdW5kZWZpbmVkYCBoZXJlIHRvIGluZGljYXRlIHRoaXMuIFRoaXMgaXMgZGlzZ2luZ3Vpc2hlZFxuICAvLyBmcm9tIGBudWxsYCB3aGljaCBpcyBzZXQgaWYgaW5mbyBpcyBudWxsLlxuICBub2RlRGF0YS5wYXJlbnROb2RlID0gbm9kZURhdGEucHJldmlvdXNTaWJsaW5nID1cbiAgbm9kZURhdGEubmV4dFNpYmxpbmcgPSB1bmRlZmluZWQ7XG4gIGlmIChjb250YWluZXJEYXRhLmNoaWxkTm9kZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHJlbW92ZSBjYWNoaW5nIG9mIGNoaWxkTm9kZXNcbiAgICBjb250YWluZXJEYXRhLmNoaWxkTm9kZXMgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtICB7IU5vZGV8RG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHBhcmFtICB7IU5vZGV8RG9jdW1lbnRGcmFnbWVudD19IGFkb3B0ZWRQYXJlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHJlY29yZENoaWxkTm9kZXMgPSAobm9kZSwgYWRvcHRlZFBhcmVudCkgPT4ge1xuICBjb25zdCBub2RlRGF0YSA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIGlmICghYWRvcHRlZFBhcmVudCAmJiBub2RlRGF0YS5maXJzdENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gcmVtb3ZlIGNhY2hpbmcgb2YgY2hpbGROb2Rlc1xuICBub2RlRGF0YS5jaGlsZE5vZGVzID0gbnVsbDtcbiAgY29uc3QgZmlyc3QgPSBub2RlRGF0YS5maXJzdENoaWxkID0gbm9kZVt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTtcbiAgbm9kZURhdGEubGFzdENoaWxkID0gbm9kZVt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2xhc3RDaGlsZCddO1xuICBwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMobm9kZSk7XG4gIGZvciAobGV0IG4gPSBmaXJzdCwgcHJldmlvdXM7IG47IChuID0gblt1dGlscy5OQVRJVkVfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pKSB7XG4gICAgY29uc3Qgc2QgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG4pO1xuICAgIHNkLnBhcmVudE5vZGUgPSBhZG9wdGVkUGFyZW50IHx8IG5vZGU7XG4gICAgc2QubmV4dFNpYmxpbmcgPSBuW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXTtcbiAgICBzZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91cyB8fCBudWxsO1xuICAgIHByZXZpb3VzID0gbjtcbiAgICBwYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzKG4pO1xuICB9XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcblxubGV0IHNjb3BpbmdTaGltID0gbnVsbDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjb3BpbmdTaGltKCkge1xuICBpZiAoIXNjb3BpbmdTaGltKSB7XG4gICAgc2NvcGluZ1NoaW0gPSB3aW5kb3dbJ1NoYWR5Q1NTJ10gJiYgd2luZG93WydTaGFkeUNTUyddWydTY29waW5nU2hpbSddO1xuICB9XG4gIHJldHVybiBzY29waW5nU2hpbSB8fCBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjb3BlQ2xhc3NBdHRyaWJ1dGUobm9kZSwgYXR0ciwgdmFsdWUpIHtcbiAgY29uc3Qgc2NvcGluZ1NoaW0gPSBnZXRTY29waW5nU2hpbSgpO1xuICBpZiAoc2NvcGluZ1NoaW0gJiYgYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgIHNjb3BpbmdTaGltWydzZXRFbGVtZW50Q2xhc3MnXShub2RlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTY29wZU5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNoYWR5U2NvcGluZyhub2RlLCBuZXdTY29wZU5hbWUpIHtcbiAgY29uc3Qgc2NvcGluZ1NoaW0gPSBnZXRTY29waW5nU2hpbSgpO1xuICBpZiAoIXNjb3BpbmdTaGltKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjb3BpbmdTaGltWydzY29wZU5vZGUnXShub2RlLCBuZXdTY29wZU5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50U2NvcGVOYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTaGFkeVNjb3Bpbmcobm9kZSwgY3VycmVudFNjb3BlTmFtZSkge1xuICBjb25zdCBzY29waW5nU2hpbSA9IGdldFNjb3BpbmdTaGltKCk7XG4gIGlmICghc2NvcGluZ1NoaW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2NvcGluZ1NoaW1bJ3Vuc2NvcGVOb2RlJ10obm9kZSwgY3VycmVudFNjb3BlTmFtZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1Njb3BlTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IG9sZFNjb3BlTmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVNoYWR5U2NvcGluZyhub2RlLCBuZXdTY29wZU5hbWUsIG9sZFNjb3BlTmFtZSkge1xuICBjb25zdCBzY29waW5nU2hpbSA9IGdldFNjb3BpbmdTaGltKCk7XG4gIGlmICghc2NvcGluZ1NoaW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9sZFNjb3BlTmFtZSkge1xuICAgIHJlbW92ZVNoYWR5U2NvcGluZyhub2RlLCBvbGRTY29wZU5hbWUpO1xuICB9XG4gIGFkZFNoYWR5U2NvcGluZyhub2RlLCBuZXdTY29wZU5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTY29wZU5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50U2NvcGVJc0NvcnJlY3Qobm9kZSwgbmV3U2NvcGVOYW1lKSB7XG4gIGNvbnN0IHNjb3BpbmdTaGltID0gZ2V0U2NvcGluZ1NoaW0oKTtcbiAgaWYgKCFzY29waW5nU2hpbSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAvLyBOT1RFOiBhcyBhbiBvcHRpbWl6YXRpb24sIG9ubHkgY2hlY2sgdGhhdCBhbGwgdGhlIHRvcC1sZXZlbCBjaGlsZHJlblxuICAgIC8vIGhhdmUgdGhlIGNvcnJlY3Qgc2NvcGUuXG4gICAgbGV0IGNvcnJlY3RTY29wZSA9IHRydWU7XG4gICAgZm9yIChsZXQgbj1ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgICBjb3JyZWN0U2NvcGUgPSBjb3JyZWN0U2NvcGUgJiZcbiAgICAgICAgY3VycmVudFNjb3BlSXNDb3JyZWN0KG4sIG5ld1Njb3BlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBjb3JyZWN0U2NvcGU7XG4gIH1cbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY3VycmVudFNjb3BlID0gc2NvcGluZ1NoaW1bJ2N1cnJlbnRTY29wZUZvck5vZGUnXShub2RlKTtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZSA9PT0gbmV3U2NvcGVOYW1lO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRTY29wZUZvck5vZGUobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3Qgc2NvcGluZ1NoaW0gPSBnZXRTY29waW5nU2hpbSgpO1xuICBpZiAoIXNjb3BpbmdTaGltKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBzY29waW5nU2hpbVsnY3VycmVudFNjb3BlRm9yTm9kZSddKG5vZGUpO1xufVxuXG4vKipcbiAqIFdhbGsgb3ZlciBhIG5vZGUncyB0cmVlIGFuZCBhcHBseSB2aXNpdG9yRm4gdG8gZWFjaCBlbGVtZW50IG5vZGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oIU5vZGUpOnZvaWR9IHZpc2l0b3JGblxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJlZVZpc2l0b3Iobm9kZSwgdmlzaXRvckZuKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSBpZiBgbm9kZWAgaXMgYSBEb2N1bWVudCBGcmFnbWVudFxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2aXNpdG9yRm4obm9kZSk7XG4gIH1cbiAgZm9yIChsZXQgbiA9IG5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgKG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSkge1xuICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdHJlZVZpc2l0b3IobiwgdmlzaXRvckZuKTtcbiAgICB9XG4gIH1cbn0iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQge2dldFNjb3BpbmdTaGltLCByZW1vdmVTaGFkeVNjb3BpbmcsIHJlcGxhY2VTaGFkeVNjb3BpbmcsXG4gIHRyZWVWaXNpdG9yLCBjdXJyZW50U2NvcGVGb3JOb2RlLCBjdXJyZW50U2NvcGVJc0NvcnJlY3QgfSBmcm9tICcuLi9zdHlsZS1zY29waW5nLmpzJztcbmltcG9ydCB7c2hhZHlEYXRhRm9yTm9kZSwgZW5zdXJlU2hhZHlEYXRhRm9yTm9kZX0gZnJvbSAnLi4vc2hhZHktZGF0YS5qcyc7XG5pbXBvcnQge3JlY29yZEluc2VydEJlZm9yZSwgcmVjb3JkUmVtb3ZlQ2hpbGR9IGZyb20gJy4uL2xpbmstbm9kZXMuanMnO1xuaW1wb3J0IHtvd25lclNoYWR5Um9vdEZvck5vZGV9IGZyb20gJy4uL2F0dGFjaC1zaGFkb3cuanMnO1xuXG5jb25zdCBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbmNvbnN0IHByZWZlclBlcmZvcm1hbmNlID0gdXRpbHMuc2V0dGluZ3MucHJlZmVyUGVyZm9ybWFuY2U7XG5cbmNvbnN0IG5hdGl2ZUlzQ29ubmVjdGVkQWNjZXNzb3JzID1cbi8qKiBAdHlwZSB7T2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyhcbiAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgJ2lzQ29ubmVjdGVkJylcbik7XG5cbmNvbnN0IG5hdGl2ZUlzQ29ubmVjdGVkID0gbmF0aXZlSXNDb25uZWN0ZWRBY2Nlc3NvcnMgJiYgbmF0aXZlSXNDb25uZWN0ZWRBY2Nlc3NvcnMuZ2V0O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgbGV0IGZpcnN0Q2hpbGQ7XG4gIHdoaWxlICgoZmlyc3RDaGlsZCA9IG5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXSkpIHtcbiAgICBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKGZpcnN0Q2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU93bmVyU2hhZHlSb290KG5vZGUpIHtcbiAgLy8gb3B0aW1pemF0aW9uOiBvbmx5IHJlc2V0IHRoZSB0cmVlIGlmIG5vZGUgaXMgYWN0dWFsbHkgaW4gYSByb290XG4gIGlmIChoYXNDYWNoZWRPd25lclJvb3Qobm9kZSkpIHtcbiAgICBmb3IgKGxldCBuPW5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgIHJlbW92ZU93bmVyU2hhZHlSb290KG4pO1xuICAgIH1cbiAgfVxuICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIGlmIChub2RlRGF0YSkge1xuICAgIG5vZGVEYXRhLm93bmVyU2hhZHlSb290ID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NhY2hlZE93bmVyUm9vdChub2RlKSB7XG4gIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgcmV0dXJuIEJvb2xlYW4obm9kZURhdGEgJiYgbm9kZURhdGEub3duZXJTaGFkeVJvb3QgIT09IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IGZsYXR0ZW5lZCBub2RlIHRoYXQgaXMgY29tcG9zZWQgaW4gdGhlIG5vZGUncyBwYXJlbnQuXG4gKiBJZiB0aGUgZ2l2ZW4gbm9kZSBpcyBhIHNsb3QsIHRoZW4gdGhlIGZpcnN0IGZsYXR0ZW5lZCBub2RlIGlzIHJldHVybmVkXG4gKiBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBhZHZhbmNlIHRvIHRoZSBub2RlJ3MgbmV4dFNpYmxpbmcuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgd2l0aGluIHdoaWNoIHRvIGZpbmQgZmlyc3QgY29tcG9zZWQgbm9kZVxuICogQHJldHVybnMge05vZGV9IGZpcnN0IGNvbXBvc2VkIG5vZGVcbiAqL1xuZnVuY3Rpb24gZmlyc3RDb21wb3NlZE5vZGUobm9kZSkge1xuICBsZXQgY29tcG9zZWQgPSBub2RlO1xuICBpZiAobm9kZSAmJiBub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IG5vZGVEYXRhICYmIG5vZGVEYXRhLmZsYXR0ZW5lZE5vZGVzO1xuICAgIGNvbXBvc2VkID0gZmxhdHRlbmVkICYmIGZsYXR0ZW5lZC5sZW5ndGggPyBmbGF0dGVuZWRbMF0gOlxuICAgICAgZmlyc3RDb21wb3NlZE5vZGUobm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2VkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlPX0gYWRkZWROb2RlXG4gKiBAcGFyYW0ge05vZGU9fSByZW1vdmVkTm9kZVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZU9ic2VydmVyKG5vZGUsIGFkZGVkTm9kZSwgcmVtb3ZlZE5vZGUpIHtcbiAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICBjb25zdCBvYnNlcnZlciA9IG5vZGVEYXRhICYmIG5vZGVEYXRhLm9ic2VydmVyO1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBpZiAoYWRkZWROb2RlKSB7XG4gICAgICBvYnNlcnZlci5hZGRlZE5vZGVzLnB1c2goYWRkZWROb2RlKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWROb2RlKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVkTm9kZXMucHVzaChyZW1vdmVkTm9kZSk7XG4gICAgfVxuICAgIG9ic2VydmVyLnNjaGVkdWxlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE5vZGVQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgcGFyZW50Tm9kZSgpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgY29uc3QgbCA9IG5vZGVEYXRhICYmIG5vZGVEYXRhLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIGwgIT09IHVuZGVmaW5lZCA/IGwgOiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGNvbnN0IGwgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5maXJzdENoaWxkO1xuICAgIHJldHVybiBsICE9PSB1bmRlZmluZWQgPyBsIDogdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBsYXN0Q2hpbGQoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGNvbnN0IGwgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGwgIT09IHVuZGVmaW5lZCA/IGwgOiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnbGFzdENoaWxkJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGNvbnN0IGwgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5uZXh0U2libGluZztcbiAgICByZXR1cm4gbCAhPT0gdW5kZWZpbmVkID8gbCA6IHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICduZXh0U2libGluZyddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHByZXZpb3VzU2libGluZygpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgY29uc3QgbCA9IG5vZGVEYXRhICYmIG5vZGVEYXRhLnByZXZpb3VzU2libGluZztcbiAgICByZXR1cm4gbCAhPT0gdW5kZWZpbmVkID8gbCA6IHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdwcmV2aW91c1NpYmxpbmcnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBjaGlsZE5vZGVzKCkge1xuICAgIGxldCBjaGlsZE5vZGVzO1xuICAgIGlmICh1dGlscy5pc1RyYWNraW5nTG9naWNhbENoaWxkTm9kZXModGhpcykpIHtcbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICAgIGlmICghbm9kZURhdGEuY2hpbGROb2Rlcykge1xuICAgICAgICBub2RlRGF0YS5jaGlsZE5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IG49dGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuPW5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgICAgICBub2RlRGF0YS5jaGlsZE5vZGVzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkTm9kZXMgPSBub2RlRGF0YS5jaGlsZE5vZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZE5vZGVzID0gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2NoaWxkTm9kZXMnXTtcbiAgICB9XG4gICAgY2hpbGROb2Rlcy5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiBjaGlsZE5vZGVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkTm9kZXM7XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgcGFyZW50RWxlbWVudCgpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgbGV0IGwgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5wYXJlbnROb2RlO1xuICAgIGlmIChsICYmIGwubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICBsID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGwgIT09IHVuZGVmaW5lZCA/IGwgOiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50RWxlbWVudCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgIGlmIChuYXRpdmVJc0Nvbm5lY3RlZCAmJiBuYXRpdmVJc0Nvbm5lY3RlZC5jYWxsKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9kZVR5cGUgPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEZhc3QgcGF0aCBmb3IgZGlzdHJpYnV0ZWQgbm9kZXMuXG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICBpZiAodXRpbHMuaGFzRG9jdW1lbnRDb250YWlucykge1xuICAgICAgaWYgKG93bmVyRG9jdW1lbnRbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdjb250YWlucyddKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgIG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3V0aWxzLk5BVElWRV9QUkVGSVggKyAnY29udGFpbnMnXSh0aGlzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFNsb3cgcGF0aCBmb3Igbm9uLWRpc3RyaWJ1dGVkIG5vZGVzLlxuICAgIGxldCBub2RlID0gdGhpcztcbiAgICB3aGlsZSAobm9kZSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgIG5vZGUgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ10gfHwgKHV0aWxzLmlzU2hhZHlSb290KG5vZGUpID8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyhub2RlKS5ob3N0IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuICEhKG5vZGUgJiYgbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50KTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICBpZiAodXRpbHMuaXNUcmFja2luZ0xvZ2ljYWxDaGlsZE5vZGVzKHRoaXMpKSB7XG4gICAgICBsZXQgdGMgPSBbXTtcbiAgICAgIGZvciAobGV0IG49dGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgICAgICBpZiAobi5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICB0Yy5wdXNoKG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ3RleHRDb250ZW50J10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGMuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAndGV4dENvbnRlbnQnXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldCB0ZXh0Q29udGVudCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9ICcnXG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5ub2RlVHlwZSkge1xuICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICBpZiAoIXV0aWxzLmlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2Rlcyh0aGlzKSAmJiB1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycykge1xuICAgICAgICAgIC8vIG1heSBiZSByZW1vdmluZyBhIG5lc3RlZCBzbG90IGJ1dCBmYXN0IHBhdGggaWYgd2Uga25vdyB3ZSBhcmUgbm90LlxuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107XG4gICAgICAgICAgaWYgKGZpcnN0Q2hpbGQgIT0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnbGFzdENoaWxkJ10gfHxcbiAgICAgICAgICAgIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgIT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICBjbGVhck5vZGUodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICd0ZXh0Q29udGVudCddID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJOb2RlKHRoaXMpO1xuICAgICAgICAgIC8vIERvY3VtZW50IGZyYWdtZW50cyBtdXN0IGhhdmUgbm8gY2hpbGROb2RlcyBpZiBzZXR0aW5nIGEgYmxhbmsgc3RyaW5nXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgfHwgdGhpcy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBOb3RlLCBiZSB3YXJ5IG9mIHBhdGNoaW5nIGBub2RlVmFsdWVgLlxuICAgICAgICB0aGlzLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0sXG5cbiAgLy8gUGF0Y2hlZCBgaW5zZXJ0QmVmb3JlYC4gTm90ZSB0aGF0IGFsbCBtdXRhdGlvbnMgdGhhdCBhZGQgbm9kZXMgYXJlIHJvdXRlZFxuICAvLyBoZXJlLiBXaGVuIGEgPHNsb3Q+IGlzIGFkZGVkIG9yIGEgbm9kZSBpcyBhZGRlZCB0byBhIGhvc3Qgd2l0aCBhIHNoYWRvd1Jvb3RcbiAgLy8gd2l0aCBhIHNsb3QsIGEgc3RhbmRhcmQgZG9tIGBpbnNlcnRgIGNhbGwgaXMgYWJvcnRlZCBhbmQgYF9hc3luY1JlbmRlcmBcbiAgLy8gaXMgY2FsbGVkIG9uIHRoZSByZWxldmFudCBzaGFkb3dSb290LiBJbiBhbGwgb3RoZXIgY2FzZXMsIGEgc3RhbmRhcmQgZG9tXG4gIC8vIGBpbnNlcnRgIGNhbiBiZSBtYWRlLCBidXQgdGhlIGxvY2F0aW9uIGFuZCByZWZfbm9kZSBtYXkgbmVlZCB0byBiZSBjaGFuZ2VkLlxuICAvKipcbiAgICogQHRoaXMge05vZGV9XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge05vZGU9fSByZWZfbm9kZVxuICAgKi9cbiAgaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZl9ub2RlKSB7XG4gICAgLy8gb3B0aW1pemF0aW9uOiBhc3N1bWUgbmF0aXZlIGluc2VydEJlZm9yZSBpcyBvayBpZiB0aGUgbm9kZXMgYXJlIG5vdCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgaWYgKHRoaXMub3duZXJEb2N1bWVudCAhPT0gZG9jICYmIG5vZGUub3duZXJEb2N1bWVudCAhPT0gZG9jKSB7XG4gICAgICB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10obm9kZSwgcmVmX25vZGUpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSB0aGlzKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZENoaWxkJyBvbiAnTm9kZSc6IFRoZSBuZXcgY2hpbGQgZWxlbWVudCBjb250YWlucyB0aGUgcGFyZW50LmApO1xuICAgIH1cbiAgICBpZiAocmVmX25vZGUpIHtcbiAgICAgIGNvbnN0IHJlZkRhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHJlZl9ub2RlKTtcbiAgICAgIGNvbnN0IHAgPSByZWZEYXRhICYmIHJlZkRhdGEucGFyZW50Tm9kZTtcbiAgICAgIGlmICgocCAhPT0gdW5kZWZpbmVkICYmIHAgIT09IHRoaXMpIHx8XG4gICAgICAgIChwID09PSB1bmRlZmluZWQgJiYgcmVmX25vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdwYXJlbnROb2RlJ10gIT09IHRoaXMpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSAnaW5zZXJ0QmVmb3JlJyBvbiAnTm9kZSc6IFRoZSBub2RlIGAgK1xuICAgICAgICBgYmVmb3JlIHdoaWNoIHRoZSBuZXcgbm9kZSBpcyB0byBiZSBpbnNlcnRlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWZfbm9kZSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7IUFycmF5PCFIVE1MU2xvdEVsZW1lbnQ+fSAqL1xuICAgIGNvbnN0IHNsb3RzQWRkZWQgPSBbXTtcbiAgICBjb25zdCBvd25lclJvb3QgPSBvd25lclNoYWR5Um9vdEZvck5vZGUodGhpcyk7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgY29uc3QgbmV3U2NvcGVOYW1lID0gb3duZXJSb290ID8gb3duZXJSb290Lmhvc3QubG9jYWxOYW1lIDogY3VycmVudFNjb3BlRm9yTm9kZSh0aGlzKTtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQgb2xkU2NvcGVOYW1lO1xuICAgIC8vIHJlbW92ZSBmcm9tIGV4aXN0aW5nIGxvY2F0aW9uXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgb2xkU2NvcGVOYW1lID0gY3VycmVudFNjb3BlRm9yTm9kZShub2RlKTtcbiAgICAgIGNvbnN0IHNraXBVbnNjb3BpbmcgPVxuICAgICAgICAvLyBEb24ndCByZW1vdmUgc2NvcGluZyBpZiB3ZSdyZSBpbnNlcnRpbmcgaW50byBhbm90aGVyIHNoYWRvd1Jvb3Q7XG4gICAgICAgIC8vIHRoaXMgd291bGQgYmUgdW5uZWNlc3Nhcnkgc2luY2UgaXQgd2lsbCBiZSByZS1zY29wZWQgYmVsb3dcbiAgICAgICAgQm9vbGVhbihvd25lclJvb3QpIHx8XG4gICAgICAgIC8vIERvbid0IHJlbW92ZSBzY29waW5nIGlmIHdlJ3JlIGJlaW5nIG1vdmVkIGJldHdlZW4gbm9uLXNoYWRvd1Jvb3RcbiAgICAgICAgLy8gbG9jYXRpb25zICh0aGUgbGlrZWx5IGNhc2UgaXMgd2hlbiBtb3ZpbmcgcHJlLXNjb3BlZCBub2RlcyBpbiBhIHRlbXBsYXRlKVxuICAgICAgICAhb3duZXJTaGFkeVJvb3RGb3JOb2RlKG5vZGUpIHx8XG4gICAgICAgIC8vIFVuZGVyIHByZWZlclBlcmZvcm1hbmNlLCBkb24ndCByZW1vdmUgc2NvcGluZyB3aGVuIG1vdmluZyBiYWNrIGludG9cbiAgICAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCB0aGF0IHdhcyBwcmV2aW91c2x5IHNjb3BlZDsgdGhlIGFzc3VtcHRpb24gaXNcbiAgICAgICAgLy8gdGhhdCB0aGUgdXNlciBzaG91bGQgb25seSBtb3ZlIGNvcnJlY3RseS1zY29wZWQgRE9NIGJhY2sgaW50byBpdFxuICAgICAgICAocHJlZmVyUGVyZm9ybWFuY2UgJiYgdGhpc1snX19ub0luc2VydGlvblBvaW50J10gIT09IHVuZGVmaW5lZCk7XG4gICAgICBwYXJlbnROb2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKG5vZGUsIHNraXBVbnNjb3BpbmcpO1xuICAgIH1cbiAgICAvLyBhZGQgdG8gbmV3IHBhcmVudFxuICAgIGxldCBhbGxvd05hdGl2ZUluc2VydCA9IHRydWU7XG4gICAgY29uc3QgbmVlZHNTY29waW5nID0gKCFwcmVmZXJQZXJmb3JtYW5jZSB8fFxuICAgICAgICAvLyBVbmRlciBwcmVmZXJQZXJmb3JtYW5jZSwgb25seSByZS1zY29wZSBpZiB3ZSdyZSBub3QgY29taW5nIGZyb20gYVxuICAgICAgICAvLyBwcmUtc2NvcGVkIGRvYyBmcmFnbWVudCBvciBiYWNrIGludG8gYSBwcmUtc2NvcGVkIGRvYyBmcmFnbWVudFxuICAgICAgICAobm9kZVsnX19ub0luc2VydGlvblBvaW50J10gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgdGhpc1snX19ub0luc2VydGlvblBvaW50J10gPT09IHVuZGVmaW5lZCkpICYmXG4gICAgICAgICFjdXJyZW50U2NvcGVJc0NvcnJlY3Qobm9kZSwgbmV3U2NvcGVOYW1lKTtcbiAgICBjb25zdCBuZWVkc1Nsb3RGaW5kaW5nID0gb3duZXJSb290ICYmICFub2RlWydfX25vSW5zZXJ0aW9uUG9pbnQnXSAmJlxuICAgICAgICAoIXByZWZlclBlcmZvcm1hbmNlIHx8IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSk7XG4gICAgaWYgKG5lZWRzU2xvdEZpbmRpbmcgfHwgbmVlZHNTY29waW5nKSB7XG4gICAgICAvLyBOT1RFOiBhdm9pZCBub2RlLnJlbW92ZUNoaWxkIGFzIHRoaXMgKmNhbiogdHJpZ2dlciBhbm90aGVyIHBhdGNoZWRcbiAgICAgIC8vIG1ldGhvZCAoZS5nLiBjdXN0b20gZWxlbWVudHMpIGFuZCB3ZSB3YW50IG9ubHkgdGhlIHNoYWR5IG1ldGhvZCB0byBydW4uXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHRhYmxlIGRlc2NyaWJlcyB3aGF0IHN0eWxlIHNjb3BpbmcgYWN0aW9ucyBzaG91bGQgaGFwcGVuIGFzIGEgcmVzdWx0IG9mIHRoaXMgaW5zZXJ0aW9uLlxuICAgICAgLy8gZG9jdW1lbnQgLT4gc2hhZG93Um9vdDogcmVwbGFjZVxuICAgICAgLy8gc2hhZG93Um9vdCAtPiBzaGFkb3dSb290OiByZXBsYWNlXG4gICAgICAvLyBzaGFkb3dSb290IC0+IHNoYWRvd1Jvb3Qgb2Ygc2FtZSB0eXBlOiBkbyBub3RoaW5nXG4gICAgICAvLyBzaGFkb3dSb290IC0+IGRvY3VtZW50OiBhbGxvdyB1bnNjb3BpbmdcbiAgICAgIC8vIGRvY3VtZW50IC0+IGRvY3VtZW50OiBkbyBub3RoaW5nXG4gICAgICAvLyBUaGUgXCJzYW1lIHR5cGUgb2Ygc2hhZG93Um9vdFwiIGFuZCBcImRvY3VtZW50IHRvIGRvY3VtZW50IGNhc2VzIHJlbHkgb24gYGN1cnJlbnRTY29wZUlzQ29ycmVjdGAgcmV0dXJuaW5nIHRydWVcbiAgICAgIGlmIChuZWVkc1Njb3BpbmcpIHtcbiAgICAgICAgLy8gaW4gYSBkb2N1bWVudCBvciBkaXNjb25uZWN0ZWQgdHJlZSwgcmVwbGFjZSBzY29waW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICBvbGRTY29wZU5hbWUgPSBvbGRTY29wZU5hbWUgfHwgY3VycmVudFNjb3BlRm9yTm9kZShub2RlKTtcbiAgICAgIH1cbiAgICAgIHRyZWVWaXNpdG9yKG5vZGUsIChub2RlKSA9PiB7XG4gICAgICAgIGlmIChuZWVkc1Nsb3RGaW5kaW5nICYmIG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgICBzbG90c0FkZGVkLnB1c2goLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqLyhub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzU2NvcGluZykge1xuICAgICAgICAgIHJlcGxhY2VTaGFkeVNjb3Bpbmcobm9kZSwgbmV3U2NvcGVOYW1lLCBvbGRTY29wZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gaWYgYSBzbG90IGlzIGFkZGVkLCBtdXN0IHJlbmRlciBjb250YWluaW5nIHJvb3QuXG4gICAgaWYgKHNsb3RzQWRkZWQubGVuZ3RoKSB7XG4gICAgICBvd25lclJvb3QuX2FkZFNsb3RzKHNsb3RzQWRkZWQpO1xuICAgICAgb3duZXJSb290Ll9hc3luY1JlbmRlcigpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNUcmFja2luZ0xvZ2ljYWxDaGlsZE5vZGVzKHRoaXMpKSB7XG4gICAgICByZWNvcmRJbnNlcnRCZWZvcmUobm9kZSwgdGhpcywgcmVmX25vZGUpO1xuICAgICAgLy8gd2hlbiBpbnNlcnRpbmcgaW50byBhIGhvc3Qgd2l0aCBhIHNoYWRvd1Jvb3Qgd2l0aCBzbG90LCB1c2VcbiAgICAgIC8vIGBzaGFkb3dSb290Ll9hc3luY1JlbmRlcigpYCB2aWEgYGF0dGFjaC1zaGFkb3dgIG1vZHVsZVxuICAgICAgY29uc3QgcGFyZW50RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgICBpZiAodXRpbHMuaGFzU2hhZG93Um9vdFdpdGhTbG90KHRoaXMpKSB7XG4gICAgICAgIHBhcmVudERhdGEucm9vdC5fYXN5bmNSZW5kZXIoKTtcbiAgICAgICAgYWxsb3dOYXRpdmVJbnNlcnQgPSBmYWxzZTtcbiAgICAgIC8vIHdoZW4gaW5zZXJ0aW5nIGludG8gYSBob3N0IHdpdGggc2hhZG93Um9vdCB3aXRoIE5PIHNsb3QsIGRvIG5vdGhpbmdcbiAgICAgIC8vIGFzIHRoZSBub2RlIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gY29tcG9zZWQgZG9tZSBhbnl3aGVyZS5cbiAgICAgIH0gZWxzZSBpZiAocGFyZW50RGF0YS5yb290KSB7XG4gICAgICAgIGFsbG93TmF0aXZlSW5zZXJ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxvd05hdGl2ZUluc2VydCkge1xuICAgICAgLy8gaWYgYWRkaW5nIHRvIGEgc2hhZHlSb290LCBhZGQgdG8gaG9zdCBpbnN0ZWFkXG4gICAgICBsZXQgY29udGFpbmVyID0gdXRpbHMuaXNTaGFkeVJvb3QodGhpcykgP1xuICAgICAgICAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovKHRoaXMpLmhvc3QgOiB0aGlzO1xuICAgICAgLy8gaWYgcmVmX25vZGUsIGdldCB0aGUgcmVmX25vZGUgdGhhdCdzIGFjdHVhbGx5IGluIGNvbXBvc2VkIGRvbS5cbiAgICAgIGlmIChyZWZfbm9kZSkge1xuICAgICAgICByZWZfbm9kZSA9IGZpcnN0Q29tcG9zZWROb2RlKHJlZl9ub2RlKTtcbiAgICAgICAgY29udGFpbmVyW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10obm9kZSwgcmVmX25vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnYXBwZW5kQ2hpbGQnXShub2RlKTtcbiAgICAgIH1cbiAgICAvLyBTaW5jZSBvd25lckRvY3VtZW50IGlzIG5vdCBwYXRjaGVkLCBpdCBjYW4gYmUgaW5jb3JyZWN0IGFmdGVyIHRoaXMgY2FsbFxuICAgIC8vIGlmIHRoZSBub2RlIGlzIHBoeXNpY2FsbHkgYXBwZW5kZWQgdmlhIGRpc3RyaWJ1dGlvbi4gVGhpcyBjYW4gcmVzdWx0XG4gICAgLy8gaW4gdGhlIGN1c3RvbSBlbGVtZW50cyBwb2x5ZmlsbCBub3QgdXBncmFkaW5nIHRoZSBub2RlIGlmIGl0J3MgaW4gYW4gaW5lcnQgZG9jLlxuICAgIC8vIFdlIGNvcnJlY3QgdGhpcyBieSBjYWxsaW5nIGBhZG9wdE5vZGVgLlxuICAgIH0gZWxzZSBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSB0aGlzLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIHRoaXMub3duZXJEb2N1bWVudC5hZG9wdE5vZGUobm9kZSk7XG4gICAgfVxuICAgIHNjaGVkdWxlT2JzZXJ2ZXIodGhpcywgbm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIGFwcGVuZENoaWxkKG5vZGUpIHtcbiAgICAvLyBpZiB0aGlzIGlzIGEgc2hhZG93Um9vdCBhbmQgdGhlIHNoYWRvd1Jvb3QgaXMgcGFzc2VkIGFzIGBub2RlYFxuICAgIC8vIHRoZW4gYW4gb3B0aW1pemVkIGFwcGVuZCBoYXMgYWxyZWFkeSBiZWVuIHBlcmZvcm1lZCwgc28gZG8gbm90aGluZy5cbiAgICBpZiAoISh0aGlzID09IG5vZGUgJiYgdXRpbHMuaXNTaGFkeVJvb3Qobm9kZSkpKSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10obm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXRjaGVkIGByZW1vdmVDaGlsZGAuIE5vdGUgdGhhdCBhbGwgZG9tIFwicmVtb3ZhbHNcIiBhcmUgcm91dGVkIGhlcmUuXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGBub2RlYCBmcm9tIHRoZSBlbGVtZW50J3MgYGNoaWxkcmVuYC5cbiAgICogVGhpcyBtZXRob2QgYWxzbyBwZXJmb3JtcyBkb20gY29tcG9zaXRpb24uXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2tpcFVuc2NvcGluZ1xuICAgKi9cbiAgcmVtb3ZlQ2hpbGQobm9kZSwgc2tpcFVuc2NvcGluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMub3duZXJEb2N1bWVudCAhPT0gZG9jKSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ10gIT09IHRoaXMpIHtcbiAgICAgIHRocm93IEVycm9yKCdUaGUgbm9kZSB0byBiZSByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgbm9kZTogJyArXG4gICAgICAgIG5vZGUpO1xuICAgIH1cbiAgICBsZXQgcHJldmVudE5hdGl2ZVJlbW92ZTtcbiAgICBsZXQgb3duZXJSb290ID0gb3duZXJTaGFkeVJvb3RGb3JOb2RlKG5vZGUpO1xuICAgIGNvbnN0IHJlbW92aW5nSW5zZXJ0aW9uUG9pbnQgPSBvd25lclJvb3QgJiYgb3duZXJSb290Ll9yZW1vdmVDb250YWluZWRTbG90cyhub2RlKTtcbiAgICBjb25zdCBwYXJlbnREYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBpZiAodXRpbHMuaXNUcmFja2luZ0xvZ2ljYWxDaGlsZE5vZGVzKHRoaXMpKSB7XG4gICAgICByZWNvcmRSZW1vdmVDaGlsZChub2RlLCB0aGlzKTtcbiAgICAgIGlmICh1dGlscy5oYXNTaGFkb3dSb290V2l0aFNsb3QodGhpcykpIHtcbiAgICAgICAgcGFyZW50RGF0YS5yb290Ll9hc3luY1JlbmRlcigpO1xuICAgICAgICBwcmV2ZW50TmF0aXZlUmVtb3ZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5zY29wZSBhIG5vZGUgbGVhdmluZyBhIFNoYWRvd1Jvb3QgaWYgU2hhZHlDU1MgaXMgcHJlc2VudCwgYW5kIHRoaXMgbm9kZVxuICAgIC8vIGlzIG5vdCBnb2luZyB0byBiZSByZXNjb3BlZCBpbiBgaW5zZXJ0QmVmb3JlYFxuICAgIGlmIChnZXRTY29waW5nU2hpbSgpICYmICFza2lwVW5zY29waW5nICYmIG93bmVyUm9vdFxuICAgICAgJiYgbm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIGNvbnN0IG9sZFNjb3BlTmFtZSA9IGN1cnJlbnRTY29wZUZvck5vZGUobm9kZSk7XG4gICAgICB0cmVlVmlzaXRvcihub2RlLCAobm9kZSkgPT4ge1xuICAgICAgICByZW1vdmVTaGFkeVNjb3Bpbmcobm9kZSwgb2xkU2NvcGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVPd25lclNoYWR5Um9vdChub2RlKTtcbiAgICAvLyBpZiByZW1vdmluZyBzbG90LCBtdXN0IHJlbmRlciBjb250YWluaW5nIHJvb3RcbiAgICBpZiAob3duZXJSb290KSB7XG4gICAgICBsZXQgY2hhbmdlU2xvdENvbnRlbnQgPSB0aGlzICYmIHRoaXMubG9jYWxOYW1lID09PSAnc2xvdCc7XG4gICAgICBpZiAoY2hhbmdlU2xvdENvbnRlbnQpIHtcbiAgICAgICAgcHJldmVudE5hdGl2ZVJlbW92ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZpbmdJbnNlcnRpb25Qb2ludCB8fCBjaGFuZ2VTbG90Q29udGVudCkge1xuICAgICAgICBvd25lclJvb3QuX2FzeW5jUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcHJldmVudE5hdGl2ZVJlbW92ZSkge1xuICAgICAgLy8gaWYgcmVtb3ZpbmcgZnJvbSBhIHNoYWR5Um9vdCwgcmVtb3ZlIGZyb20gaG9zdCBpbnN0ZWFkXG4gICAgICBsZXQgY29udGFpbmVyID0gdXRpbHMuaXNTaGFkeVJvb3QodGhpcykgP1xuICAgICAgICAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovKHRoaXMpLmhvc3QgOlxuICAgICAgICB0aGlzO1xuICAgICAgLy8gbm90IGd1YXJhbnRlZWQgdG8gcGh5c2ljYWxseSBiZSBpbiBjb250YWluZXI7IGUuZy5cbiAgICAgIC8vICgxKSBpZiBwYXJlbnQgaGFzIGEgc2hhZHlSb290LCBlbGVtZW50IG1heSBvciBtYXkgbm90IGF0IGRpc3RyaWJ1dGVkXG4gICAgICAvLyBsb2NhdGlvbiAoY291bGQgYmUgdW5kaXN0cmlidXRlZClcbiAgICAgIC8vICgyKSBpZiBwYXJlbnQgaXMgYSBzbG90LCBlbGVtZW50IG1heSBub3QgYmVuIGluIGNvbXBvc2VkIGRvbVxuICAgICAgaWYgKCEocGFyZW50RGF0YS5yb290IHx8IG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpIHx8XG4gICAgICAgIChjb250YWluZXIgPT09IG5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdwYXJlbnROb2RlJ10pKSB7XG4gICAgICAgIGNvbnRhaW5lclt1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNjaGVkdWxlT2JzZXJ2ZXIodGhpcywgbnVsbCwgbm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtOb2RlPX0gcmVmX25vZGVcbiAgICovXG4gIHJlcGxhY2VDaGlsZChub2RlLCByZWZfbm9kZSkge1xuICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKG5vZGUsIHJlZl9ub2RlKTtcbiAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKHJlZl9ub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge05vZGV9XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlZXBcbiAgICovXG4gIGNsb25lTm9kZShkZWVwKSB7XG4gICAgaWYgKHRoaXMubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnY2xvbmVOb2RlJ10oZGVlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnY2xvbmVOb2RlJ10oZmFsc2UpO1xuICAgICAgLy8gQXR0cmlidXRlIG5vZGVzIGhpc3RvcmljYWxseSBoYWQgY2hpbGROb2RlcywgYnV0IHRoZXkgaGF2ZSBsYXRlclxuICAgICAgLy8gYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWMuXG4gICAgICAvLyBNYWtlIHN1cmUgd2UgZG8gbm90IGRvIGEgZGVlcCBjbG9uZSBvbiB0aGVtIGZvciBvbGQgYnJvd3NlcnMgKElFMTEpXG4gICAgICBpZiAoZGVlcCAmJiBuLm5vZGVUeXBlICE9PSBOb2RlLkFUVFJJQlVURV9OT0RFKSB7XG4gICAgICAgIGZvciAobGV0IGM9dGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddLCBuYzsgYzsgYyA9IGNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgICAgICBuYyA9IGNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Nsb25lTm9kZSddKHRydWUpO1xuICAgICAgICAgIG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ2FwcGVuZENoaWxkJ10obmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAgICovXG4gIC8vIFRPRE8oc29ydmVsbCk6IGltcGxlbWVudCBgb3B0aW9uc2AgZS5nLiBgeyBjb21wb3NlZDogYm9vbGVhbiB9YFxuICBnZXRSb290Tm9kZShvcHRpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoIXRoaXMgfHwgIXRoaXMubm9kZVR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGxldCByb290ID0gbm9kZURhdGEub3duZXJTaGFkeVJvb3Q7XG4gICAgaWYgKHJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHV0aWxzLmlzU2hhZHlSb290KHRoaXMpKSB7XG4gICAgICAgIHJvb3QgPSB0aGlzO1xuICAgICAgICBub2RlRGF0YS5vd25lclNoYWR5Um9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgICAgICByb290ID0gcGFyZW50ID8gcGFyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKG9wdGlvbnMpIDogdGhpcztcbiAgICAgICAgLy8gbWVtby1pemUgcmVzdWx0IGZvciBwZXJmb3JtYW5jZSBidXQgb25seSBtZW1vLWl6ZVxuICAgICAgICAvLyByZXN1bHQgaWYgbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuIFRoaXMgYXZvaWRzIGEgcHJvYmxlbSB3aGVyZSBhIHJvb3RcbiAgICAgICAgLy8gY2FuIGJlIGNhY2hlZCB3aGlsZSBhbiBlbGVtZW50IGlzIGluc2lkZSBhIGZyYWdtZW50LlxuICAgICAgICAvLyBJZiB0aGlzIGhhcHBlbnMgYW5kIHdlIGNhY2hlIHRoZSByZXN1bHQsIHRoZSB2YWx1ZSBjYW4gYmVjb21lIHN0YWxlXG4gICAgICAgIC8vIGJlY2F1c2UgZm9yIHBlcmYgd2UgYXZvaWQgcHJvY2Vzc2luZyB0aGUgc3VidHJlZSBvZiBhZGRlZCBmcmFnbWVudHMuXG4gICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdjb250YWlucyddKHRoaXMpKSB7XG4gICAgICAgICAgbm9kZURhdGEub3duZXJTaGFkeVJvb3QgPSByb290O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBjb250YWlucyhub2RlKSB7XG4gICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMsIG5vZGUpO1xuICB9XG5cbn0pO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuLi9zaGFkeS1kYXRhLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1hdGNoZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBoYWx0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5KG5vZGUsIG1hdGNoZXIsIGhhbHRlcikge1xuICBsZXQgbGlzdCA9IFtdO1xuICBxdWVyeUNoaWxkTm9kZXMobm9kZSwgbWF0Y2hlcixcbiAgICBoYWx0ZXIsIGxpc3QpO1xuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gcXVlcnlDaGlsZE5vZGVzKHBhcmVudCwgbWF0Y2hlciwgaGFsdGVyLCBsaXN0KSB7XG4gIGZvciAobGV0IG4gPSBwYXJlbnRbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgICAgcXVlcnlFbGVtZW50KG4sIG1hdGNoZXIsIGhhbHRlciwgbGlzdCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBxdWVyeUVsZW1lbnQobm9kZSwgbWF0Y2hlciwgaGFsdGVyLCBsaXN0KSB7XG4gIGxldCByZXN1bHQgPSBtYXRjaGVyKG5vZGUpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgbGlzdC5wdXNoKG5vZGUpO1xuICB9XG4gIGlmIChoYWx0ZXIgJiYgaGFsdGVyKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHF1ZXJ5Q2hpbGROb2Rlcyhub2RlLCBtYXRjaGVyLFxuICAgIGhhbHRlciwgbGlzdCk7XG59XG5cbi8vIE5lZWRlZCBvbiBFbGVtZW50LCBEb2N1bWVudEZyYWdtZW50LCBEb2N1bWVudFxuZXhwb3J0IGNvbnN0IFBhcmVudE5vZGVQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBnZXQgZmlyc3RFbGVtZW50Q2hpbGQoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGlmIChub2RlRGF0YSAmJiBub2RlRGF0YS5maXJzdENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBuID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddO1xuICAgICAgd2hpbGUgKG4gJiYgbi5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ107XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmaXJzdEVsZW1lbnRDaGlsZCddO1xuICAgIH1cbiAgfSxcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBsYXN0RWxlbWVudENoaWxkKCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBpZiAobm9kZURhdGEgJiYgbm9kZURhdGEubGFzdENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBuID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnbGFzdENoaWxkJ107XG4gICAgICB3aGlsZSAobiAmJiBuLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAncHJldmlvdXNTaWJsaW5nJ107XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdsYXN0RWxlbWVudENoaWxkJ107XG4gICAgfVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIGlmICghdXRpbHMuaXNUcmFja2luZ0xvZ2ljYWxDaGlsZE5vZGVzKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2NoaWxkcmVuJ107XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5jcmVhdGVQb2x5ZmlsbGVkSFRNTENvbGxlY3Rpb24oQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKFxuICAgICAgICB1dGlscy5jaGlsZE5vZGVzQXJyYXkodGhpcyksIChuKSA9PiB7XG4gICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBnZXQgY2hpbGRFbGVtZW50Q291bnQoKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnY2hpbGRyZW4nXTtcbiAgICBpZihjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxufSk7XG5cbmV4cG9ydCBjb25zdCBRdWVyeVBhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcbiAgLy8gVE9ETyhzb3J2ZWxsKTogY29uc2lkZXIgZG9pbmcgbmF0aXZlIFFTQSBhbmQgZmlsdGVyaW5nIHJlc3VsdHMuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtICB7c3RyaW5nfSBzZWxlY3RvclxuICAgKi9cbiAgcXVlcnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIC8vIG1hdGNoIHNlbGVjdG9yIGFuZCBoYWx0IG9uIGZpcnN0IHJlc3VsdC5cbiAgICBsZXQgcmVzdWx0ID0gcXVlcnkodGhpcywgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHV0aWxzLm1hdGNoZXNTZWxlY3RvcihuLCBzZWxlY3Rvcik7XG4gICAgfSwgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIEJvb2xlYW4obik7XG4gICAgfSlbMF07XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtICB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiBAcGFyYW0gIHtib29sZWFufSB1c2VOYXRpdmVcbiAgICovXG4gIC8vIFRPRE8oc29ydmVsbCk6IGB1c2VOYXRpdmVgIG9wdGlvbiByZWxpZXMgb24gbmF0aXZlIHF1ZXJ5U2VsZWN0b3JBbGwgYW5kXG4gIC8vIG1pc3NlcyBkaXN0cmlidXRlZCBub2Rlcywgc2VlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3B1bGwvMjEwI2lzc3VlY29tbWVudC0zNjE0MzU1MDNcbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgdXNlTmF0aXZlKSB7XG4gICAgaWYgKHVzZU5hdGl2ZSkge1xuICAgICAgY29uc3QgbyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdxdWVyeVNlbGVjdG9yQWxsJ10oc2VsZWN0b3IpKTtcbiAgICAgIGNvbnN0IHJvb3QgPSB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKCk7XG4gICAgICByZXR1cm4gby5maWx0ZXIoZSA9PiBlW3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKCkgPT0gcm9vdCk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeSh0aGlzLCBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWF0Y2hlc1NlbGVjdG9yKG4sIHNlbGVjdG9yKTtcbiAgICB9KTtcbiAgfVxuXG59KTtcblxuLy8gSW4gcHJlZmVyUGVyZm9ybWFuY2UgbW9kZSwgY3JlYXRlIGEgY3VzdG9tIGBQYXJlbnROb2RlRG9jdW1lbnRPckZyYWdtZW50YFxuLy8gdGhhdCBvcHRpb25hbGx5IGRvZXMgbm90IG1peGluIHF1ZXJ5U2VsZWN0b3IvQWxsOyB0aGlzIGlzIGEgcGVyZm9ybWFuY2Vcbi8vIG9wdGltaXphdGlvbi4gSW4gbm9QYXRjaCwgd2UgbmVlZCB0byBrZWVwIHRoZSBxdWVyeSBwYXRjaGVzIGhlcmUgaW4gb3JkZXIgdG9cbi8vIGVuc3VyZSB0aGUgcXVlcnkgQVBJIGlzIGF2YWlsYWJsZSBvbiB0aGUgd3JhcHBlclxuZXhwb3J0IGNvbnN0IFBhcmVudE5vZGVEb2N1bWVudE9yRnJhZ21lbnRQYXRjaGVzID1cbiAgKHV0aWxzLnNldHRpbmdzLnByZWZlclBlcmZvcm1hbmNlICYmICF1dGlscy5zZXR0aW5ncy5ub1BhdGNoKSA/XG4gIE9iamVjdC5hc3NpZ24oe30sIFBhcmVudE5vZGVQYXRjaGVzKSA6IFBhcmVudE5vZGVQYXRjaGVzO1xuXG5PYmplY3QuYXNzaWduKFBhcmVudE5vZGVQYXRjaGVzLCBRdWVyeVBhdGNoZXMpOyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgeyBxdWVyeSB9IGZyb20gJy4vUGFyZW50Tm9kZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBEb2N1bWVudE9yRnJhZ21lbnRQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtFbGVtZW50fVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICovXG4gIGdldEVsZW1lbnRCeUlkKGlkKSB7XG4gICAgaWYgKGlkID09PSAnJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBxdWVyeSh0aGlzLCBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gbi5pZCA9PSBpZDtcbiAgICB9LCBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihuKTtcbiAgICB9KVswXTtcbiAgICByZXR1cm4gcmVzdWx0IHx8IG51bGw7XG4gIH1cblxufSk7IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtvd25lclNoYWR5Um9vdEZvck5vZGV9IGZyb20gJy4uL2F0dGFjaC1zaGFkb3cuanMnO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudEFjdGl2ZUVsZW1lbnQoKSB7XG4gIGlmICh1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycykge1xuICAgIHJldHVybiBkb2N1bWVudFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2FjdGl2ZUVsZW1lbnQnXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRG9jdW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtEb2N1bWVudHxTaGFkb3dSb290fSAqL1xuICBnZXQgYWN0aXZlRWxlbWVudCgpIHtcbiAgICBsZXQgYWN0aXZlID0gZ2V0RG9jdW1lbnRBY3RpdmVFbGVtZW50KCk7XG4gICAgLy8gSW4gSUUxMSwgYWN0aXZlRWxlbWVudCBtaWdodCBiZSBhbiBlbXB0eSBvYmplY3QgaWYgdGhlIGRvY3VtZW50IGlzXG4gICAgLy8gY29udGFpbmVkIGluIGFuIGlmcmFtZS5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDk5ODc4OC9cbiAgICBpZiAoIWFjdGl2ZSB8fCAhYWN0aXZlLm5vZGVUeXBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGlzU2hhZHlSb290ID0gISEodXRpbHMuaXNTaGFkeVJvb3QodGhpcykpO1xuICAgIGlmICh0aGlzICE9PSBkb2N1bWVudCkge1xuICAgICAgLy8gSWYgdGhpcyBub2RlIGlzbid0IGEgZG9jdW1lbnQgb3Igc2hhZHkgcm9vdCwgdGhlbiBpdCBkb2Vzbid0IGhhdmVcbiAgICAgIC8vIGFuIGFjdGl2ZSBlbGVtZW50LlxuICAgICAgaWYgKCFpc1NoYWR5Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoaXMgc2hhZHkgcm9vdCdzIGhvc3QgaXMgdGhlIGFjdGl2ZSBlbGVtZW50IG9yIHRoZSBhY3RpdmVcbiAgICAgIC8vIGVsZW1lbnQgaXMgbm90IGEgZGVzY2VuZGFudCBvZiB0aGUgaG9zdCAoaW4gdGhlIGNvbXBvc2VkIHRyZWUpLFxuICAgICAgLy8gdGhlbiBpdCBkb2Vzbid0IGhhdmUgYW4gYWN0aXZlIGVsZW1lbnQuXG4gICAgICBpZiAodGhpcy5ob3N0ID09PSBhY3RpdmUgfHxcbiAgICAgICAgICAhdGhpcy5ob3N0W3V0aWxzLk5BVElWRV9QUkVGSVggKyAnY29udGFpbnMnXShhY3RpdmUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIG5vZGUgaXMgZWl0aGVyIHRoZSBkb2N1bWVudCBvciBhIHNoYWR5IHJvb3Qgb2Ygd2hpY2ggdGhlIGFjdGl2ZVxuICAgIC8vIGVsZW1lbnQgaXMgYSAoY29tcG9zZWQpIGRlc2NlbmRhbnQgb2YgaXRzIGhvc3Q7IGl0ZXJhdGUgdXB3YXJkcyB0b1xuICAgIC8vIGZpbmQgdGhlIGFjdGl2ZSBlbGVtZW50J3MgbW9zdCBzaGFsbG93IGhvc3Qgd2l0aGluIGl0LlxuICAgIGxldCBhY3RpdmVSb290ID0gb3duZXJTaGFkeVJvb3RGb3JOb2RlKGFjdGl2ZSk7XG4gICAgd2hpbGUgKGFjdGl2ZVJvb3QgJiYgYWN0aXZlUm9vdCAhPT0gdGhpcykge1xuICAgICAgYWN0aXZlID0gYWN0aXZlUm9vdC5ob3N0O1xuICAgICAgYWN0aXZlUm9vdCA9IG93bmVyU2hhZHlSb290Rm9yTm9kZShhY3RpdmUpO1xuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBpcyB0aGUgZG9jdW1lbnQsIHNvIGFjdGl2ZVJvb3Qgc2hvdWxkIGJlIG51bGwuXG4gICAgICByZXR1cm4gYWN0aXZlUm9vdCA/IG51bGwgOiBhY3RpdmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBpcyBhIG5vbi1kb2N1bWVudCBzaGFkeSByb290LCBhbmQgaXQgc2hvdWxkIGJlXG4gICAgICAvLyBhY3RpdmVSb290LlxuICAgICAgcmV0dXJuIGFjdGl2ZVJvb3QgPT09IHRoaXMgPyBhY3RpdmUgOiBudWxsO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQge2dldElubmVySFRNTH0gZnJvbSAnLi4vaW5uZXJIVE1MLmpzJztcbmltcG9ydCB7Y2xlYXJOb2RlfSBmcm9tICcuL05vZGUuanMnO1xuXG4vKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbmNvbnN0IGluZXJ0RG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdpbmVydCcpO1xuXG5leHBvcnQgY29uc3QgRWxlbWVudE9yU2hhZG93Um9vdFBhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBpbm5lckhUTUwoKSB7XG4gICAgaWYgKHV0aWxzLmlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2Rlcyh0aGlzKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnID9cbiAgICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGhpcykuY29udGVudCA6IHRoaXM7XG4gICAgICByZXR1cm4gZ2V0SW5uZXJIVE1MKGNvbnRlbnQsIHV0aWxzLmNoaWxkTm9kZXNBcnJheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW5uZXJIVE1MJ107XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXQgaW5uZXJIVE1MKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW5uZXJIVE1MJ10gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJOb2RlKHRoaXMpO1xuICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IHRoaXMubG9jYWxOYW1lIHx8ICdkaXYnO1xuICAgICAgbGV0IGh0bWxDb250YWluZXI7XG4gICAgICBpZiAoIXRoaXMubmFtZXNwYWNlVVJJIHx8IHRoaXMubmFtZXNwYWNlVVJJID09PSBpbmVydERvYy5uYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgaHRtbENvbnRhaW5lciA9IGluZXJ0RG9jLmNyZWF0ZUVsZW1lbnQoY29udGFpbmVyTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sQ29udGFpbmVyID0gaW5lcnREb2MuY3JlYXRlRWxlbWVudE5TKHRoaXMubmFtZXNwYWNlVVJJLCBjb250YWluZXJOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycykge1xuICAgICAgICBodG1sQ29udGFpbmVyW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW5uZXJIVE1MJ10gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWxDb250YWluZXIuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBsZXQgZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlICgoZmlyc3RDaGlsZCA9IGh0bWxDb250YWluZXJbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXSkpIHtcbiAgICAgICAgdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10oZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0pO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5leHBvcnQgY29uc3QgU2hhZG93Um9vdFBhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKipcbiAgICogQHRoaXMge1NoYWRvd1Jvb3R9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSBvcHRpb25zT3JDYXB0dXJlXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYXB0dXJlICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uc09yQ2FwdHVyZSA9IHtcbiAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RlLCBgX19zaGFkeVRhcmdldGAgbWF5IGFscmVhZHkgYmUgc2V0IGlmIGFuIGV2ZW50IHdhcyBhZGRlZCBvbiBhIDxzbG90PiBjaGlsZFxuICAgIG9wdGlvbnNPckNhcHR1cmUuX19zaGFkeVRhcmdldCA9IG9wdGlvbnNPckNhcHR1cmUuX19zaGFkeVRhcmdldCB8fCB0aGlzO1xuICAgIHRoaXMuaG9zdFt1dGlscy5TSEFEWV9QUkVGSVggKyAnYWRkRXZlbnRMaXN0ZW5lciddKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge1NoYWRvd1Jvb3R9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSBvcHRpb25zT3JDYXB0dXJlXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYXB0dXJlICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9uc09yQ2FwdHVyZSA9IHtcbiAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RlLCBgX19zaGFkeVRhcmdldGAgbWF5IGFscmVhZHkgYmUgc2V0IGlmIGFuIGV2ZW50IHdhcyBhZGRlZCBvbiBhIDxzbG90PiBjaGlsZFxuICAgIG9wdGlvbnNPckNhcHR1cmUuX19zaGFkeVRhcmdldCA9IG9wdGlvbnNPckNhcHR1cmUuX19zaGFkeVRhcmdldCB8fCB0aGlzO1xuICAgIHRoaXMuaG9zdFt1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlRXZlbnRMaXN0ZW5lciddKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgfVxuXG59KTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtOb2RlUGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL05vZGUuanMnO1xuaW1wb3J0IHtPdXRzaWRlRGVzY3JpcHRvcnMsIEluc2lkZURlc2NyaXB0b3JzLCBUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzfSBmcm9tICcuL3BhdGNoLWluc3RhbmNlcy5qcyc7XG5pbXBvcnQge1BhcmVudE5vZGVQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvUGFyZW50Tm9kZS5qcyc7XG5pbXBvcnQge0RvY3VtZW50T3JGcmFnbWVudFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Eb2N1bWVudE9yRnJhZ21lbnQuanMnO1xuaW1wb3J0IHtEb2N1bWVudE9yU2hhZG93Um9vdFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Eb2N1bWVudE9yU2hhZG93Um9vdC5qcyc7XG5pbXBvcnQge0VsZW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvRWxlbWVudE9yU2hhZG93Um9vdC5qcyc7XG5pbXBvcnQge1NoYWRvd1Jvb3RQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvU2hhZG93Um9vdC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBwcm90b1xuICogQHBhcmFtIHtzdHJpbmc9fSBwcmVmaXhcbiAqL1xuY29uc3QgcGF0Y2hTaGFkeUFjY2Vzc29ycyA9IChwcm90bywgcHJlZml4KSA9PiB7XG4gIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgU2hhZG93Um9vdFBhdGNoZXMsIHByZWZpeCk7XG4gIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgRG9jdW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzLCBwcmVmaXgpO1xuICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIEVsZW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzLCBwcmVmaXgpO1xuICAvLyBXZSBlbnN1cmUgUGFyZW50Tm9kZSBhY2Nlc3NvcnMgc2luY2UgdGhlc2UgZG8gbm90IGV4aXN0IGluIEVkZ2UvSUUgb24gRG9jdW1lbnRGcmFnbWVudHMuXG4gIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgUGFyZW50Tm9kZVBhdGNoZXMsIHByZWZpeCk7XG4gIC8vIEVuc3VyZSBgc2hhZG93Um9vdGAgaGFzIGJhc2ljIGRlc2NyaXB0b3JzIHdoZW4gd2UgY2Fubm90IHJlbHlcbiAgLy8gb24gdGhlbSBjb21pbmcgZnJvbSBEb2N1bWVudEZyYWdtZW50LlxuICAvL1xuICAvLyBDYXNlIDEsIG5vUGF0Y2hpbmc6IEJlY2F1c2Ugd2Ugd2FudCBub1BhdGNoIFNoYWR5Um9vdHMgdG8gaGF2ZSBuYXRpdmUgcHJvcGVydHlcbiAgLy8gbmFtZXMgc28gdGhhdCB0aGV5IGRvIG5vdCBoYXZlIHRvIGJlIHdyYXBwZWQuLi5cbiAgLy8gV2hlbiB3ZSBkbyAqbm90KiBwYXRjaCBOb2RlL0RvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlXG4gIC8vIHdlIG11c3QgbWFudWFsbHkgaW5zdGFsbCB0aG9zZSBwcm9wZXJ0aWVzIG9uIFNoYWR5Um9vdCdzIHByb3RvdHlwZS5cbiAgLy8gTm90ZSwgaXQncyBpbXBvcnRhbnQgdG8gb25seSBpbnN0YWxsIHRoZXNlIGluIHRoaXMgbW9kZSBzbyBhcyBub3QgdG8gc3RvbXBcbiAgLy8gb3ZlciBDdXN0b21FbGVtZW50cyBwb2x5ZmlsbCdzIHBhdGNoZXMgb24gTm9kZS9Eb2N1bWVudEZyYWdtZW50IG1ldGhvZHMuXG4gIGlmICh1dGlscy5zZXR0aW5ncy5ub1BhdGNoICYmICFwcmVmaXgpIHtcbiAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIE5vZGVQYXRjaGVzLCBwcmVmaXgpO1xuICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcywgcHJlZml4KTtcbiAgLy8gQ2FzZSAyLCBiYWQgZGVzY3JpcHRvcnM6IEVuc3VyZSBhY2Nlc3NvcnMgYXJlIG9uIFNoYWRvd1Jvb3QuXG4gIC8vIFRoZXNlIGRlc2NyaXB0b3JzIGFyZSBub3JtYWxseSB1c2VkIGZvciBpbnN0YW5jZSBwYXRjaGluZyBidXQgYmVjYXVzZVxuICAvLyBTaGFkeVJvb3QgY2FuIGFsd2F5cyBiZSBwYXRjaGVkLCBqdXN0IGRvIGl0IHRvIHRoZSBwcm90b3R5cGUuXG4gIH0gZWxzZSBpZiAoIXV0aWxzLnNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzKSB7XG4gICAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKHByb3RvLCBPdXRzaWRlRGVzY3JpcHRvcnMpO1xuICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgSW5zaWRlRGVzY3JpcHRvcnMpO1xuICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgVGV4dENvbnRlbnRJbm5lckhUTUxEZXNjcmlwdG9ycyk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHBhdGNoU2hhZHlSb290ID0gKHByb3RvKSA9PiB7XG4gIHByb3RvLl9fcHJvdG9fXyA9IERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlO1xuXG4gIC8vIHBhdGNoIGJvdGggcHJlZml4ZWQgYW5kIG5vdCwgZXZlbiB3aGVuIG5vUGF0Y2ggPT0gdHJ1ZS5cbiAgcGF0Y2hTaGFkeUFjY2Vzc29ycyhwcm90bywgdXRpbHMuU0hBRFlfUFJFRklYKTtcbiAgcGF0Y2hTaGFkeUFjY2Vzc29ycyhwcm90byk7XG5cbiAgLy8gRW5zdXJlIG5hdGl2ZSBwcm9wZXJ0aWVzIGFyZSBhbGwgc2FmZWx5IHdyYXBwZWQgc2luY2UgU2hhZG93Um9vdCBpcyBub3QgYW5cbiAgLy8gYWN0dWFsIERvY3VtZW50RnJhZ21lbnQgaW5zdGFuY2UuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvLCB7XG4gICAgbm9kZVR5cGU6IHtcbiAgICAgIHZhbHVlOiBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuICAgIG5vZGVOYW1lOiB7XG4gICAgICB2YWx1ZTogJyNkb2N1bWVudC1mcmFnbWVudCcsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuICAgIG5vZGVWYWx1ZToge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuXG4gIC8vIG1ha2UgdW5kZWZpbmVkXG4gIFtcbiAgICAnbG9jYWxOYW1lJyxcbiAgICAnbmFtZXNwYWNlVVJJJyxcbiAgICAncHJlZml4J1xuICBdLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIHByb3AsIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gZGVmZXIgcHJvcGVydGllcyB0byBob3N0XG4gIFtcbiAgICAnb3duZXJEb2N1bWVudCcsXG4gICAgJ2Jhc2VVUkknLFxuICAgICdpc0Nvbm5lY3RlZCdcbiAgXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBwcm9wLCB7XG4gICAgICAvKiogQHRoaXMge1NoYWRvd1Jvb3R9ICovXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RbcHJvcF07XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0IHtjYWxjdWxhdGVTcGxpY2VzfSBmcm9tICcuL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7ZW5xdWV1ZX0gZnJvbSAnLi9mbHVzaC5qcyc7XG5pbXBvcnQge2Vuc3VyZVNoYWR5RGF0YUZvck5vZGUsIHNoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4vc2hhZHktZGF0YS5qcyc7XG5pbXBvcnQge3JlY29yZENoaWxkTm9kZXN9IGZyb20gJy4vbGluay1ub2Rlcy5qcyc7XG5pbXBvcnQge3BhdGNoU2hhZHlSb290fSBmcm9tICcuL3BhdGNoLXNoYWR5Um9vdC5qcyc7XG5cbi8vIERvIG5vdCBleHBvcnQgdGhpcyBvYmplY3QuIEl0IG11c3QgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbi8vIFNoYWR5Um9vdCBjb25zdHJ1Y3RvciBpbiBgYXR0YWNoU2hhZG93YCB0byBwcmV2ZW50IHRoZSBjb25zdHJ1Y3RvciBmcm9tXG4vLyB0aHJvd2luZy4gVGhpcyBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGJlaW5nIGFibGUgdG8gbWFudWFsbHkgY29uc3RydWN0IGFcbi8vIFNoYWR5Um9vdCAoaS5lLiBgbmV3IFNoYWRvd1Jvb3QoKWApLlxuY29uc3QgU2hhZHlSb290Q29uc3RydWN0aW9uVG9rZW4gPSB7fTtcblxuY29uc3QgQ0FUQ0hBTExfTkFNRSA9ICdfX2NhdGNoYWxsJztcbmNvbnN0IFNIQURZUk9PVF9OQU1FID0gJ1NoYWR5Um9vdCc7XG5cbmNvbnN0IE1PREVfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5cbmxldCBpc1JlbmRlcmluZyA9IHV0aWxzLnNldHRpbmdzWydkZWZlckNvbm5lY3Rpb25DYWxsYmFja3MnXSAmJiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZyc7XG5sZXQgcm9vdFJlbmRlcmVkO1xuXG5mdW5jdGlvbiBhbmNlc3Rvckxpc3Qobm9kZSkge1xuICBsZXQgYW5jZXN0b3JzID0gW107XG4gIGRvIHtcbiAgICBhbmNlc3RvcnMudW5zaGlmdChub2RlKTtcbiAgfSB3aGlsZSAoKG5vZGUgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ10pKTtcbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuLyoqXG4gKiBAZXh0ZW5kcyB7U2hhZG93Um9vdH1cbiAqL1xuY2xhc3MgU2hhZHlSb290IHtcblxuICBjb25zdHJ1Y3Rvcih0b2tlbiwgaG9zdCwgb3B0aW9ucykge1xuICAgIGlmICh0b2tlbiAhPT0gU2hhZHlSb290Q29uc3RydWN0aW9uVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuX3JlbmRlclBlbmRpbmc7XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuX2hhc1JlbmRlcmVkO1xuICAgIC8qKiBAdHlwZSB7P0FycmF5PEhUTUxTbG90RWxlbWVudD59ICovXG4gICAgdGhpcy5fc2xvdExpc3QgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7P09iamVjdDxzdHJpbmcsIEFycmF5PEhUTUxTbG90RWxlbWVudD4+fSAqL1xuICAgIHRoaXMuX3Nsb3RNYXA7XG4gICAgLyoqIEB0eXBlIHs/QXJyYXk8SFRNTFNsb3RFbGVtZW50Pn0gKi9cbiAgICB0aGlzLl9wZW5kaW5nU2xvdHM7XG4gICAgdGhpcy5faW5pdChob3N0LCBvcHRpb25zKTtcbiAgfVxuXG4gIF9pbml0KGhvc3QsIG9wdGlvbnMpIHtcbiAgICAvLyBOT1RFOiBzZXQgYSBmYWtlIGxvY2FsIG5hbWUgc28gdGhpcyBlbGVtZW50IGNhbiBiZVxuICAgIC8vIGRpc3Rpbmd1aXNoZWQgZnJvbSBhIERvY3VtZW50RnJhZ21lbnQgd2hlbiBwYXRjaGluZy5cbiAgICAvLyBGRiBkb2Vzbid0IGFsbG93IHRoaXMgdG8gYmUgYGxvY2FsTmFtZWBcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLl9sb2NhbE5hbWUgPSBTSEFEWVJPT1RfTkFNRTtcbiAgICAvLyByb290IDw9PiBob3N0XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAvKiogQHR5cGUgeyFzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tb2RlO1xuICAgIHJlY29yZENoaWxkTm9kZXModGhpcy5ob3N0KTtcbiAgICBjb25zdCBob3N0RGF0YSA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUodGhpcy5ob3N0KTtcbiAgICAvKiogQHR5cGUgeyFTaGFkeVJvb3R9ICovXG4gICAgaG9zdERhdGEucm9vdCA9IHRoaXM7XG4gICAgaG9zdERhdGEucHVibGljUm9vdCA9IHRoaXMubW9kZSAhPT0gTU9ERV9DTE9TRUQgPyB0aGlzIDogbnVsbDtcbiAgICAvLyBzZXR1cCByb290XG4gICAgY29uc3Qgcm9vdERhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIHJvb3REYXRhLmZpcnN0Q2hpbGQgPSByb290RGF0YS5sYXN0Q2hpbGQgPVxuICAgICAgICByb290RGF0YS5wYXJlbnROb2RlID0gcm9vdERhdGEubmV4dFNpYmxpbmcgPVxuICAgICAgICByb290RGF0YS5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIC8vIE5PVEU6IG9wdGltaXphdGlvbiBmbGFnLCBvbmx5IHJlcXVpcmUgYW4gYXN5bmNocm9ub3VzIHJlbmRlclxuICAgIC8vIHRvIHJlY29yZCBwYXJzZWQgY2hpbGRyZW4gaWYgZmxhZyBpcyBub3Qgc2V0LlxuICAgIGlmICh1dGlscy5zZXR0aW5nc1sncHJlZmVyUGVyZm9ybWFuY2UnXSkge1xuICAgICAgbGV0IG47XG4gICAgICB3aGlsZSAoKG4gPSB0aGlzLmhvc3RbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ10pKSB7XG4gICAgICAgIHRoaXMuaG9zdFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FzeW5jUmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2FzeW5jUmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyUGVuZGluZykge1xuICAgICAgdGhpcy5fcmVuZGVyUGVuZGluZyA9IHRydWU7XG4gICAgICBlbnF1ZXVlKCgpID0+IHRoaXMuX3JlbmRlcigpKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm5zIHRoZSBvbGRlc3QgcmVuZGVyUGVuZGluZyBhbmNlc3RvciByb290LlxuICBfZ2V0UGVuZGluZ0Rpc3RyaWJ1dGlvblJvb3QoKSB7XG4gICAgbGV0IHJlbmRlclJvb3Q7XG4gICAgbGV0IHJvb3QgPSB0aGlzO1xuICAgIHdoaWxlIChyb290KSB7XG4gICAgICBpZiAocm9vdC5fcmVuZGVyUGVuZGluZykge1xuICAgICAgICByZW5kZXJSb290ID0gcm9vdDtcbiAgICAgIH1cbiAgICAgIHJvb3QgPSByb290Ll9nZXREaXN0cmlidXRpb25QYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlclJvb3Q7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBzaGFkeVJvb3QgYHRoaXMuaG9zdGAgaWYgYHRoaXMuaG9zdGBcbiAgLy8gaGFzIGNoaWxkcmVuIHRoYXQgcmVxdWlyZSBkaXN0cmlidXRpb24uXG4gIF9nZXREaXN0cmlidXRpb25QYXJlbnQoKSB7XG4gICAgbGV0IHJvb3QgPSB0aGlzLmhvc3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2dldFJvb3ROb2RlJ10oKTtcbiAgICBpZiAoIXV0aWxzLmlzU2hhZHlSb290KHJvb3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzLmhvc3QpO1xuICAgIGlmIChub2RlRGF0YSAmJiBub2RlRGF0YS5fX2NoaWxkU2xvdENvdW50ID4gMCkge1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVuZGVycyB0aGUgdG9wIG1vc3QgcmVuZGVyIHBlbmRpbmcgc2hhZG93Um9vdCBpbiB0aGUgZGlzdHJpYnV0aW9uIHRyZWUuXG4gIC8vIFRoaXMgaXMgc2FmZSBiZWNhdXNlIHdoZW4gYSBkaXN0cmlidXRpb24gcGFyZW50IHJlbmRlcnMsIGFsbCBjaGlsZHJlbiByZW5kZXIuXG4gIF9yZW5kZXIoKSB7XG4gICAgLy8gSWYgdGhpcyByb290IGlzIG5vdCBwZW5kaW5nLCBpdCBuZWVkcyBubyByZW5kZXJpbmcgd29yay4gQW55IHBlbmRpbmdcbiAgICAvLyBwYXJlbnQgdGhhdCBuZWVkcyB0byByZW5kZXIgd2xsIGNhdXNlIHRoaXMgcm9vdCB0byByZW5kZXIuXG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuX3JlbmRlclBlbmRpbmcgJiYgdGhpcy5fZ2V0UGVuZGluZ0Rpc3RyaWJ1dGlvblJvb3QoKTtcbiAgICBpZiAocm9vdCkge1xuICAgICAgcm9vdC5fcmVuZGVyU2VsZigpO1xuICAgIH1cbiAgfVxuXG4gIF9mbHVzaEluaXRpYWwoKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNSZW5kZXJlZCAmJiB0aGlzLl9yZW5kZXJQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIF9yZW5kZXJTZWxmKCkge1xuICAgIC8vIHRyYWNrIHJlbmRlcmluZyBzdGF0ZS5cbiAgICBjb25zdCB3YXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG4gICAgdGhpcy5fcmVuZGVyUGVuZGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9zbG90TGlzdCkge1xuICAgICAgdGhpcy5fZGlzdHJpYnV0ZSgpO1xuICAgICAgdGhpcy5fY29tcG9zZSgpO1xuICAgIH1cbiAgICAvLyBOT1RFOiBvcHRpbWl6YXRpb24gZmxhZywgb25seSBwcm9jZXNzIHBhcnNlZCBjaGlsZHJlblxuICAgIC8vIGlmIG9wdGltaXphdGlvbiBmbGFnIGlzIG5vdCBzZXQuXG4gICAgLy8gb24gaW5pdGlhbCByZW5kZXIgcmVtb3ZlIGFueSB1bmRpc3RyaWJ1dGVkIGNoaWxkcmVuLlxuICAgIGlmICghdXRpbHMuc2V0dGluZ3NbJ3ByZWZlclBlcmZvcm1hbmNlJ10gJiYgIXRoaXMuX2hhc1JlbmRlcmVkKSB7XG4gICAgICBmb3IgKGxldCBuPXRoaXMuaG9zdFt1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgICAgICBjb25zdCBkYXRhID0gc2hhZHlEYXRhRm9yTm9kZShuKTtcbiAgICAgICAgaWYgKG5bdXRpbHMuTkFUSVZFX1BSRUZJWCArICdwYXJlbnROb2RlJ10gPT09IHRoaXMuaG9zdCAmJlxuICAgICAgICAgICAgKG4ubG9jYWxOYW1lID09PSAnc2xvdCcgfHwgIWRhdGEuYXNzaWduZWRTbG90KSkge1xuICAgICAgICAgIHRoaXMuaG9zdFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGFzUmVuZGVyZWQgPSB0cnVlO1xuICAgIGlzUmVuZGVyaW5nID0gd2FzUmVuZGVyaW5nO1xuICAgIGlmIChyb290UmVuZGVyZWQpIHtcbiAgICAgIHJvb3RSZW5kZXJlZCgpO1xuICAgIH1cbiAgfVxuXG4gIF9kaXN0cmlidXRlKCkge1xuICAgIHRoaXMuX3ZhbGlkYXRlU2xvdHMoKTtcbiAgICAvLyBjYXB0dXJlICMgb2YgcHJldmlvdXNseSBhc3NpZ25lZCBub2RlcyB0byBoZWxwIGRldGVybWluZSBpZiBkaXJ0eS5cbiAgICBmb3IgKGxldCBpPTAsIHNsb3Q7IGkgPCB0aGlzLl9zbG90TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgc2xvdCA9IHRoaXMuX3Nsb3RMaXN0W2ldO1xuICAgICAgdGhpcy5fY2xlYXJTbG90QXNzaWduZWROb2RlcyhzbG90KTtcbiAgICB9XG4gICAgLy8gZGlzdHJpYnV0ZSBob3N0IGNoaWxkcmVuLlxuICAgIGZvciAobGV0IG49dGhpcy5ob3N0W3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG49blt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgICAgdGhpcy5fZGlzdHJpYnV0ZU5vZGVUb1Nsb3Qobik7XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGNvbnRlbnQsIHNsb3RjaGFuZ2UsIGFuZCBkaXJ0eSByb290c1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHRoaXMuX3Nsb3RMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzbG90ID0gdGhpcy5fc2xvdExpc3RbaV07XG4gICAgICBjb25zdCBzbG90RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUoc2xvdCk7XG4gICAgICAvLyBkaXN0cmlidXRlIGZhbGxiYWNrIGNvbnRlbnRcbiAgICAgIGlmICghc2xvdERhdGEuYXNzaWduZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgbj1zbG90W3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG49blt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgICAgICAgIHRoaXMuX2Rpc3RyaWJ1dGVOb2RlVG9TbG90KG4sIHNsb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzbG90UGFyZW50RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUoc2xvdFt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddKTtcbiAgICAgIGNvbnN0IHNsb3RQYXJlbnRSb290ID0gc2xvdFBhcmVudERhdGEgJiYgc2xvdFBhcmVudERhdGEucm9vdDtcbiAgICAgIGlmIChzbG90UGFyZW50Um9vdCAmJiAoc2xvdFBhcmVudFJvb3QuX2hhc0luc2VydGlvblBvaW50KCkgfHwgc2xvdFBhcmVudFJvb3QuX3JlbmRlclBlbmRpbmcpKSB7XG4gICAgICAgIHNsb3RQYXJlbnRSb290Ll9yZW5kZXJTZWxmKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRBc3NpZ25lZFRvRmxhdHRlbmVkTm9kZXMoc2xvdERhdGEuZmxhdHRlbmVkTm9kZXMsXG4gICAgICAgIHNsb3REYXRhLmFzc2lnbmVkTm9kZXMpO1xuICAgICAgbGV0IHByZXZBc3NpZ25lZE5vZGVzID0gc2xvdERhdGEuX3ByZXZpb3VzbHlBc3NpZ25lZE5vZGVzO1xuICAgICAgaWYgKHByZXZBc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHByZXZBc3NpZ25lZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2hhZHlEYXRhRm9yTm9kZShwcmV2QXNzaWduZWROb2Rlc1tpXSkuX3ByZXZBc3NpZ25lZFNsb3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNsb3REYXRhLl9wcmV2aW91c2x5QXNzaWduZWROb2RlcyA9IG51bGw7XG4gICAgICAgIC8vIGRpcnR5IGlmIHByZXZpb3VzbHkgbGVzcyBhc3NpZ25lZCBub2RlcyB0aGFuIHByZXZpb3VzbHkgYXNzaWduZWQuXG4gICAgICAgIGlmIChwcmV2QXNzaWduZWROb2Rlcy5sZW5ndGggPiBzbG90RGF0YS5hc3NpZ25lZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNsb3REYXRhLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogTm90ZTogQSBzbG90IGlzIG1hcmtlZCBkaXJ0eSB3aGVuZXZlciBhIG5vZGUgaXMgbmV3bHkgYXNzaWduZWQgdG8gaXRcbiAgICAgIG9yIGEgbm9kZSBpcyBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCBzbG90IChkb25lIGluIGBfZGlzdHJpYnV0ZU5vZGVUb1Nsb3RgKVxuICAgICAgb3IgaWYgdGhlIG51bWJlciBvZiBub2RlcyBhc3NpZ25lZCB0byB0aGUgc2xvdCBoYXMgZGVjcmVhc2VkIChkb25lIGFib3ZlKTtcbiAgICAgICovXG4gICAgICBpZiAoc2xvdERhdGEuZGlydHkpIHtcbiAgICAgICAgc2xvdERhdGEuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyZVNsb3RDaGFuZ2Uoc2xvdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3RyaWJ1dGVzIGdpdmVuIGBub2RlYCB0byB0aGUgYXBwcm9wcmlhdGUgc2xvdCBiYXNlZCBvbiBpdHMgYHNsb3RgXG4gICAqIGF0dHJpYnV0ZS4gSWYgYGZvcmNlZFNsb3RgIGlzIGdpdmVuLCB0aGVuIHRoZSBub2RlIGlzIGRpc3RyaWJ1dGVkIHRvIHRoZVxuICAgKiBgZm9yY2VkU2xvdGAuXG4gICAqIE5vdGU6IHNsb3QgdG8gd2hpY2ggdGhlIG5vZGUgaXMgYXNzaWduZWQgd2lsbCBiZSBtYXJrZWQgZGlydHkgZm9yIGZpcmluZ1xuICAgKiBgc2xvdGNoYW5nZWAuXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge05vZGU9fSBmb3JjZWRTbG90XG4gICAqXG4gICAqL1xuICBfZGlzdHJpYnV0ZU5vZGVUb1Nsb3Qobm9kZSwgZm9yY2VkU2xvdCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgICBsZXQgb2xkU2xvdCA9IG5vZGVEYXRhLl9wcmV2QXNzaWduZWRTbG90O1xuICAgIG5vZGVEYXRhLl9wcmV2QXNzaWduZWRTbG90ID0gbnVsbDtcbiAgICBsZXQgc2xvdCA9IGZvcmNlZFNsb3Q7XG4gICAgaWYgKCFzbG90KSB7XG4gICAgICBsZXQgbmFtZSA9IG5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3Nsb3QnXSB8fCBDQVRDSEFMTF9OQU1FO1xuICAgICAgY29uc3QgbGlzdCA9IHRoaXMuX3Nsb3RNYXBbbmFtZV07XG4gICAgICBzbG90ID0gbGlzdCAmJiBsaXN0WzBdO1xuICAgIH1cbiAgICBpZiAoc2xvdCkge1xuICAgICAgY29uc3Qgc2xvdERhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHNsb3QpO1xuICAgICAgc2xvdERhdGEuYXNzaWduZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZURhdGEuYXNzaWduZWRTbG90ID0gc2xvdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZURhdGEuYXNzaWduZWRTbG90ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2xkU2xvdCAhPT0gbm9kZURhdGEuYXNzaWduZWRTbG90KSB7XG4gICAgICBpZiAobm9kZURhdGEuYXNzaWduZWRTbG90KSB7XG4gICAgICAgIGVuc3VyZVNoYWR5RGF0YUZvck5vZGUobm9kZURhdGEuYXNzaWduZWRTbG90KS5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgYXNzaWduZWROb2RlcyB0cmFja2luZyBkYXRhIGZvciBhIGdpdmVuIGBzbG90YC4gTm90ZSwgdGhlIGN1cnJlbnRcbiAgICogYXNzaWduZWQgbm9kZSBkYXRhIGlzIHRyYWNrZWQgKHZpYSBfcHJldmlvdXNseUFzc2lnbmVkTm9kZXMgYW5kXG4gICAqIF9wcmV2QXNzaWduZWRTbG90KSB0byBzZWUgaWYgYHNsb3RjaGFuZ2VgIHNob3VsZCBmaXJlLiBUaGlzIGRhdGEgbWF5IGJlIG91dFxuICAgKiAgb2YgZGF0ZSBhdCB0aGlzIHRpbWUgYmVjYXVzZSB0aGUgYXNzaWduZWQgbm9kZXMgbWF5IGhhdmUgYWxyZWFkeSBiZWVuXG4gICAqIGRpc3RyaWJ1dGVkIHRvIGFub3RoZXIgcm9vdC4gVGhpcyBpcyBvayBzaW5jZSB0aGlzIGRhdGEgaXMgb25seSB1c2VkIHRvXG4gICAqIHRyYWNrIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7SFRNTFNsb3RFbGVtZW50fSBzbG90XG4gICAqL1xuICBfY2xlYXJTbG90QXNzaWduZWROb2RlcyhzbG90KSB7XG4gICAgY29uc3Qgc2xvdERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHNsb3QpO1xuICAgIGxldCBuJCA9IHNsb3REYXRhLmFzc2lnbmVkTm9kZXM7XG4gICAgc2xvdERhdGEuYXNzaWduZWROb2RlcyA9IFtdO1xuICAgIHNsb3REYXRhLmZsYXR0ZW5lZE5vZGVzID0gW107XG4gICAgc2xvdERhdGEuX3ByZXZpb3VzbHlBc3NpZ25lZE5vZGVzID0gbiQ7XG4gICAgaWYgKG4kKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBuJC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbiA9IHNoYWR5RGF0YUZvck5vZGUobiRbaV0pO1xuICAgICAgICBuLl9wcmV2QXNzaWduZWRTbG90ID0gbi5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIC8vIG9ubHkgY2xlYXIgaWYgaXQgd2FzIHByZXZpb3VzbHkgc2V0IHRvIHRoaXMgc2xvdDtcbiAgICAgICAgLy8gdGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBpZiB0aGUgbm9kZSBoYXMgb3RoZXJ3aXNlIGJlZW4gZGlzdHJpYnV0ZWRcbiAgICAgICAgLy8gaWdub3JlIGl0LlxuICAgICAgICBpZiAobi5hc3NpZ25lZFNsb3QgPT09IHNsb3QpIHtcbiAgICAgICAgICBuLmFzc2lnbmVkU2xvdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWRkQXNzaWduZWRUb0ZsYXR0ZW5lZE5vZGVzKGZsYXR0ZW5lZCwgYXNzaWduZWQpIHtcbiAgICBmb3IgKGxldCBpPTAsIG47IChpPGFzc2lnbmVkLmxlbmd0aCkgJiYgKG49YXNzaWduZWRbaV0pOyBpKyspIHtcbiAgICAgIGlmIChuLmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgY29uc3QgbmVzdGVkQXNzaWduZWQgPSBzaGFkeURhdGFGb3JOb2RlKG4pLmFzc2lnbmVkTm9kZXM7XG4gICAgICAgIGlmIChuZXN0ZWRBc3NpZ25lZCAmJiBuZXN0ZWRBc3NpZ25lZC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9hZGRBc3NpZ25lZFRvRmxhdHRlbmVkTm9kZXMoZmxhdHRlbmVkLCBuZXN0ZWRBc3NpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW5lZC5wdXNoKGFzc2lnbmVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZmlyZVNsb3RDaGFuZ2Uoc2xvdCkge1xuICAgIC8vIE5PVEU6IGNhbm5vdCBidWJibGUgY29ycmVjdGx5IGhlcmUgc28gbm90IHNldHRpbmcgYnViYmxlczogdHJ1ZVxuICAgIC8vIFNhZmFyaSB0ZWNoIHByZXZpZXcgZG9lcyBub3QgYnViYmxlIGJ1dCBjaHJvbWUgZG9lc1xuICAgIC8vIFNwZWMgc2F5cyBpdCBidWJibGVzIChodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI211dGF0aW9uLW9ic2VydmVycylcbiAgICBzbG90W3V0aWxzLk5BVElWRV9QUkVGSVggKyAnZGlzcGF0Y2hFdmVudCddKG5ldyBFdmVudCgnc2xvdGNoYW5nZScpKTtcbiAgICBjb25zdCBzbG90RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUoc2xvdCk7XG4gICAgaWYgKHNsb3REYXRhLmFzc2lnbmVkU2xvdCkge1xuICAgICAgdGhpcy5fZmlyZVNsb3RDaGFuZ2Uoc2xvdERhdGEuYXNzaWduZWRTbG90KTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWlmeSBkb20gc3VjaCB0aGF0IGl0IGlzIGF0IGl0cyBjb3JyZWN0IHJlbmRlcmluZyBwb3NpdGlvblxuICAvLyBiYXNlZCBvbiBsb2dpY2FsIGRpc3RyaWJ1dGlvbi5cbiAgLy8gTk9URTogaGVyZSB3ZSBvbmx5IGNvbXBvc2UgcGFyZW50cyBvZiA8c2xvdD4gZWxlbWVudHMgYW5kIG5vdCB0aGVcbiAgLy8gc2hhZG93Um9vdCBpbnRvIHRoZSBob3N0LiBUaGUgbGF0dGVyIGlzIHBlcmZvcm1lbmQgdmlhIGEgZmFzdCBwYXRoXG4gIC8vIGluIHRoZSBgbG9naWNhbC1tdXRhdGlvbmAuaW5zZXJ0QmVmb3JlLlxuICBfY29tcG9zZSgpIHtcbiAgICBjb25zdCBzbG90cyA9IHRoaXMuX3Nsb3RMaXN0O1xuICAgIGxldCBjb21wb3NlTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzbG90c1tpXVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgICAgLyogY29tcG9zZSBub2RlIG9ubHkgaWY6XG4gICAgICAgICgxKSBwYXJlbnQgZG9lcyBub3QgaGF2ZSBhIHNoYWRvd1Jvb3Qgc2luY2Ugc2hhZG93Um9vdCBoYXMgYWxyZWFkeVxuICAgICAgICBjb21wb3NlZCBpbnRvIHRoZSBob3N0XG4gICAgICAgICgyKSB3ZSdyZSBub3QgYWxyZWFkeSBjb21wb3NpbmcgaXRcbiAgICAgICAgW2NvbnNpZGVyIChuXjIpIGJ1dCByYXJlIGJldHRlciB0aGFuIFNldF1cbiAgICAgICovXG4gICAgICBjb25zdCBwYXJlbnREYXRhID0gc2hhZHlEYXRhRm9yTm9kZShwYXJlbnQpO1xuICAgICAgaWYgKCEocGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLnJvb3QpICYmXG4gICAgICAgIGNvbXBvc2VMaXN0LmluZGV4T2YocGFyZW50KSA8IDApIHtcbiAgICAgICAgY29tcG9zZUxpc3QucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpPTA7IGkgPCBjb21wb3NlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IGNvbXBvc2VMaXN0W2ldO1xuICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IG5vZGUgPT09IHRoaXMgPyB0aGlzLmhvc3QgOiBub2RlO1xuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGROb2Rlcyh0YXJnZXROb2RlLCB0aGlzLl9jb21wb3NlTm9kZShub2RlKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgbGlzdCBvZiBub2RlcyB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQgaW5zaWRlIGBub2RlYC5cbiAgX2NvbXBvc2VOb2RlKG5vZGUpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGxldCBuPW5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgIC8vIE5vdGU6IGlmIHdlIHNlZSBhIHNsb3QgaGVyZSwgdGhlIG5vZGVzIGFyZSBndWFyYW50ZWVkIHRvIG5lZWQgdG8gYmVcbiAgICAgIC8vIGNvbXBvc2VkIGhlcmUuIFRoaXMgaXMgYmVjYXVzZSBpZiB0aGVyZSBpcyByZWRpc3RyaWJ1dGlvbiwgaXQgaGFzXG4gICAgICAvLyBhbHJlYWR5IGJlZW4gaGFuZGxlZCBieSB0aGlzIHBvaW50LlxuICAgICAgaWYgKHRoaXMuX2lzSW5zZXJ0aW9uUG9pbnQobikpIHtcbiAgICAgICAgbGV0IGZsYXR0ZW5lZE5vZGVzID0gc2hhZHlEYXRhRm9yTm9kZShuKS5mbGF0dGVuZWROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmbGF0dGVuZWROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBkaXN0cmlidXRlZE5vZGUgPSBmbGF0dGVuZWROb2Rlc1tqXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZGlzdHJpYnV0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgX2lzSW5zZXJ0aW9uUG9pbnQobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUubG9jYWxOYW1lID09ICdzbG90JztcbiAgICB9XG5cbiAgLy8gRW5zdXJlcyB0aGF0IHRoZSByZW5kZXJlZCBub2RlIGxpc3QgaW5zaWRlIGBjb250YWluZXJgIGlzIGBjaGlsZHJlbmAuXG4gIF91cGRhdGVDaGlsZE5vZGVzKGNvbnRhaW5lciwgY2hpbGRyZW4pIHtcbiAgICBsZXQgY29tcG9zZWQgPSB1dGlscy5uYXRpdmVDaGlsZE5vZGVzQXJyYXkoY29udGFpbmVyKTtcbiAgICBsZXQgc3BsaWNlcyA9IGNhbGN1bGF0ZVNwbGljZXMoY2hpbGRyZW4sIGNvbXBvc2VkKTtcbiAgICAvLyBwcm9jZXNzIHJlbW92YWxzXG4gICAgZm9yIChsZXQgaT0wLCBkPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqPTAsIG47IChqIDwgcy5yZW1vdmVkLmxlbmd0aCkgJiYgKG49cy5yZW1vdmVkW2pdKTsgaisrKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBub2RlIGlzIHN0aWxsIHdoZXJlIHdlIGV4cGVjdCBpdCBpcyBiZWZvcmUgdHJ5aW5nXG4gICAgICAgIC8vIHRvIHJlbW92ZSBpdDsgdGhpcyBjYW4gaGFwcGVuIGlmIHdlIG1vdmUgYSBub2RlIGFuZFxuICAgICAgICAvLyB0aGVuIHNjaGVkdWxlIGl0cyBwcmV2aW91cyBob3N0IGZvciBkaXN0cmlidXRpb24gcmVzdWx0aW5nIGluXG4gICAgICAgIC8vIHRoZSBub2RlIGJlaW5nIHJlbW92ZWQgaGVyZS5cbiAgICAgICAgaWYgKG5bdXRpbHMuTkFUSVZFX1BSRUZJWCArICdwYXJlbnROb2RlJ10gPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lclt1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogYXZvaWQgdGhlIG5lZWQgZm9yIHNwbGljaW5nIGhlcmUuXG4gICAgICAgIGNvbXBvc2VkLnNwbGljZShzLmluZGV4ICsgZCwgMSk7XG4gICAgICB9XG4gICAgICBkIC09IHMuYWRkZWRDb3VudDtcbiAgICB9XG4gICAgLy8gcHJvY2VzcyBhZGRzXG4gICAgZm9yIChsZXQgaT0wLCBzLCBuZXh0OyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykgeyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG4gICAgICBuZXh0ID0gY29tcG9zZWRbcy5pbmRleF07XG4gICAgICBmb3IgKGxldCBqPXMuaW5kZXgsIG47IGogPCBzLmluZGV4ICsgcy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgbiA9IGNoaWxkcmVuW2pdO1xuICAgICAgICBjb250YWluZXJbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdpbnNlcnRCZWZvcmUnXShuLCBuZXh0KTtcbiAgICAgICAgY29tcG9zZWQuc3BsaWNlKGosIDAsIG4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVTbG90RGF0YSgpIHtcbiAgICB0aGlzLl9wZW5kaW5nU2xvdHMgPSB0aGlzLl9wZW5kaW5nU2xvdHMgfHwgW107XG4gICAgdGhpcy5fc2xvdExpc3QgPSB0aGlzLl9zbG90TGlzdCB8fCBbXTtcbiAgICB0aGlzLl9zbG90TWFwID0gdGhpcy5fc2xvdE1hcCB8fCB7fTtcbiAgfVxuXG4gIF9hZGRTbG90cyhzbG90cykge1xuICAgIHRoaXMuX2Vuc3VyZVNsb3REYXRhKCk7XG4gICAgdGhpcy5fcGVuZGluZ1Nsb3RzLnB1c2goLi4uc2xvdHMpO1xuICB9XG5cbiAgX3ZhbGlkYXRlU2xvdHMoKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdTbG90cyAmJiB0aGlzLl9wZW5kaW5nU2xvdHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tYXBTbG90cyh0aGlzLl9wZW5kaW5nU2xvdHMpO1xuICAgICAgdGhpcy5fcGVuZGluZ1Nsb3RzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIHNsb3RzLiBTbG90cyBhcmUgbWFpbnRhaW5lZCBpbiBhbiBkb20tb3JkZXJlZCBsaXN0LlxuICAgKiBJbiBhZGRpdGlvbiBhIG1hcCBvZiBuYW1lIHRvIHNsb3QgaXMgdXBkYXRlZC5cbiAgICovXG4gIF9tYXBTbG90cyhzbG90cykge1xuICAgIGxldCBzbG90TmFtZXNUb1NvcnQ7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNsb3QgPSBzbG90c1tpXTtcbiAgICAgIC8vIGVuc3VyZSBpbnNlcnRpb25Qb2ludHMncyBhbmQgdGhlaXIgcGFyZW50cyBoYXZlIGxvZ2ljYWwgZG9tIGluZm8uXG4gICAgICAvLyBzYXZlIGxvZ2ljYWwgdHJlZSBpbmZvXG4gICAgICAvLyBhLiBmb3Igc2hhZHlSb290XG4gICAgICAvLyBiLiBmb3IgaW5zZXJ0aW9uIHBvaW50cyAoZmFsbGJhY2spXG4gICAgICAvLyBjLiBmb3IgcGFyZW50cyBvZiBpbnNlcnRpb24gcG9pbnRzXG4gICAgICByZWNvcmRDaGlsZE5vZGVzKHNsb3QpO1xuICAgICAgY29uc3Qgc2xvdFBhcmVudCA9IHNsb3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgICAgIHJlY29yZENoaWxkTm9kZXMoc2xvdFBhcmVudCk7XG4gICAgICBjb25zdCBzbG90UGFyZW50RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUoc2xvdFBhcmVudCk7XG4gICAgICBzbG90UGFyZW50RGF0YS5fX2NoaWxkU2xvdENvdW50ID0gKHNsb3RQYXJlbnREYXRhLl9fY2hpbGRTbG90Q291bnQgfHwgMCkgKyAxO1xuICAgICAgbGV0IG5hbWUgPSB0aGlzLl9uYW1lRm9yU2xvdChzbG90KTtcbiAgICAgIGlmICh0aGlzLl9zbG90TWFwW25hbWVdKSB7XG4gICAgICAgIHNsb3ROYW1lc1RvU29ydCA9IHNsb3ROYW1lc1RvU29ydCB8fCB7fTtcbiAgICAgICAgc2xvdE5hbWVzVG9Tb3J0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2xvdE1hcFtuYW1lXS5wdXNoKHNsb3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2xvdE1hcFtuYW1lXSA9IFtzbG90XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nsb3RMaXN0LnB1c2goc2xvdCk7XG4gICAgfVxuICAgIGlmIChzbG90TmFtZXNUb1NvcnQpIHtcbiAgICAgIGZvciAobGV0IG4gaW4gc2xvdE5hbWVzVG9Tb3J0KSB7XG4gICAgICAgIHRoaXMuX3Nsb3RNYXBbbl0gPSB0aGlzLl9zb3J0U2xvdHModGhpcy5fc2xvdE1hcFtuXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX25hbWVGb3JTbG90KHNsb3QpIHtcbiAgICBjb25zdCBuYW1lID0gc2xvdFsnbmFtZSddIHx8IHNsb3QuZ2V0QXR0cmlidXRlKCduYW1lJykgfHwgQ0FUQ0hBTExfTkFNRTtcbiAgICBzbG90Ll9fc2xvdE5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNsb3RzIGFyZSBrZXB0IGluIGFuIG9yZGVyZWQgbGlzdC4gU2xvdHMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAqIGFyZSBzb3J0ZWQgaGVyZSBieSB0cmVlIG9yZGVyLlxuICAgKi9cbiAgX3NvcnRTbG90cyhzbG90cykge1xuICAgIC8vIE5PVEU6IENhbm5vdCB1c2UgYGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uYCBiZWNhdXNlIGl0J3Mgbm90IHBvbHlmaWxsZWQsXG4gICAgLy8gYnV0IHRoZSBjb2RlIGhlcmUgY291bGQgYmUgdXNlZCB0byBwb2x5ZmlsbCB0aGUgcHJlY2VlZGluZy9mb2xsb3dpbmcgaW5mb1xuICAgIC8vIGluIGBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbmAuXG4gICAgcmV0dXJuIHNsb3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGxldCBsaXN0QSA9IGFuY2VzdG9yTGlzdChhKTtcbiAgICAgIGxldCBsaXN0QiA9IGFuY2VzdG9yTGlzdChiKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaSA8IGxpc3RBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuQSA9IGxpc3RBW2ldO1xuICAgICAgICBsZXQgbkIgPSBsaXN0QltpXTtcbiAgICAgICAgaWYgKG5BICE9PSBuQikge1xuICAgICAgICAgIGxldCBjJCA9IHV0aWxzLmNoaWxkTm9kZXNBcnJheShuQVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddKTtcbiAgICAgICAgICByZXR1cm4gYyQuaW5kZXhPZihuQSkgLSBjJC5pbmRleE9mKG5CKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZnJvbSB0cmFja2VkIHNsb3QgZGF0YSBhbnkgc2xvdHMgY29udGFpbmVkIHdpdGhpbiBgY29udGFpbmVyYCBhbmRcbiAgICogdGhlbiB1cGRhdGVzIHRoZSB0cmFja2VkIGRhdGEgKF9zbG90TGlzdCBhbmQgX3Nsb3RNYXApLlxuICAgKiBBbnkgcmVtb3ZlZCBzbG90cyBhbHNvIGhhdmUgdGhlaXIgYGFzc2lnbmVkTm9kZXNgIHJlbW92ZWQgZnJvbSBjb21vcHNlZCBkb20uXG4gICAqL1xuICBfcmVtb3ZlQ29udGFpbmVkU2xvdHMoY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9zbG90TGlzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl92YWxpZGF0ZVNsb3RzKCk7XG4gICAgbGV0IGRpZFJlbW92ZTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9zbG90TWFwO1xuICAgIGZvciAobGV0IG4gaW4gbWFwKSB7XG4gICAgICBjb25zdCBzbG90cyA9IG1hcFtuXTtcbiAgICAgIGZvciAobGV0IGk9MDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNsb3QgPSBzbG90c1tpXTtcbiAgICAgICAgaWYgKHV0aWxzLmNvbnRhaW5zKGNvbnRhaW5lciwgc2xvdCkpIHtcbiAgICAgICAgICBzbG90cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgY29uc3QgeCA9IHRoaXMuX3Nsb3RMaXN0LmluZGV4T2Yoc2xvdCk7XG4gICAgICAgICAgaWYgKHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2xvdExpc3Quc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgY29uc3Qgc2xvdFBhcmVudERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHNsb3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXSk7XG4gICAgICAgICAgICBpZiAoc2xvdFBhcmVudERhdGEgJiYgc2xvdFBhcmVudERhdGEuX19jaGlsZFNsb3RDb3VudCkge1xuICAgICAgICAgICAgICBzbG90UGFyZW50RGF0YS5fX2NoaWxkU2xvdENvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGktLTtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVGbGF0dGVuZWROb2RlcyhzbG90KTtcbiAgICAgICAgICBkaWRSZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWRSZW1vdmU7XG4gIH1cblxuICBfdXBkYXRlU2xvdE5hbWUoc2xvdCkge1xuICAgIGlmICghdGhpcy5fc2xvdExpc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHNsb3RNYXAgaXMgaW5pdGlhbGl6ZWQgd2l0aCB0aGlzIHNsb3RcbiAgICB0aGlzLl92YWxpZGF0ZVNsb3RzKCk7XG4gICAgY29uc3Qgb2xkTmFtZSA9IHNsb3QuX19zbG90TmFtZTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fbmFtZUZvclNsb3Qoc2xvdCk7XG4gICAgaWYgKG5hbWUgPT09IG9sZE5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGZyb20gZXhpc3RpbmcgdHJhY2tpbmdcbiAgICBsZXQgc2xvdHMgPSB0aGlzLl9zbG90TWFwW29sZE5hbWVdO1xuICAgIGNvbnN0IGkgPSBzbG90cy5pbmRleE9mKHNsb3QpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHNsb3RzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgLy8gYWRkIHRvIG5ldyBsb2NhdGlvbiBhbmQgc29ydCBpZiBuZWRlc3NhcnlcbiAgICBsZXQgbGlzdCA9IHRoaXMuX3Nsb3RNYXBbbmFtZV0gfHwgKHRoaXMuX3Nsb3RNYXBbbmFtZV0gPSBbXSk7XG4gICAgbGlzdC5wdXNoKHNsb3QpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX3Nsb3RNYXBbbmFtZV0gPSB0aGlzLl9zb3J0U2xvdHMobGlzdCk7XG4gICAgfVxuICB9XG5cbiAgX3JlbW92ZUZsYXR0ZW5lZE5vZGVzKHNsb3QpIHtcbiAgICBjb25zdCBkYXRhID0gc2hhZHlEYXRhRm9yTm9kZShzbG90KTtcbiAgICBsZXQgbiQgPSBkYXRhLmZsYXR0ZW5lZE5vZGVzO1xuICAgIGlmIChuJCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpPG4kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbiRbaV07XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2RlW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50W3V0aWxzLk5BVElWRV9QUkVGSVggKyAncmVtb3ZlQ2hpbGQnXShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkYXRhLmZsYXR0ZW5lZE5vZGVzID0gW107XG4gICAgZGF0YS5hc3NpZ25lZE5vZGVzID0gW107XG4gIH1cblxuICBfaGFzSW5zZXJ0aW9uUG9pbnQoKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVTbG90cygpO1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX3Nsb3RMaXN0ICYmIHRoaXMuX3Nsb3RMaXN0Lmxlbmd0aCk7XG4gIH1cbn1cblxucGF0Y2hTaGFkeVJvb3QoU2hhZHlSb290LnByb3RvdHlwZSk7XG5leHBvcnQge1NoYWR5Um9vdH07XG5cbi8qKlxuICBJbXBsZW1lbnRzIGEgcGFyZWQgZG93biB2ZXJzaW9uIG9mIFNoYWRvd0RPTSdzIHNjb3BpbmcsIHdoaWNoIGlzIGVhc3kgdG9cbiAgcG9seWZpbGwgYWNyb3NzIGJyb3dzZXJzLlxuKi9cbmV4cG9ydCBjb25zdCBhdHRhY2hTaGFkb3cgPSAoaG9zdCwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWhvc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhvc3QuJyk7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cy4nKTtcbiAgfVxuICBsZXQgcm9vdDtcbiAgLy8gT3B0aW1pemF0aW9uIGZvciBib290aW5nIHVwIGEgc2hhZG93Um9vdCBmcm9tIGEgZnJhZ21lbnQgcmF0aGVyIHRoYW5cbiAgLy8gY3JlYXRpbmcgb25lLlxuICBpZiAob3B0aW9uc1snc2hhZHlVcGdyYWRlRnJhZ21lbnQnXSAmJiB1dGlscy5jYW5VcGdyYWRlKCkpIHtcbiAgICByb290ID0gb3B0aW9uc1snc2hhZHlVcGdyYWRlRnJhZ21lbnQnXTtcbiAgICByb290Ll9fcHJvdG9fXyA9IFNoYWRvd1Jvb3QucHJvdG90eXBlO1xuICAgIHJvb3QuX2luaXQoaG9zdCwgb3B0aW9ucyk7XG4gICAgcmVjb3JkQ2hpbGROb2Rlcyhyb290LCByb290KTtcbiAgICAvLyBOb3RlOiBxc2EgaXMgbmF0aXZlIHdoZW4gdXNlZCB3aXRoIG5vUGF0Y2guXG4gICAgLyoqIEB0eXBlIHs/Tm9kZUxpc3Q8RWxlbWVudD59ICovXG4gICAgY29uc3Qgc2xvdHNBZGRlZCA9IHJvb3RbJ19fbm9JbnNlcnRpb25Qb2ludCddID8gbnVsbCA6IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgIC8vIFJlc2V0IHNjb3BpbmcgaW5mb3JtYXRpb24gc28gbm9ybWFsIHNjb2luZyBydWxlcyBhcHBseSBhZnRlciB0aGlzLlxuICAgIHJvb3RbJ19fbm9JbnNlcnRpb25Qb2ludCddID0gdW5kZWZpbmVkO1xuICAgIC8vIGlmIGEgc2xvdCBpcyBhZGRlZCwgbXVzdCByZW5kZXIgY29udGFpbmluZyByb290LlxuICAgIGlmIChzbG90c0FkZGVkICYmIHNsb3RzQWRkZWQubGVuZ3RoKSB7XG4gICAgICByb290Ll9hZGRTbG90cyhzbG90c0FkZGVkKTtcbiAgICAgIHJvb3QuX2FzeW5jUmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8ocm9vdCkuaG9zdFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2FwcGVuZENoaWxkJ10ocm9vdCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdCA9IG5ldyBTaGFkeVJvb3QoU2hhZHlSb290Q29uc3RydWN0aW9uVG9rZW4sIGhvc3QsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiByb290O1xufVxuXG4vLyBNaXRpZ2F0ZSBjb25uZWN0L2Rpc2Nvbm5lY3Qgc3BhbSBieSB3cmFwcGluZyBjdXN0b20gZWxlbWVudCBjbGFzc2VzLlxuaWYgKHdpbmRvd1snY3VzdG9tRWxlbWVudHMnXSAmJiB1dGlscy5zZXR0aW5ncy5pblVzZSAmJiAhdXRpbHMuc2V0dGluZ3NbJ3ByZWZlclBlcmZvcm1hbmNlJ10pIHtcblxuICAvLyBwcm9jZXNzIGNvbm5lY3QvZGlzY29ubmVjdCBhZnRlciByb290cyBoYXZlIHJlbmRlcmVkIHRvIGF2b2lkXG4gIC8vIGlzc3VlcyB3aXRoIHJlYWN0aW9uIHN0YWNrLlxuICBsZXQgY29ubmVjdE1hcCA9IG5ldyBNYXAoKTtcbiAgcm9vdFJlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gYWxsb3cgZWxlbWVudHMgdG8gY29ubmVjdFxuICAgIC8vIHNhdmUgbWFwIHN0YXRlICh3aXRob3V0IG5lZWRpbmcgcG9seWZpbGxzIG9uIElFMTEpXG4gICAgY29uc3QgciA9IFtdO1xuICAgIGNvbm5lY3RNYXAuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgICAgci5wdXNoKFtrLCB2XSk7XG4gICAgfSk7XG4gICAgY29ubmVjdE1hcC5jbGVhcigpO1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGUgPSByW2ldWzBdLCB2YWx1ZSA9IHJbaV1bMV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZVsnX19zaGFkeWRvbV9jb25uZWN0ZWRDYWxsYmFjayddKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlWydfX3NoYWR5ZG9tX2Rpc2Nvbm5lY3RlZENhbGxiYWNrJ10oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlIGFuZCBmbGFnIGlzIHNldCAoZGVmZXJDb25uZWN0aW9uQ2FsbGJhY2tzKVxuICAvLyBzbyBwcm9jZXNzIGNvbm5lY3Rpb24gc3RhY2sgd2hlbiBgcmVhZHlzdGF0ZWNoYW5nZWAgZmlyZXMuXG4gIGlmIChpc1JlbmRlcmluZykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgcm9vdFJlbmRlcmVkKCk7XG4gICAgfSwge29uY2U6IHRydWV9KTtcbiAgfVxuXG4gIC8qXG4gICAqICgxKSBlbGVtZW50cyBjYW4gb25seSBiZSBjb25uZWN0ZWQvZGlzY29ubmVjdGVkIGlmIHRoZXkgYXJlIGluIHRoZSBleHBlY3RlZFxuICAgKiBzdGF0ZS5cbiAgICogKDIpIG5ldmVyIHJ1biBjb25uZWN0L2Rpc2Nvbm5lY3QgZHVyaW5nIHJlbmRlcmluZyB0byBhdm9pZCByZWFjdGlvbiBzdGFjayBpc3N1ZXMuXG4gICAqL1xuICBjb25zdCBNYW5hZ2VDb25uZWN0ID0gKGJhc2UsIGNvbm5lY3RlZCwgZGlzY29ubmVjdGVkKSA9PiB7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGNvbnN0IGNvbm5lY3RGbGFnID0gYF9faXNDb25uZWN0ZWQke2NvdW50ZXIrK31gO1xuICAgIGlmIChjb25uZWN0ZWQgfHwgZGlzY29ubmVjdGVkKSB7XG5cbiAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgYmFzZS5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2sgPSBiYXNlLnByb3RvdHlwZVsnX19zaGFkeWRvbV9jb25uZWN0ZWRDYWxsYmFjayddID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGlmIHJlbmRlcmluZyBkZWZlciBjb25uZWN0ZWRcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbm5lY3Qgb25seSBpZiB3ZSBoYXZlbid0IGFscmVhZHlcbiAgICAgICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgY29ubmVjdE1hcC5zZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXNbY29ubmVjdEZsYWddKSB7XG4gICAgICAgICAgdGhpc1tjb25uZWN0RmxhZ10gPSB0cnVlO1xuICAgICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgIGJhc2UucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrID0gYmFzZS5wcm90b3R5cGVbJ19fc2hhZHlkb21fZGlzY29ubmVjdGVkQ2FsbGJhY2snXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpZiByZW5kZXJpbmcsIGNhbmNlbCBhIHBlbmRpbmcgY29ubmVjdGlvbiBhbmQgcXVldWUgZGlzY29ubmVjdCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGRpc2Nvbm5lY3Qgb25seSBpZiBhIGNvbm5lY3Rpb24gaGFzIGJlZW4gYWxsb3dlZFxuICAgICAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBvbmx5IGJlY2F1c2UgY2FsbGluZyByZW1vdmVDaGlsZFxuICAgICAgICAgIC8vIG9uIGEgbm9kZSB0aGF0IHJlcXVpcmVzIGRpc3RyaWJ1dGlvbiBsZWF2ZXMgaXQgaW4gdGhlIERPTSB0cmVlXG4gICAgICAgICAgLy8gdW50aWwgZGlzdHJpYnV0aW9uLlxuICAgICAgICAgIC8vIE5PVEU6IHJlbWVtYmVyIHRoaXMgaXMgY2hlY2tpbmcgdGhlIHBhdGNoZWQgaXNDb25uZWN0ZWQgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgaW4gdGhlIGxvZ2ljYWwgdHJlZS5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3RNYXAuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1tjb25uZWN0RmxhZ10pIHtcbiAgICAgICAgICB0aGlzW2Nvbm5lY3RGbGFnXSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChkaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luYWxEZWZpbmUgPSB3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ11bJ2RlZmluZSddO1xuICBjb25zdCBkZWZpbmUgPSBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGNvbm5lY3RlZCA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaztcbiAgICBjb25zdCBkaXNjb25uZWN0ZWQgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGlzY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgb3JpZ2luYWxEZWZpbmUuY2FsbCh3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ10sIG5hbWUsXG4gICAgICAgIE1hbmFnZUNvbm5lY3QoY29uc3RydWN0b3IsIGNvbm5lY3RlZCwgZGlzY29ubmVjdGVkKSk7XG4gICAgLy8gdW5wYXRjaCBjb25uZWN0ZWQvZGlzY29ubmVjdGVkIG9uIGNsYXNzOyBjdXN0b20gZWxlbWVudHMgdGVhcnMgdGhpcyBvZmZcbiAgICAvLyBzbyB0aGUgcGF0Y2ggaXMgbWFpbnRhaW5lZCwgYnV0IGlmIHRoZSB1c2VyIGNhbGxzIHRoZXNlIG1ldGhvZHMgZm9yXG4gICAgLy8gZS5nLiB0ZXN0aW5nLCB0aGV5IHdpbGwgYmUgYXMgZXhwZWN0ZWQuXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrID0gY29ubmVjdGVkO1xuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjayA9IGRpc2Nvbm5lY3RlZDtcbiAgfVxuICAvLyBOb3RlLCBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gb25seSBwYXRjaCB0aGUgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZSxcbiAgLy8gYnV0IFNoYWR5Q1NTIHBhdGNoZXMgZGVmaW5lIGRpcmVjdGx5LlxuICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lID0gZGVmaW5lO1xuICAvLyBTdGlsbCBwYXRjaCB0aGUgcmVnaXN0cnkgZGlyZWN0bHkgc2luY2UgU2FmYXJpIDEwIGxvc2VzIHRoZSBwYXRjaFxuICAvLyB1bmxlc3MgdGhpcyBpcyBkb25lLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93WydDdXN0b21FbGVtZW50UmVnaXN0cnknXS5wcm90b3R5cGUsICdkZWZpbmUnLCB7XG4gICAgdmFsdWU6IGRlZmluZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKiBAcmV0dXJuIHshU2hhZHlSb290fHVuZGVmaW5lZH0gKi9cbmV4cG9ydCBjb25zdCBvd25lclNoYWR5Um9vdEZvck5vZGUgPSAobm9kZSkgPT4ge1xuICBsZXQgcm9vdCA9IG5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2dldFJvb3ROb2RlJ10oKTtcbiAgaWYgKHV0aWxzLmlzU2hhZHlSb290KHJvb3QpKSB7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtldmVudFByb3BlcnR5TmFtZXN9IGZyb20gJy4vcGF0Y2gtZXZlbnRzLmpzJztcblxuLyoqIEBpbXBsZW1lbnRzIHtJV3JhcHBlcn0gKi9cbmNsYXNzIFdyYXBwZXIge1xuXG4gIC8qKiBAcGFyYW0geyFOb2RlfSBub2RlICovXG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9XG5cbiAgLy8gbm9kZVxuICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnYWRkRXZlbnRMaXN0ZW5lciddKG5hbWUsIGZuLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVFdmVudExpc3RlbmVyJ10obmFtZSwgZm4sIG9wdGlvbnMpO1xuICB9XG5cbiAgYXBwZW5kQ2hpbGQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2FwcGVuZENoaWxkJ10obm9kZSk7XG4gIH1cblxuICBpbnNlcnRCZWZvcmUobm9kZSwgcmVmX25vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbnNlcnRCZWZvcmUnXShub2RlLCByZWZfbm9kZSk7XG4gIH1cblxuICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlQ2hpbGQnXShub2RlKTtcbiAgfVxuXG4gIHJlcGxhY2VDaGlsZChub2RlLCByZWZfbm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3JlcGxhY2VDaGlsZCddKG5vZGUsIHJlZl9ub2RlKTtcbiAgfVxuXG4gIGNsb25lTm9kZShkZWVwKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnY2xvbmVOb2RlJ10oZGVlcCk7XG4gIH1cblxuICBnZXRSb290Tm9kZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXShvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnRhaW5zKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdjb250YWlucyddKG5vZGUpO1xuICB9XG5cbiAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Rpc3BhdGNoRXZlbnQnXShldmVudCk7XG4gIH1cblxuICAvLyBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnc2V0QXR0cmlidXRlJ10obmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLy8gTk9URTogbm90IG5lZWRlZCwganVzdCBoZXJlIGZvciBiYWxhbmNlXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2dldEF0dHJpYnV0ZSddKG5hbWUpO1xuICB9XG5cbiAgLy8gTk9URTogbm90IG5lZWRlZCwganVzdCBoZXJlIGZvciBiYWxhbmNlXG4gIGhhc0F0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2hhc0F0dHJpYnV0ZSddKG5hbWUpO1xuICB9XG5cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3JlbW92ZUF0dHJpYnV0ZSddKG5hbWUpO1xuICB9XG5cbiAgYXR0YWNoU2hhZG93KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdhdHRhY2hTaGFkb3cnXShvcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTm9kZXx1bmRlZmluZWR9ICovXG4gIGdldCBhY3RpdmVFbGVtZW50KCkge1xuICAgIGlmICh1dGlscy5pc1NoYWR5Um9vdCh0aGlzLm5vZGUpIHx8IHRoaXMubm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdhY3RpdmVFbGVtZW50J107XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFsbGVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggYnJvd3NlcnMgKG9sZGVyIENocm9tZS9TYWZhcmkpIHRoYXQgZG9cbiAgICogbm90IGhhdmUgYSBjb25maWd1cmFibGUgYGFjdGl2ZUVsZW1lbnRgIGFjY2Vzc29yLiBFbmFibGVzIG5vUGF0Y2ggYW5kXG4gICAqIHBhdGNoIG1vZGUgYm90aCB0byBjb25zaXN0ZW50bHkgdXNlIFNoYWR5RE9NLndyYXAoZG9jdW1lbnQpLl9hY3RpdmVFbGVtZW50LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybiB7IU5vZGV8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IF9hY3RpdmVFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBOT1RFOiBub3QgbmVlZGVkLCBqdXN0IGhlcmUgZm9yIGJhbGFuY2VcbiAgLyoqIEBvdmVycmlkZSAqL1xuICBmb2N1cygpIHtcbiAgICB0aGlzLm5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmb2N1cyddKCk7XG4gIH1cblxuICBibHVyKCkge1xuICAgIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnYmx1ciddKCk7XG4gIH1cblxuICAvLyBkb2N1bWVudFxuICBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcbiAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ltcG9ydE5vZGUnXShub2RlLCBkZWVwKTtcbiAgICB9XG4gIH1cblxuICBnZXRFbGVtZW50QnlJZChpZCkge1xuICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0RWxlbWVudEJ5SWQnXShpZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gcXVlcnlcbiAgcXVlcnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3F1ZXJ5U2VsZWN0b3InXShzZWxlY3Rvcik7XG4gIH1cblxuICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCB1c2VOYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdxdWVyeVNlbGVjdG9yQWxsJ10oc2VsZWN0b3IsIHVzZU5hdGl2ZSk7XG4gIH1cblxuICAvLyBzbG90XG4gIGFzc2lnbmVkTm9kZXMob3B0aW9ucykge1xuICAgIGlmICh0aGlzLm5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Fzc2lnbmVkTm9kZXMnXShvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaG9zdCgpIHtcbiAgICBpZiAodXRpbHMuaXNTaGFkeVJvb3QodGhpcy5ub2RlKSkge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovKHRoaXMubm9kZSkuaG9zdDtcbiAgICB9XG4gIH1cblxuICBnZXQgcGFyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gIH1cblxuICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107XG4gIH1cblxuICBnZXQgbGFzdENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2xhc3RDaGlsZCddO1xuICB9XG5cbiAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ107XG4gIH1cblxuICBnZXQgcHJldmlvdXNTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3ByZXZpb3VzU2libGluZyddO1xuICB9XG5cbiAgZ2V0IGNoaWxkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnY2hpbGROb2RlcyddO1xuICB9XG5cbiAgZ2V0IHBhcmVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50RWxlbWVudCddO1xuICB9XG5cbiAgZ2V0IGZpcnN0RWxlbWVudENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0RWxlbWVudENoaWxkJ107XG4gIH1cblxuICBnZXQgbGFzdEVsZW1lbnRDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdsYXN0RWxlbWVudENoaWxkJ107XG4gIH1cblxuICBnZXQgbmV4dEVsZW1lbnRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRFbGVtZW50U2libGluZyddO1xuICB9XG5cbiAgZ2V0IHByZXZpb3VzRWxlbWVudFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncHJldmlvdXNFbGVtZW50U2libGluZyddO1xuICB9XG5cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NoaWxkcmVuJ107XG4gIH1cblxuICBnZXQgY2hpbGRFbGVtZW50Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnY2hpbGRFbGVtZW50Q291bnQnXTtcbiAgfVxuXG4gIGdldCBzaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3NoYWRvd1Jvb3QnXTtcbiAgfVxuXG4gIGdldCBhc3NpZ25lZFNsb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnYXNzaWduZWRTbG90J107XG4gIH1cblxuICBnZXQgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnaXNDb25uZWN0ZWQnXTtcbiAgfVxuXG4gIGdldCBpbm5lckhUTUwoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnaW5uZXJIVE1MJ107XG4gIH1cblxuICBzZXQgaW5uZXJIVE1MKHZhbHVlKSB7XG4gICAgdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbm5lckhUTUwnXSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3RleHRDb250ZW50J107XG4gIH1cblxuICBzZXQgdGV4dENvbnRlbnQodmFsdWUpIHtcbiAgICB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3RleHRDb250ZW50J10gPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBzbG90KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3Nsb3QnXTtcbiAgfVxuXG4gIHNldCBzbG90KHZhbHVlKSB7XG4gICAgdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdzbG90J10gPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBjbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnY2xhc3NOYW1lJ107XG4gIH1cblxuICBzZXQgY2xhc3NOYW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnY2xhc3NOYW1lJ10gPSB2YWx1ZTtcbiAgfVxuXG59XG5cbmV2ZW50UHJvcGVydHlOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlci5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAvKiogQHRoaXMge1dyYXBwZXJ9ICovXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyBuYW1lXTtcbiAgICB9LFxuICAgIC8qKiBAdGhpcyB7V3JhcHBlcn0gKi9cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyBuYW1lXSA9IHZhbHVlO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG59KTtcblxuZXhwb3J0IHtXcmFwcGVyfTtcblxuY29uc3Qgd3JhcHBlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKG9iaikge1xuICBpZiAodXRpbHMuaXNTaGFkeVJvb3Qob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBsZXQgd3JhcHBlciA9IHdyYXBwZXJNYXAuZ2V0KG9iailcbiAgaWYgKCF3cmFwcGVyKSB7XG4gICAgd3JhcHBlciA9IG5ldyBXcmFwcGVyKG9iaik7XG4gICAgd3JhcHBlck1hcC5zZXQob2JqLCB3cmFwcGVyKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7Zmx1c2h9IGZyb20gJy4uL2ZsdXNoLmpzJztcbmltcG9ydCB7YWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lcn0gZnJvbSAnLi4vcGF0Y2gtZXZlbnRzLmpzJztcblxuZXhwb3J0IGNvbnN0IEV2ZW50VGFyZ2V0UGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIGZsdXNoKCk7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdkaXNwYXRjaEV2ZW50J10oZXZlbnQpO1xuICB9LFxuXG4gIGFkZEV2ZW50TGlzdGVuZXIsXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuXG59KTsiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQge3NoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4uL3NoYWR5LWRhdGEuanMnO1xuXG5leHBvcnQgY29uc3QgU2xvdGFibGVQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgYXNzaWduZWRTbG90KCkge1xuICAgIC8vIEZvcmNlIGFueSBwYXJlbnQncyBzaGFkb3dSb290IHRvIGZsdXNoIHNvIHRoYXQgZGlzdHJpYnV0aW9uIG9jY3Vyc1xuICAgIC8vIGFuZCB0aGlzIG5vZGUgaGFzIGFuIGFzc2lnbmVkU2xvdC5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgY29uc3Qgb3duZXJSb290ID0gcGFyZW50ICYmIHBhcmVudFt1dGlscy5TSEFEWV9QUkVGSVggKyAnc2hhZG93Um9vdCddO1xuICAgIGlmIChvd25lclJvb3QpIHtcbiAgICAgIG93bmVyUm9vdC5fcmVuZGVyKCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICByZXR1cm4gbm9kZURhdGEgJiYgbm9kZURhdGEuYXNzaWduZWRTbG90IHx8IG51bGw7XG4gIH1cblxufSk7XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQge3Njb3BlQ2xhc3NBdHRyaWJ1dGV9IGZyb20gJy4uL3N0eWxlLXNjb3BpbmcuanMnO1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuLi9zaGFkeS1kYXRhLmpzJztcbmltcG9ydCB7YXR0YWNoU2hhZG93LCBvd25lclNoYWR5Um9vdEZvck5vZGV9IGZyb20gJy4uL2F0dGFjaC1zaGFkb3cuanMnO1xuXG5jb25zdCBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciBhbiBhdHRyaWJ1dGUgY2hhbmdlcy4gSWYgdGhlIGBzbG90YCBhdHRyaWJ1dGVcbiAqIGNoYW5nZXMsIHByb3Zva2VzIHJlbmRlcmluZyBpZiBuZWNlc3NhcnkuIElmIGEgYDxzbG90PmAgZWxlbWVudCdzIGBuYW1lYFxuICogYXR0cmlidXRlIGNoYW5nZXMsIHVwZGF0ZXMgdGhlIHJvb3QncyBzbG90IG1hcCBhbmQgcmVuZGVycy5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGlzdHJpYnV0ZUF0dHJpYnV0ZUNoYW5nZShub2RlLCBuYW1lKSB7XG4gIGlmIChuYW1lID09PSAnc2xvdCcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgaWYgKHV0aWxzLmhhc1NoYWRvd1Jvb3RXaXRoU2xvdChwYXJlbnQpKSB7XG4gICAgICBzaGFkeURhdGFGb3JOb2RlKHBhcmVudCkucm9vdC5fYXN5bmNSZW5kZXIoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5sb2NhbE5hbWUgPT09ICdzbG90JyAmJiBuYW1lID09PSAnbmFtZScpIHtcbiAgICBsZXQgcm9vdCA9IG93bmVyU2hhZHlSb290Rm9yTm9kZShub2RlKTtcbiAgICBpZiAocm9vdCkge1xuICAgICAgcm9vdC5fdXBkYXRlU2xvdE5hbWUobm9kZSk7XG4gICAgICByb290Ll9hc3luY1JlbmRlcigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRWxlbWVudFBhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBwcmV2aW91c0VsZW1lbnRTaWJsaW5nKCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBpZiAobm9kZURhdGEgJiYgbm9kZURhdGEucHJldmlvdXNTaWJsaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBuID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncHJldmlvdXNTaWJsaW5nJ107XG4gICAgICB3aGlsZSAobiAmJiBuLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAncHJldmlvdXNTaWJsaW5nJ107XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJ107XG4gICAgfVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgZ2V0IG5leHRFbGVtZW50U2libGluZygpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgaWYgKG5vZGVEYXRhICYmIG5vZGVEYXRhLm5leHRTaWJsaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBuID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXTtcbiAgICAgIHdoaWxlIChuICYmIG4ubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnbmV4dEVsZW1lbnRTaWJsaW5nJ107XG4gICAgfVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgZ2V0IHNsb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzbG90Jyk7XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBzZXQgc2xvdCh2YWx1ZSkge1xuICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3NldEF0dHJpYnV0ZSddKCdzbG90JywgdmFsdWUpO1xuICB9LFxuXG4gIC8vIE5vdGU6IENhbiBiZSBwYXRjaGVkIG9uIGVsZW1lbnQgcHJvdG90eXBlIG9uIGFsbCBicm93c2Vycy5cbiAgLy8gTXVzdCBiZSBwYXRjaGVkIG9uIGluc3RhbmNlIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBuYXRpdmUgU2hhZG93IERPTVxuICAvLyBidXQgZG8gbm90IGhhdmUgYnVpbHRpbiBhY2Nlc3NvcnMgKG9sZCBDaHJvbWUpLlxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBzaGFkb3dSb290KCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICByZXR1cm4gbm9kZURhdGEgJiYgbm9kZURhdGEucHVibGljUm9vdCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgZ2V0IGNsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtFbGVtZW50fVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldCBjbGFzc05hbWUodmFsdWUpIHtcbiAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdzZXRBdHRyaWJ1dGUnXSgnY2xhc3MnLCB2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtFbGVtZW50fVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLm93bmVyRG9jdW1lbnQgIT09IGRvYykge1xuICAgICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3NldEF0dHJpYnV0ZSddKGF0dHIsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFzY29wZUNsYXNzQXR0cmlidXRlKHRoaXMsIGF0dHIsIHZhbHVlKSkge1xuICAgICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3NldEF0dHJpYnV0ZSddKGF0dHIsIHZhbHVlKTtcbiAgICAgIGRpc3RyaWJ1dGVBdHRyaWJ1dGVDaGFuZ2UodGhpcywgYXR0cik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZShhdHRyKSB7XG4gICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUF0dHJpYnV0ZSddKGF0dHIpO1xuICAgIGRpc3RyaWJ1dGVBdHRyaWJ1dGVDaGFuZ2UodGhpcywgYXR0cik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtFbGVtZW50fVxuICAgKiBAcGFyYW0geyF7bW9kZTogc3RyaW5nfX0gb3B0aW9uc1xuICAgKi9cbiAgYXR0YWNoU2hhZG93KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXR0YWNoU2hhZG93KHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbn0pO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtldmVudFByb3BlcnR5TmFtZXN9IGZyb20gJy4uL3BhdGNoLWV2ZW50cy5qcyc7XG5pbXBvcnQge3NoYWR5RGF0YUZvck5vZGUsIGVuc3VyZVNoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4uL3NoYWR5LWRhdGEuanMnO1xuXG5leHBvcnQgY29uc3QgSFRNTEVsZW1lbnRQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtIVE1MRWxlbWVudH0gKi9cbiAgYmx1cigpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgbGV0IHJvb3QgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5yb290O1xuICAgIGxldCBzaGFkb3dBY3RpdmUgPSByb290ICYmIHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoc2hhZG93QWN0aXZlKSB7XG4gICAgICBzaGFkb3dBY3RpdmVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2JsdXInXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnYmx1ciddKCk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5ldmVudFByb3BlcnR5TmFtZXMuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gIEhUTUxFbGVtZW50UGF0Y2hlc1twcm9wZXJ0eV0gPSB7XG4gICAgLyoqIEB0aGlzIHtIVE1MRWxlbWVudH0gKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBjb25zdCBzaGFkeURhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgICAgY29uc3QgZXZlbnROYW1lID0gcHJvcGVydHkuc3Vic3RyaW5nKDIpO1xuICAgICAgaWYgKCFzaGFkeURhdGEuX19vbkNhbGxiYWNrTGlzdGVuZXJzKSB7XG4gICAgICAgIHNoYWR5RGF0YS5fX29uQ2FsbGJhY2tMaXN0ZW5lcnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHNoYWR5RGF0YS5fX29uQ2FsbGJhY2tMaXN0ZW5lcnNbcHJvcGVydHldICYmIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHNoYWR5RGF0YS5fX29uQ2FsbGJhY2tMaXN0ZW5lcnNbcHJvcGVydHldKTtcbiAgICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2FkZEV2ZW50TGlzdGVuZXInXShldmVudE5hbWUsIGZuKTtcbiAgICAgIHNoYWR5RGF0YS5fX29uQ2FsbGJhY2tMaXN0ZW5lcnNbcHJvcGVydHldID0gZm47XG4gICAgfSxcbiAgICAvKiogQHRoaXMge0hUTUxFbGVtZW50fSAqL1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHNoYWR5RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgICByZXR1cm4gc2hhZHlEYXRhICYmIHNoYWR5RGF0YS5fX29uQ2FsbGJhY2tMaXN0ZW5lcnMgJiYgc2hhZHlEYXRhLl9fb25DYWxsYmFja0xpc3RlbmVyc1twcm9wZXJ0eV07XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfTtcbn0pO1xuXG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQge3NoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4uL3NoYWR5LWRhdGEuanMnO1xuaW1wb3J0IHthZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyfSBmcm9tICcuLi9wYXRjaC1ldmVudHMuanMnO1xuXG5leHBvcnQgY29uc3QgU2xvdFBhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKipcbiAgICogQHRoaXMge0hUTUxTbG90RWxlbWVudH1cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqL1xuICBhc3NpZ25lZE5vZGVzKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgLy8gRm9yY2UgYW55IGNvbnRhaW5pbmcgc2hhZG93Um9vdCB0byBmbHVzaCBzbyB0aGF0IGRpc3RyaWJ1dGlvbiBvY2N1cnNcbiAgICAgIC8vIGFuZCB0aGlzIG5vZGUgaGFzIGFzc2lnbmVkTm9kZXMuXG4gICAgICBjb25zdCByb290ID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXSgpO1xuICAgICAgaWYgKHJvb3QgJiYgdXRpbHMuaXNTaGFkeVJvb3Qocm9vdCkpIHtcbiAgICAgICAgcm9vdC5fcmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgICByZXR1cm4gbm9kZURhdGEgP1xuICAgICAgICAoKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuID8gbm9kZURhdGEuZmxhdHRlbmVkTm9kZXMgOlxuICAgICAgICAgIG5vZGVEYXRhLmFzc2lnbmVkTm9kZXMpIHx8IFtdKSA6XG4gICAgICAgIFtdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0hUTUxTbG90RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbj19IG9wdGlvbnNPckNhcHR1cmVcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpIHtcbiAgICAvLyBOT1RFLCBjaGVjayBpZiB0aGlzIGlzIGEgYHNsb3RgIGJlY2F1c2UgdGhlc2UgcGF0Y2hlcyBhcmUgaW5zdGFsbGVkIG9uXG4gICAgLy8gRWxlbWVudCB3aGVyZSBicm93c2VycyBkb24ndCBoYXZlIGA8c2xvdD5gXG4gICAgaWYgKHRoaXMubG9jYWxOYW1lICE9PSAnc2xvdCcgfHwgdHlwZSA9PT0gJ3Nsb3RjaGFuZ2UnKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhcHR1cmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnNPckNhcHR1cmUgPSB7XG4gICAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWR5RE9NIGNhbm5vdCBhdHRhY2ggZXZlbnQgdG8gc2xvdCB1bmxlc3MgaXQgaGFzIGEgYHBhcmVudE5vZGVgJyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT3JDYXB0dXJlLl9fc2hhZHlUYXJnZXQgPSB0aGlzO1xuICAgICAgcGFyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdhZGRFdmVudExpc3RlbmVyJ10odHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0hUTUxTbG90RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbj19IG9wdGlvbnNPckNhcHR1cmVcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpIHtcbiAgICAvLyBOT1RFLCBjaGVjayBpZiB0aGlzIGlzIGEgYHNsb3RgIGJlY2F1c2UgdGhlc2UgcGF0Y2hlcyBhcmUgaW5zdGFsbGVkIG9uXG4gICAgLy8gRWxlbWVudCB3aGVyZSBicm93c2VycyBkb24ndCBoYXZlIGA8c2xvdD5gXG4gICAgaWYgKHRoaXMubG9jYWxOYW1lICE9PSAnc2xvdCcgfHwgdHlwZSA9PT0gJ3Nsb3RjaGFuZ2UnKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhcHR1cmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnNPckNhcHR1cmUgPSB7XG4gICAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWR5RE9NIGNhbm5vdCBhdHRhY2ggZXZlbnQgdG8gc2xvdCB1bmxlc3MgaXQgaGFzIGEgYHBhcmVudE5vZGVgJyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zT3JDYXB0dXJlLl9fc2hhZHlUYXJnZXQgPSB0aGlzO1xuICAgICAgcGFyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVFdmVudExpc3RlbmVyJ10odHlwZSwgZm4sIG9wdGlvbnNPckNhcHR1cmUpO1xuICAgIH1cbiAgfVxuXG59KTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuY29uc3QgZG9jID0gd2luZG93LmRvY3VtZW50O1xuXG5leHBvcnQgY29uc3QgRG9jdW1lbnRQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLy8gbm90ZTogVGhvdWdoIG5vdCB0ZWNobmljYWxseSBjb3JyZWN0LCB3ZSBmYXN0IHBhdGggYGltcG9ydE5vZGVgXG4gIC8vIHdoZW4gY2FsbGVkIG9uIGEgbm9kZSBub3Qgb3duZWQgYnkgdGhlIG1haW4gZG9jdW1lbnQuXG4gIC8vIFRoaXMgYWxsb3dzLCBmb3IgZXhhbXBsZSwgZWxlbWVudHMgdGhhdCBjYW5ub3RcbiAgLy8gY29udGFpbiBjdXN0b20gZWxlbWVudHMgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGxpa2VseSB0byBjb250YWluIHNoYWRvd1Jvb3RzXG4gIC8vIHRvIGNsb25lZCBuYXRpdmVseS4gVGhpcyBpcyBhIGZhaXJseSBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSB3aW4uXG4gIC8qKlxuICAgKiBAdGhpcyB7RG9jdW1lbnR9XG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXBcbiAgICovXG4gIGltcG9ydE5vZGUobm9kZSwgZGVlcCkge1xuICAgIC8vIEEgdGVtcGxhdGUgZWxlbWVudCBub3JtYWxseSBoYXMgbm8gY2hpbGRyZW4gd2l0aCBzaGFkb3dSb290cywgc28gbWFrZVxuICAgIC8vIHN1cmUgd2UgYWx3YXlzIG1ha2UgYSBkZWVwIGNvcHkgdG8gY29ycmVjdGx5IGNvbnN0cnVjdCB0aGUgdGVtcGxhdGUuY29udGVudFxuICAgIGlmIChub2RlLm93bmVyRG9jdW1lbnQgIT09IGRvYyB8fCBub2RlLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdpbXBvcnROb2RlJ10obm9kZSwgZGVlcCk7XG4gICAgfVxuICAgIGxldCBuID0gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2ltcG9ydE5vZGUnXShub2RlLCBmYWxzZSk7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGZvciAobGV0IGM9bm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddLCBuYzsgYzsgYyA9IGNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgICAgbmMgPSB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbXBvcnROb2RlJ10oYywgdHJ1ZSk7XG4gICAgICAgIG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ2FwcGVuZENoaWxkJ10obmMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuXG59KTsiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHthZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyfSBmcm9tICcuLi9wYXRjaC1ldmVudHMuanMnO1xuXG5leHBvcnQgY29uc3QgV2luZG93UGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8vIE5PVEU6IGVuc3VyZSB0aGVzZSBtZXRob2RzIGFyZSBib3VuZCB0byBgd2luZG93YCBzbyB0aGF0IGB0aGlzYCBpcyBjb3JyZWN0XG4gIC8vIHdoZW4gY2FsbGVkIGRpcmVjdGx5IGZyb20gZ2xvYmFsIGNvbnRleHQgd2l0aG91dCBhIHJlY2VpdmVyOyBlLmcuXG4gIC8vIGBhZGRFdmVudExpc3RlbmVyKC4uLilgLlxuICBhZGRFdmVudExpc3RlbmVyOiBhZGRFdmVudExpc3RlbmVyLmJpbmQod2luZG93KSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyOiByZW1vdmVFdmVudExpc3RlbmVyLmJpbmQod2luZG93KVxuXG59KTsiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7RXZlbnRUYXJnZXRQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IHtOb2RlUGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL05vZGUuanMnO1xuaW1wb3J0IHtTbG90YWJsZVBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9TbG90YWJsZS5qcyc7XG5pbXBvcnQge1BhcmVudE5vZGVQYXRjaGVzLCBQYXJlbnROb2RlRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL1BhcmVudE5vZGUuanMnO1xuaW1wb3J0IHtFbGVtZW50UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL0VsZW1lbnQuanMnO1xuaW1wb3J0IHtFbGVtZW50T3JTaGFkb3dSb290UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL0VsZW1lbnRPclNoYWRvd1Jvb3QuanMnO1xuaW1wb3J0IHtIVE1MRWxlbWVudFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9IVE1MRWxlbWVudC5qcyc7XG5pbXBvcnQge1Nsb3RQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvU2xvdC5qcyc7XG5pbXBvcnQge0RvY3VtZW50T3JGcmFnbWVudFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Eb2N1bWVudE9yRnJhZ21lbnQuanMnO1xuaW1wb3J0IHtEb2N1bWVudE9yU2hhZG93Um9vdFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Eb2N1bWVudE9yU2hhZG93Um9vdC5qcyc7XG5pbXBvcnQge0RvY3VtZW50UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL0RvY3VtZW50LmpzJztcbmltcG9ydCB7V2luZG93UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL1dpbmRvdy5qcyc7XG5cbi8vIFNvbWUgYnJvd3NlcnMgKElFL0VkZ2UpIGhhdmUgbm9uLXN0YW5kYXJkIEhUTUxFbGVtZW50IGFjY2Vzc29ycy5cbmNvbnN0IE5vblN0YW5kYXJkSFRNTEVsZW1lbnQgPSB7fTtcblxuaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAncGFyZW50RWxlbWVudCcpKSB7XG4gIE5vblN0YW5kYXJkSFRNTEVsZW1lbnQucGFyZW50RWxlbWVudCA9IE5vZGVQYXRjaGVzLnBhcmVudEVsZW1lbnQ7XG59XG5cbmlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NvbnRhaW5zJykpIHtcbiAgTm9uU3RhbmRhcmRIVE1MRWxlbWVudC5jb250YWlucyA9IE5vZGVQYXRjaGVzLmNvbnRhaW5zO1xufVxuXG5pZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsICdjaGlsZHJlbicpKSB7XG4gIE5vblN0YW5kYXJkSFRNTEVsZW1lbnQuY2hpbGRyZW4gPSBQYXJlbnROb2RlUGF0Y2hlcy5jaGlsZHJlbjtcbn1cblxuaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5uZXJIVE1MJykpIHtcbiAgTm9uU3RhbmRhcmRIVE1MRWxlbWVudC5pbm5lckhUTUwgPSBFbGVtZW50T3JTaGFkb3dSb290UGF0Y2hlcy5pbm5lckhUTUw7XG59XG5cbmlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NsYXNzTmFtZScpKSB7XG4gIE5vblN0YW5kYXJkSFRNTEVsZW1lbnQuY2xhc3NOYW1lID0gRWxlbWVudFBhdGNoZXMuY2xhc3NOYW1lO1xufVxuXG4vLyBBdm9pZCBwYXRjaGluZyBgaW5uZXJIVE1MYCBpZiBpdCBkb2VzIG5vdCBleGlzdCBvbiBFbGVtZW50IChJRSlcbi8vIGFuZCB3ZSBjYW4gcGF0Y2ggYWNjZXNzb3JzIChoYXNEZXNjcmlwdG9ycykuXG5jb25zdCBFbGVtZW50U2hvdWxkSGF2ZUlubmVySFRNTCA9ICF1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycyB8fCAnaW5uZXJIVE1MJyBpbiBFbGVtZW50LnByb3RvdHlwZTtcblxuLy8gc2V0dXAgcGF0Y2hpbmdcbmNvbnN0IHBhdGNoTWFwID0ge1xuICBFdmVudFRhcmdldDogW0V2ZW50VGFyZ2V0UGF0Y2hlc10sXG4gIE5vZGU6IFtOb2RlUGF0Y2hlcywgIXdpbmRvdy5FdmVudFRhcmdldCA/IEV2ZW50VGFyZ2V0UGF0Y2hlcyA6IG51bGxdLFxuICBUZXh0OiBbU2xvdGFibGVQYXRjaGVzXSxcbiAgRWxlbWVudDogW0VsZW1lbnRQYXRjaGVzLCBQYXJlbnROb2RlUGF0Y2hlcywgU2xvdGFibGVQYXRjaGVzLFxuICAgIEVsZW1lbnRTaG91bGRIYXZlSW5uZXJIVE1MID8gRWxlbWVudE9yU2hhZG93Um9vdFBhdGNoZXMgOiBudWxsLFxuICAgICF3aW5kb3cuSFRNTFNsb3RFbGVtZW50ID8gU2xvdFBhdGNoZXMgOiBudWxsXSxcbiAgSFRNTEVsZW1lbnQ6IFtIVE1MRWxlbWVudFBhdGNoZXMsIE5vblN0YW5kYXJkSFRNTEVsZW1lbnRdLFxuICBIVE1MU2xvdEVsZW1lbnQ6IFtTbG90UGF0Y2hlc10sXG4gIERvY3VtZW50RnJhZ21lbnQ6IFtQYXJlbnROb2RlRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcywgRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlc10sXG4gIERvY3VtZW50OiBbRG9jdW1lbnRQYXRjaGVzLCBQYXJlbnROb2RlRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcywgRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcywgRG9jdW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzXSxcbiAgV2luZG93OiBbV2luZG93UGF0Y2hlc11cbn1cblxuY29uc3QgZ2V0UGF0Y2hQcm90b3R5cGUgPSAobmFtZSkgPT4gd2luZG93W25hbWVdICYmIHdpbmRvd1tuYW1lXS5wcm90b3R5cGU7XG5cbi8vIE5vdGUsIG11c3QgYXZvaWQgcGF0Y2hpbmcgYWNjZXNzb3JzIG9uIHByb3RvdHlwZXMgd2hlbiBkZXNjcmlwdG9ycyBhcmUgbm90IGNvcnJlY3Rcbi8vIGJlY2F1c2UgdGhlIEN1c3RvbUVsZW1lbnRzIHBvbHlmaWxsIGNoZWNrcyBpZiB0aGVzZSBleGlzdCBiZWZvcmUgcGF0Y2hpbmcgaW5zdGFuY2VzLlxuLy8gQ3VzdG9tRWxlbWVudHMgcG9seWZpbGwgKm9ubHkqIGNhcmVzIGFib3V0IHRoZXNlIGFjY2Vzc29ycy5cbmNvbnN0IGRpc2FsbG93ZWROYXRpdmVQYXRjaGVzID0gdXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMgPyBudWxsIDogWydpbm5lckhUTUwnLCAndGV4dENvbnRlbnQnXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nPX0gcHJlZml4ICovXG5leHBvcnQgY29uc3QgYXBwbHlQYXRjaGVzID0gKHByZWZpeCkgPT4ge1xuICBjb25zdCBkaXNhbGxvd2VkID0gcHJlZml4ID8gbnVsbCA6IGRpc2FsbG93ZWROYXRpdmVQYXRjaGVzO1xuICBmb3IgKGxldCBwIGluIHBhdGNoTWFwKSB7XG4gICAgY29uc3QgcHJvdG8gPSBnZXRQYXRjaFByb3RvdHlwZShwKTtcbiAgICBwYXRjaE1hcFtwXS5mb3JFYWNoKHBhdGNoID0+IHByb3RvICYmIHBhdGNoICYmXG4gICAgICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgcGF0Y2gsIHByZWZpeCwgZGlzYWxsb3dlZCkpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhZGRTaGFkeVByZWZpeGVkUHJvcGVydGllcyA9ICgpID0+IHtcbiAgLy8gcGVyZm9ybSBzaGFkeSBwYXRjaGVzXG4gIGFwcGx5UGF0Y2hlcyh1dGlscy5TSEFEWV9QUkVGSVgpO1xuXG4gIC8vIGluc3RhbGwgYF9hY3RpdmVFbGVtZW50YCBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgKG9sZGVyIENocm9tZS9TYWZhcmkpIGRvIG5vdCBoYXZlXG4gIC8vIGEgJ2NvbmZpZ3VyYWJsZScgYGFjdGl2ZUVsZW1lbnRgIGFjY2Vzc3Nvci5cbiAgY29uc3QgZGVzY3JpcHRvciA9IERvY3VtZW50T3JTaGFkb3dSb290UGF0Y2hlcy5hY3RpdmVFbGVtZW50O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsICdfYWN0aXZlRWxlbWVudCcsIGRlc2NyaXB0b3IpO1xuXG4gIC8vIE9uIFdpbmRvdywgd2UncmUgcGF0Y2hpbmcgYGFkZEV2ZW50TGlzdGVuZXJgIHdoaWNoIGlzIGEgd2VpcmQgYXV0by1ib3VuZFxuICAvLyBwcm9wZXJ0eSB0aGF0IGlzIG5vdCBkaXJlY3RseSBvbiB0aGUgV2luZG93IHByb3RvdHlwZS5cbiAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKFdpbmRvdy5wcm90b3R5cGUsIFdpbmRvd1BhdGNoZXMsIHV0aWxzLlNIQURZX1BSRUZJWCk7XG59O1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLyoqXG4gKiBQYXRjaGVzIGVsZW1lbnRzIHRoYXQgaW50ZXJhY3RzIHdpdGggU2hhZHlET01cbiAqIHN1Y2ggdGhhdCB0cmVlIHRyYXZlcnNhbCBhbmQgbXV0YXRpb24gYXBpcyBhY3QgbGlrZSB0aGV5IHdvdWxkIHVuZGVyXG4gKiBTaGFkb3dET00uXG4gKlxuICogVGhpcyBpbXBvcnQgZW5hYmxlcyBzZWVtbGVzcyBpbnRlcmFjdGlvbiB3aXRoIFNoYWR5RE9NIHBvd2VyZWRcbiAqIGN1c3RvbSBlbGVtZW50cywgZW5hYmxpbmcgYmV0dGVyIGludGVyb3BlcmF0aW9uIHdpdGggM3JkIHBhcnR5IGNvZGUsXG4gKiBsaWJyYXJpZXMsIGFuZCBmcmFtZXdvcmtzIHRoYXQgdXNlIERPTSB0cmVlIG1hbmlwdWxhdGlvbiBhcGlzLlxuICovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtmbHVzaCwgZW5xdWV1ZX0gZnJvbSAnLi9mbHVzaC5qcyc7XG5pbXBvcnQge29ic2VydmVDaGlsZHJlbiwgdW5vYnNlcnZlQ2hpbGRyZW4sIGZpbHRlck11dGF0aW9uc30gZnJvbSAnLi9vYnNlcnZlLWNoYW5nZXMuanMnO1xuaW1wb3J0IHthZGROYXRpdmVQcmVmaXhlZFByb3BlcnRpZXMsIG5hdGl2ZU1ldGhvZHMsIG5hdGl2ZVRyZWV9IGZyb20gJy4vcGF0Y2gtbmF0aXZlLmpzJztcbmltcG9ydCB7cGF0Y2hJbnNpZGVFbGVtZW50QWNjZXNzb3JzLCBwYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzfSBmcm9tICcuL3BhdGNoLWluc3RhbmNlcy5qcyc7XG5pbXBvcnQge3BhdGNoRXZlbnRzLCBwYXRjaENsaWNrLCBjb21wb3NlZFBhdGh9IGZyb20gJy4vcGF0Y2gtZXZlbnRzLmpzJztcbmltcG9ydCB7U2hhZHlSb290fSBmcm9tICcuL2F0dGFjaC1zaGFkb3cuanMnO1xuaW1wb3J0IHt3cmFwLCBXcmFwcGVyfSBmcm9tICcuL3dyYXBwZXIuanMnO1xuaW1wb3J0IHthZGRTaGFkeVByZWZpeGVkUHJvcGVydGllcywgYXBwbHlQYXRjaGVzfSBmcm9tICcuL3BhdGNoLXByb3RvdHlwZXMuanMnO1xuXG5cbmlmICh1dGlscy5zZXR0aW5ncy5pblVzZSkge1xuXG4gIGxldCBTaGFkeURPTSA9IHtcbiAgICAvLyBUT0RPKHNvcnZlbGwpOiByZW1vdmUgd2hlbiBQb2x5bWVyIGRvZXMgbm90IGRlcGVuZCBvbiB0aGlzLlxuICAgICdpblVzZSc6IHV0aWxzLnNldHRpbmdzLmluVXNlLFxuICAgIC8vIE5PVEU6IG9sZCBicm93c2VycyB3aXRob3V0IHByb3RvdHlwZSBhY2Nlc3NvcnMgKHZlcnkgb2xkIENocm9tZVxuICAgIC8vIGFuZCBTYWZhcmkpIG5lZWQgbWFudWFsbHkgcGF0Y2hlZCBhY2Nlc3NvcnMgdG8gcHJvcGVybHkgc2V0XG4gICAgLy8gYGlubmVySFRNTGAgYW5kIGB0ZXh0Q29udGVudGAgd2hlbiBhbiBlbGVtZW50IGlzOlxuICAgIC8vICgxKSBpbnNpZGUgYSBzaGFkb3dSb290XG4gICAgLy8gKDIpIGRvZXMgbm90IGhhdmUgc3BlY2lhbCAoc2xvdCkgY2hpbGRyZW4gaXRzZWxmXG4gICAgLy8gKDMpIGFuZCBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBuZWVkcyB0byBwcm92b2tlIGRpc3RyaWJ1dGlvbiAoYmVjYXVzZVxuICAgIC8vIGEgbmVzdGVkIHNsb3QgaXMgYWRkZWQvcmVtb3ZlZClcbiAgICAncGF0Y2gnOiAobm9kZSkgPT4ge1xuICAgICAgcGF0Y2hJbnNpZGVFbGVtZW50QWNjZXNzb3JzKG5vZGUpO1xuICAgICAgcGF0Y2hPdXRzaWRlRWxlbWVudEFjY2Vzc29ycyhub2RlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgJ2lzU2hhZHlSb290JzogdXRpbHMuaXNTaGFkeVJvb3QsXG4gICAgJ2VucXVldWUnOiBlbnF1ZXVlLFxuICAgICdmbHVzaCc6IGZsdXNoLFxuICAgICdmbHVzaEluaXRpYWwnOiAocm9vdCkgPT4ge1xuICAgICAgcm9vdC5fZmx1c2hJbml0aWFsKCk7XG4gICAgfSxcbiAgICAnc2V0dGluZ3MnOiB1dGlscy5zZXR0aW5ncyxcbiAgICAnZmlsdGVyTXV0YXRpb25zJzogZmlsdGVyTXV0YXRpb25zLFxuICAgICdvYnNlcnZlQ2hpbGRyZW4nOiBvYnNlcnZlQ2hpbGRyZW4sXG4gICAgJ3Vub2JzZXJ2ZUNoaWxkcmVuJzogdW5vYnNlcnZlQ2hpbGRyZW4sXG4gICAgLy8gU2V0IHRvIHRydWUgdG8gZGVmZXIgbmF0aXZlIGN1c3RvbSBlbGVtZW50cyBjb25uZWN0aW9uIHVudGlsIHRoZVxuICAgIC8vIGRvY3VtZW50IGhhcyBmdWxseSBwYXJzZWQuIFRoaXMgZW5hYmxlcyBjdXN0b20gZWxlbWVudHMgdGhhdCBjcmVhdGVcbiAgICAvLyBzaGFkb3dSb290cyB0byBiZSBkZWZpbmVkIHdoaWxlIHRoZSBkb2N1bWVudCBpcyBsb2FkaW5nLiBFbGVtZW50c1xuICAgIC8vIGN1c3RvbWl6ZWQgYXMgdGhleSBhcmUgY3JlYXRlZCBieSB0aGUgcGFyc2VyIHdpbGwgc3VjY2Vzc2Z1bGx5XG4gICAgLy8gcmVuZGVyIHdpdGggdGhpcyBmbGFnIG9uLlxuICAgICdkZWZlckNvbm5lY3Rpb25DYWxsYmFja3MnOiB1dGlscy5zZXR0aW5nc1snZGVmZXJDb25uZWN0aW9uQ2FsbGJhY2tzJ10sXG4gICAgLy8gU2V0IHRvIHRydWUgdG8gc3BlZWQgdXAgdGhlIHBvbHlmaWxsIHNsaWdodGx5IGF0IHRoZSBjb3N0IG9mIGNvcnJlY3RuZXNzXG4gICAgLy8gKiBkb2VzIG5vdCBwYXRjaCBxdWVyeVNlbGVjdG9yL0FsbCBvbiBEb2N1bWVudCBvciBEb2N1bWVudEZyYWdtZW50XG4gICAgLy8gKiBkb2VzIG5vdCB3cmFwIGNvbm5lY3RlZC9kaXNjb25uZWN0ZWQgY2FsbGJhY2tzIHRvIGRlLWR1cCB0aGVzZVxuICAgIC8vIHdoZW4gdXNpbmcgbmF0aXZlIGN1c3RvbUVsZW1lbnRzXG4gICAgLy8gKiBkb2VzIG5vdCB3YWl0IHRvIHByb2Nlc3MgY2hpbGRyZW4gb2YgZWxlbWVudHMgd2l0aCBzaGFkb3dSb290c1xuICAgIC8vIG1lYW5pbmcgc2hhZG93Um9vdHMgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIHdoaWxlIGFuIGVsZW1lbnQgaXMgcGFyc2luZ1xuICAgIC8vIChlLmcuIGlmIGEgY3VzdG9tIGVsZW1lbnQgdGhhdCBjcmVhdGVzIGEgc2hhZG93Um9vdCBpcyBkZWZpbmVkIGJlZm9yZVxuICAgIC8vIGEgY2FuZGlkYXRlIGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50IGJlbG93IGl0LlxuICAgICdwcmVmZXJQZXJmb3JtYW5jZSc6IHV0aWxzLnNldHRpbmdzWydwcmVmZXJQZXJmb3JtYW5jZSddLFxuICAgIC8vIEludGVncmF0aW9uIHBvaW50IHdpdGggU2hhZHlDU1MgdG8gZGlzYWJsZSBzdHlsaW5nIE11dGF0aW9uT2JzZXJ2ZXIsXG4gICAgLy8gYXMgU2hhZHlET00gd2lsbCBub3cgaGFuZGxlIGR5bmFtaWMgc2NvcGluZy5cbiAgICAnaGFuZGxlc0R5bmFtaWNTY29waW5nJzogdHJ1ZSxcbiAgICAnd3JhcCc6IHV0aWxzLnNldHRpbmdzLm5vUGF0Y2ggPyB3cmFwIDogKG4pID0+IG4sXG4gICAgJ1dyYXBwZXInOiBXcmFwcGVyLFxuICAgICdjb21wb3NlZFBhdGgnOiBjb21wb3NlZFBhdGgsXG4gICAgLy8gU2V0IHRvIHRydWUgdG8gYXZvaWQgcGF0Y2hpbmcgcmVndWxhciBwbGF0Zm9ybSBwcm9wZXJ0eSBuYW1lcy4gV2hlbiBzZXQsXG4gICAgLy8gU2hhZG93IERPTSBjb21wYXRpYmxlIGJlaGF2aW9yIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gYWNjZXNzaW5nIERPTVxuICAgIC8vIEFQSSB1c2luZyBgU2hhZHlET00ud3JhcGAsIGUuZy4gYFNoYWR5RE9NLndyYXAoZWxlbWVudCkuc2hhZG93Um9vdGAuXG4gICAgLy8gVGhpcyBzZXR0aW5nIHByb3ZpZGVzIGEgc21hbGwgcGVyZm9ybWFuY2UgYm9vc3QsIGJ1dCByZXF1aXJlcyBhbGwgRE9NIEFQSVxuICAgIC8vIGFjY2VzcyB0aGF0IHJlcXVpcmVzIFNoYWRvdyBET00gYmVoYXZpb3IgdG8gYmUgcHJveGllZCB2aWEgYFNoYWR5RE9NLndyYXBgLlxuICAgICdub1BhdGNoJzogdXRpbHMuc2V0dGluZ3Mubm9QYXRjaCxcbiAgICAnbmF0aXZlTWV0aG9kcyc6IG5hdGl2ZU1ldGhvZHMsXG4gICAgJ25hdGl2ZVRyZWUnOiBuYXRpdmVUcmVlXG4gIH07XG5cbiAgd2luZG93WydTaGFkeURPTSddID0gU2hhZHlET007XG5cbiAgLy8gTW9kaWZpZXMgbmF0aXZlIHByb3RvdHlwZXMgZm9yIE5vZGUsIEVsZW1lbnQsIGV0Yy4gdG9cbiAgLy8gbWFrZSBuYXRpdmUgcGxhdGZvcm0gYmVoYXZpb3IgYXZhaWxhYmxlIGF0IHByZWZpeGVkIG5hbWVzLCBlLmcuXG4gIC8vIGB1dGlscy5OQVRJVkVfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnYCBvciBgX19zaGFkeV9uYXRpdmVfZmlyc3RDaGlsZGAuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSBzdGFuZGFyZCBuYW1lcyB0byBiZSBzYWZlbHkgcGF0Y2hlZCB3aGlsZSByZXRhaW5pbmcgdGhlXG4gIC8vIGFiaWxpdHkgZm9yIG5hdGl2ZSBiZWhhdmlvciB0byBiZSB1c2VkLiBUaGlzIHBvbHlmaWxsIG1hbmlwdWxhdGVzIERPTVxuICAvLyBieSB1c2luZyB0aGlzIHNhdmVkIG5hdGl2ZSBiZWhhdmlvci5cbiAgLy8gTm90ZSwgc29tZSBicm93c2VycyBkbyBub3QgaGF2ZSBwcm9wZXIgZWxlbWVudCBkZXNjcmlwdG9ycyBmb3JcbiAgLy8gYWNjZXNzb3JzOyBpbiB0aGlzIGNhc2UsIG5hdGl2ZSBiZWhhdmlvciBmb3IgdGhlc2UgYWNjZXNzb3JzIGlzIHNpbXVsYXRlZFxuICAvLyB2aWEgYSBUcmVlV2Fsa2VyLlxuICBhZGROYXRpdmVQcmVmaXhlZFByb3BlcnRpZXMoKTtcblxuICAvLyBNb2RpZmllcyBuYXRpdmUgcHJvdG90eXBlcyBmb3IgTm9kZSwgRWxlbWVudCwgZXRjLiB0byBtYWtlIFNoYWRvd0RPTVxuICAvLyBiZWhhdmlvciBhdmFpbGFibGUgYXQgcHJlZml4ZWQgbmFtZXMsIGUuZy5cbiAgLy8gYHV0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkYCBvciBgX19zaGFkeV9maXJzdENoaWxkYC4gVGhpcyBpcyBkb25lXG4gIC8vIHNvIHRoaXMgcG9seWZpbGwgY2FuIHBlcmZvcm0gU2hhZG93IERPTSBzdHlsZSBET00gbWFuaXB1bGF0aW9uLlxuICAvLyBCZWNhdXNlIHBhdGNoaW5nIG5vcm1hbCBwbGF0Zm9ybSBwcm9wZXJ0eSBuYW1lcyBpcyBvcHRpb25hbCwgdGhlc2UgcHJlZml4ZWRcbiAgLy8gbmFtZXMgYXJlIHVzZWQgaW50ZXJuYWxseS5cbiAgYWRkU2hhZHlQcmVmaXhlZFByb3BlcnRpZXMoKTtcblxuICAvLyBNb2RpZmllcyBuYXRpdmUgcHJvdG90eXBlcyBmb3IgTm9kZSwgRWxlbWVudCwgZXRjLiB0byBwYXRjaFxuICAvLyByZWd1bGFyIHBsYXRmb3JtIHByb3BlcnR5IG5hbWVzIHRvIGhhdmUgU2hhZG93IERPTSBjb21wYXRpYmxlIEFQSSBiZWhhdmlvci5cbiAgLy8gVGhpcyBhcHBsaWVzIHRoZSB1dGlscy5TSEFEWV9QUkVGSVggYmVoYXZpb3IgdG8gbm9ybWFsIG5hbWVzLiBGb3IgZXhhbXBsZSxcbiAgLy8gaWYgYG5vUGF0Y2hgIGlzIG5vdCBzZXQsIHRoZW4gYGVsLl9fc2hhZHlfZmlyc3RDaGlsZGAgaXMgZXF1aXZhbGVudCB0b1xuICAvLyBgZWwuZmlyc3RDaGlsZGAuXG4gIC8vIE5PVEUsIG9uIG9sZGVyIGJyb3dzZXJzIChvbGQgQ2hyb21lL1NhZmFyaSkgbmF0aXZlIGFjY2Vzc29ycyBjYW5ub3QgYmVcbiAgLy8gcGF0Y2hlZCBvbiBwcm90b3R5cGVzIChlLmcuIE5vZGUucHJvdG90eXBlLmZpcnN0Q2hpbGQgY2Fubm90IGJlIG1vZGlmaWVkKS5cbiAgLy8gT24gdGhlc2UgYnJvd3NlcnMsIGluc3RhbmNlIGxldmVsIHBhdGNoaW5nIGlzIHBlcmZvcm1lZCB3aGVyZSBuZWVkZWQ7IHRoaXNcbiAgLy8gaW5zdGFuY2UgcGF0Y2hpbmcgaXMgb25seSBkb25lIHdoZW4gYG5vUGF0Y2hgIGlzICpub3QqIHNldC5cbiAgaWYgKCF1dGlscy5zZXR0aW5ncy5ub1BhdGNoKSB7XG4gICAgYXBwbHlQYXRjaGVzKCk7XG4gICAgLy8gUGF0Y2ggY2xpY2sgZXZlbnQgYmVoYXZpb3Igb25seSBpZiB3ZSdyZSBwYXRjaGluZ1xuICAgIHBhdGNoQ2xpY2soKVxuICB9XG5cbiAgLy8gRm9yIHNpbXBsaWNpdHksIHBhdGNoIGV2ZW50cyB1bmNvbmRpdGlvbmFsbHkuXG4gIC8vIFBhdGNoZXMgdGhlIGV2ZW50IHN5c3RlbSB0byBoYXZlIFNoYWRvdyBET00gY29tcGF0aWJsZSBiZWhhdmlvciAoZS5nLlxuICAvLyBldmVudCByZXRhcmdldGluZykuIFdoZW4gYG5vUGF0Y2hgIGlzIHNldCwgcmV0YXJnZXRpbmcgaXMgb25seSBhdmFpbGFibGVcbiAgLy8gd2hlbiBhZGRpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCBkaXNwYXRjaGluZyBldmVudHMgdmlhIGBTaGFkeURPTS53cmFwYFxuICAvLyAoZS5nLiBgU2hhZHlET00ud3JhcChlbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKC4uLilgKS5cbiAgcGF0Y2hFdmVudHMoKTtcblxuICB3aW5kb3cuU2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7ZnVuY3Rpb24obmV3OlNoYWRvd1Jvb3QpfSAqLyhTaGFkeVJvb3QpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@webcomponents/shadydom/src/shadydom.js\n");

/***/ }),

/***/ "./node_modules/document-register-element/build/document-register-element.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/document-register-element/build/document-register-element.js ***!
  \***********************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */\n!function (e, t) {\n  \"use strict\";\n\n  function n() {\n    var e = A.splice(0, A.length);\n\n    for (Ye = 0; e.length;) {\n      e.shift().call(null, e.shift());\n    }\n  }\n\n  function r(e, t) {\n    for (var n = 0, r = e.length; n < r; n++) {\n      T(e[n], t);\n    }\n  }\n\n  function o(e) {\n    for (var t, n = 0, r = e.length; n < r; n++) {\n      t = e[n], V(t, le[a(t)]);\n    }\n  }\n\n  function l(e) {\n    return function (t) {\n      ke(t) && (T(t, e), ae.length && r(t.querySelectorAll(ae), e));\n    };\n  }\n\n  function a(e) {\n    var t = Ze.call(e, \"is\"),\n        n = e.nodeName.toUpperCase(),\n        r = ue.call(oe, t ? te + t.toUpperCase() : ee + n);\n    return t && -1 < r && !i(n, t) ? -1 : r;\n  }\n\n  function i(e, t) {\n    return -1 < ae.indexOf(e + '[is=\"' + t + '\"]');\n  }\n\n  function u(e) {\n    var t = e.currentTarget,\n        n = e.attrChange,\n        r = e.attrName,\n        o = e.target,\n        l = e[$] || 2,\n        a = e[Q] || 3;\n    !ot || o && o !== t || !t[Z] || \"style\" === r || e.prevValue === e.newValue && (\"\" !== e.newValue || n !== l && n !== a) || t[Z](r, n === l ? null : e.prevValue, n === a ? null : e.newValue);\n  }\n\n  function c(e) {\n    var t = l(e);\n    return function (e) {\n      A.push(t, e.target), Ye && clearTimeout(Ye), Ye = setTimeout(n, 1);\n    };\n  }\n\n  function s(e) {\n    rt && (rt = !1, e.currentTarget.removeEventListener(Y, s)), ae.length && r((e.target || y).querySelectorAll(ae), e.detail === q ? q : _), Re && d();\n  }\n\n  function m(e, t) {\n    var n = this;\n    ze.call(n, e, t), O.call(n, {\n      target: n\n    });\n  }\n\n  function f(e, t, n) {\n    var r = t.apply(e, n),\n        l = a(r);\n    return -1 < l && V(r, le[l]), n.pop() && ae.length && o(r.querySelectorAll(ae)), r;\n  }\n\n  function p(e, t) {\n    Fe(e, t), I ? I.observe(e, Qe) : (nt && (e.setAttribute = m, e[U] = D(e), e[k](J, O)), e[k](W, u)), e[K] && ot && (e.created = !0, e[K](), e.created = !1);\n  }\n\n  function d() {\n    for (var e, t = 0, n = _e.length; t < n; t++) {\n      e = _e[t], ie.contains(e) || (n--, _e.splice(t--, 1), T(e, q));\n    }\n  }\n\n  function h(e) {\n    throw new Error(\"A \" + e + \" type is already registered\");\n  }\n\n  function T(e, t) {\n    var n,\n        r,\n        o = a(e);\n    -1 < o && (S(e, le[o]), o = 0, t !== _ || e[_] ? t !== q || e[q] || (e[_] = !1, e[q] = !0, r = \"disconnected\", o = 1) : (e[q] = !1, e[_] = !0, r = \"connected\", o = 1, Re && ue.call(_e, e) < 0 && _e.push(e)), o && (n = e[t + x] || e[r + x]) && n.call(e));\n  }\n\n  function L() {}\n\n  function M(e, t, n) {\n    var r = n && n[B] || \"\",\n        o = t.prototype,\n        l = Ie(o),\n        a = t.observedAttributes || pe,\n        i = {\n      prototype: l\n    };\n    Ue(l, K, {\n      value: function value() {\n        if (we) we = !1;else if (!this[ve]) {\n          this[ve] = !0, new t(this), o[K] && o[K].call(this);\n          var e = Ae[Ne.get(t)];\n          (!ge || e.create.length > 1) && H(this);\n        }\n      }\n    }), Ue(l, Z, {\n      value: function value(e) {\n        -1 < ue.call(a, e) && o[Z] && o[Z].apply(this, arguments);\n      }\n    }), o[G] && Ue(l, j, {\n      value: o[G]\n    }), o[z] && Ue(l, X, {\n      value: o[z]\n    }), r && (i[B] = r), e = e.toUpperCase(), Ae[e] = {\n      constructor: t,\n      create: r ? [r, De(e)] : [e]\n    }, Ne.set(t, e), y[R](e.toLowerCase(), i), g(e), Oe[e].r();\n  }\n\n  function E(e) {\n    var t = Ae[e.toUpperCase()];\n    return t && t.constructor;\n  }\n\n  function v(e) {\n    return \"string\" == typeof e ? e : e && e.is || \"\";\n  }\n\n  function H(e) {\n    for (var t, n = e[Z], r = n ? e.attributes : pe, o = r.length; o--;) {\n      t = r[o], n.call(e, t.name || t.nodeName, null, t.value || t.nodeValue);\n    }\n  }\n\n  function g(e) {\n    return e = e.toUpperCase(), e in Oe || (Oe[e] = {}, Oe[e].p = new Ce(function (t) {\n      Oe[e].r = t;\n    })), Oe[e].p;\n  }\n\n  function b() {\n    He && delete e.customElements, fe(e, \"customElements\", {\n      configurable: !0,\n      value: new L()\n    }), fe(e, \"CustomElementRegistry\", {\n      configurable: !0,\n      value: L\n    });\n\n    for (var t = w.get(/^HTML[A-Z]*[a-z]/), n = t.length; n--; function (t) {\n      var n = e[t];\n\n      if (n) {\n        e[t] = function (e) {\n          var t, r;\n          return e || (e = this), e[ve] || (we = !0, t = Ae[Ne.get(e.constructor)], r = ge && 1 === t.create.length, e = r ? Reflect.construct(n, pe, t.constructor) : y.createElement.apply(y, t.create), e[ve] = !0, we = !1, r || H(e)), e;\n        }, e[t].prototype = n.prototype;\n\n        try {\n          n.prototype.constructor = e[t];\n        } catch (r) {\n          Ee = !0, fe(n, ve, {\n            value: e[t]\n          });\n        }\n      }\n    }(t[n])) {\n      ;\n    }\n\n    y.createElement = function (e, t) {\n      var n = v(t);\n      return n ? $e.call(this, e, De(n)) : $e.call(this, e);\n    }, Je || (tt = !0, y[R](\"\"));\n  }\n\n  var y = e.document,\n      C = e.Object,\n      w = function (e) {\n    var t,\n        n,\n        r,\n        o,\n        l = /^[A-Z]+[a-z]/,\n        a = function a(e) {\n      var t,\n          n = [];\n\n      for (t in u) {\n        e.test(t) && n.push(t);\n      }\n\n      return n;\n    },\n        i = function i(e, t) {\n      (t = t.toLowerCase()) in u || (u[e] = (u[e] || []).concat(t), u[t] = u[t.toUpperCase()] = e);\n    },\n        u = (C.create || C)(null),\n        c = {};\n\n    for (n in e) {\n      for (o in e[n]) {\n        for (r = e[n][o], u[o] = r, t = 0; t < r.length; t++) {\n          u[r[t].toLowerCase()] = u[r[t].toUpperCase()] = o;\n        }\n      }\n    }\n\n    return c.get = function (e) {\n      return \"string\" == typeof e ? u[e] || (l.test(e) ? [] : \"\") : a(e);\n    }, c.set = function (e, t) {\n      return l.test(e) ? i(e, t) : i(t, e), c;\n    }, c;\n  }({\n    collections: {\n      HTMLAllCollection: [\"all\"],\n      HTMLCollection: [\"forms\"],\n      HTMLFormControlsCollection: [\"elements\"],\n      HTMLOptionsCollection: [\"options\"]\n    },\n    elements: {\n      Element: [\"element\"],\n      HTMLAnchorElement: [\"a\"],\n      HTMLAppletElement: [\"applet\"],\n      HTMLAreaElement: [\"area\"],\n      HTMLAttachmentElement: [\"attachment\"],\n      HTMLAudioElement: [\"audio\"],\n      HTMLBRElement: [\"br\"],\n      HTMLBaseElement: [\"base\"],\n      HTMLBodyElement: [\"body\"],\n      HTMLButtonElement: [\"button\"],\n      HTMLCanvasElement: [\"canvas\"],\n      HTMLContentElement: [\"content\"],\n      HTMLDListElement: [\"dl\"],\n      HTMLDataElement: [\"data\"],\n      HTMLDataListElement: [\"datalist\"],\n      HTMLDetailsElement: [\"details\"],\n      HTMLDialogElement: [\"dialog\"],\n      HTMLDirectoryElement: [\"dir\"],\n      HTMLDivElement: [\"div\"],\n      HTMLDocument: [\"document\"],\n      HTMLElement: [\"element\", \"abbr\", \"address\", \"article\", \"aside\", \"b\", \"bdi\", \"bdo\", \"cite\", \"code\", \"command\", \"dd\", \"dfn\", \"dt\", \"em\", \"figcaption\", \"figure\", \"footer\", \"header\", \"i\", \"kbd\", \"mark\", \"nav\", \"noscript\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"section\", \"small\", \"strong\", \"sub\", \"summary\", \"sup\", \"u\", \"var\", \"wbr\"],\n      HTMLEmbedElement: [\"embed\"],\n      HTMLFieldSetElement: [\"fieldset\"],\n      HTMLFontElement: [\"font\"],\n      HTMLFormElement: [\"form\"],\n      HTMLFrameElement: [\"frame\"],\n      HTMLFrameSetElement: [\"frameset\"],\n      HTMLHRElement: [\"hr\"],\n      HTMLHeadElement: [\"head\"],\n      HTMLHeadingElement: [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],\n      HTMLHtmlElement: [\"html\"],\n      HTMLIFrameElement: [\"iframe\"],\n      HTMLImageElement: [\"img\"],\n      HTMLInputElement: [\"input\"],\n      HTMLKeygenElement: [\"keygen\"],\n      HTMLLIElement: [\"li\"],\n      HTMLLabelElement: [\"label\"],\n      HTMLLegendElement: [\"legend\"],\n      HTMLLinkElement: [\"link\"],\n      HTMLMapElement: [\"map\"],\n      HTMLMarqueeElement: [\"marquee\"],\n      HTMLMediaElement: [\"media\"],\n      HTMLMenuElement: [\"menu\"],\n      HTMLMenuItemElement: [\"menuitem\"],\n      HTMLMetaElement: [\"meta\"],\n      HTMLMeterElement: [\"meter\"],\n      HTMLModElement: [\"del\", \"ins\"],\n      HTMLOListElement: [\"ol\"],\n      HTMLObjectElement: [\"object\"],\n      HTMLOptGroupElement: [\"optgroup\"],\n      HTMLOptionElement: [\"option\"],\n      HTMLOutputElement: [\"output\"],\n      HTMLParagraphElement: [\"p\"],\n      HTMLParamElement: [\"param\"],\n      HTMLPictureElement: [\"picture\"],\n      HTMLPreElement: [\"pre\"],\n      HTMLProgressElement: [\"progress\"],\n      HTMLQuoteElement: [\"blockquote\", \"q\", \"quote\"],\n      HTMLScriptElement: [\"script\"],\n      HTMLSelectElement: [\"select\"],\n      HTMLShadowElement: [\"shadow\"],\n      HTMLSlotElement: [\"slot\"],\n      HTMLSourceElement: [\"source\"],\n      HTMLSpanElement: [\"span\"],\n      HTMLStyleElement: [\"style\"],\n      HTMLTableCaptionElement: [\"caption\"],\n      HTMLTableCellElement: [\"td\", \"th\"],\n      HTMLTableColElement: [\"col\", \"colgroup\"],\n      HTMLTableElement: [\"table\"],\n      HTMLTableRowElement: [\"tr\"],\n      HTMLTableSectionElement: [\"thead\", \"tbody\", \"tfoot\"],\n      HTMLTemplateElement: [\"template\"],\n      HTMLTextAreaElement: [\"textarea\"],\n      HTMLTimeElement: [\"time\"],\n      HTMLTitleElement: [\"title\"],\n      HTMLTrackElement: [\"track\"],\n      HTMLUListElement: [\"ul\"],\n      HTMLUnknownElement: [\"unknown\", \"vhgroupv\", \"vkeygen\"],\n      HTMLVideoElement: [\"video\"]\n    },\n    nodes: {\n      Attr: [\"node\"],\n      Audio: [\"audio\"],\n      CDATASection: [\"node\"],\n      CharacterData: [\"node\"],\n      Comment: [\"#comment\"],\n      Document: [\"#document\"],\n      DocumentFragment: [\"#document-fragment\"],\n      DocumentType: [\"node\"],\n      HTMLDocument: [\"#document\"],\n      Image: [\"img\"],\n      Option: [\"option\"],\n      ProcessingInstruction: [\"node\"],\n      ShadowRoot: [\"#shadow-root\"],\n      Text: [\"#text\"],\n      XMLDocument: [\"xml\"]\n    }\n  });\n\n  \"object\" != _typeof(t) && (t = {\n    type: t || \"auto\"\n  });\n\n  var A,\n      O,\n      N,\n      D,\n      I,\n      F,\n      S,\n      V,\n      P,\n      R = \"registerElement\",\n      U = \"__\" + R + (1e5 * e.Math.random() >> 0),\n      k = \"addEventListener\",\n      _ = \"attached\",\n      x = \"Callback\",\n      q = \"detached\",\n      B = \"extends\",\n      Z = \"attributeChanged\" + x,\n      j = _ + x,\n      G = \"connected\" + x,\n      z = \"disconnected\" + x,\n      K = \"created\" + x,\n      X = q + x,\n      $ = \"ADDITION\",\n      Q = \"REMOVAL\",\n      W = \"DOMAttrModified\",\n      Y = \"DOMContentLoaded\",\n      J = \"DOMSubtreeModified\",\n      ee = \"<\",\n      te = \"=\",\n      ne = /^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,\n      re = [\"ANNOTATION-XML\", \"COLOR-PROFILE\", \"FONT-FACE\", \"FONT-FACE-SRC\", \"FONT-FACE-URI\", \"FONT-FACE-FORMAT\", \"FONT-FACE-NAME\", \"MISSING-GLYPH\"],\n      oe = [],\n      le = [],\n      ae = \"\",\n      ie = y.documentElement,\n      ue = oe.indexOf || function (e) {\n    for (var t = this.length; t-- && this[t] !== e;) {\n      ;\n    }\n\n    return t;\n  },\n      ce = C.prototype,\n      se = ce.hasOwnProperty,\n      me = ce.isPrototypeOf,\n      fe = C.defineProperty,\n      pe = [],\n      de = C.getOwnPropertyDescriptor,\n      he = C.getOwnPropertyNames,\n      Te = C.getPrototypeOf,\n      Le = C.setPrototypeOf,\n      Me = !!C.__proto__,\n      Ee = !1,\n      ve = \"__dreCEv1\",\n      He = e.customElements,\n      ge = !/^force/.test(t.type) && !!(He && He.define && He.get && He.whenDefined),\n      be = C.create || C,\n      ye = e.Map || function () {\n    var e,\n        t = [],\n        n = [];\n    return {\n      get: function get(e) {\n        return n[ue.call(t, e)];\n      },\n      set: function set(r, o) {\n        e = ue.call(t, r), e < 0 ? n[t.push(r) - 1] = o : n[e] = o;\n      }\n    };\n  },\n      Ce = e.Promise || function (e) {\n    function t(e) {\n      for (r = !0; n.length;) {\n        n.shift()(e);\n      }\n    }\n\n    var n = [],\n        r = !1,\n        o = {\n      \"catch\": function _catch() {\n        return o;\n      },\n      then: function then(e) {\n        return n.push(e), r && setTimeout(t, 1), o;\n      }\n    };\n    return e(t), o;\n  },\n      we = !1,\n      Ae = be(null),\n      Oe = be(null),\n      Ne = new ye(),\n      De = function De(e) {\n    return e.toLowerCase();\n  },\n      Ie = C.create || function it(e) {\n    return e ? (it.prototype = e, new it()) : this;\n  },\n      Fe = Le || (Me ? function (e, t) {\n    return e.__proto__ = t, e;\n  } : he && de ? function () {\n    function e(e, t) {\n      for (var n, r = he(t), o = 0, l = r.length; o < l; o++) {\n        n = r[o], se.call(e, n) || fe(e, n, de(t, n));\n      }\n    }\n\n    return function (t, n) {\n      do {\n        e(t, n);\n      } while ((n = Te(n)) && !me.call(n, t));\n\n      return t;\n    };\n  }() : function (e, t) {\n    for (var n in t) {\n      e[n] = t[n];\n    }\n\n    return e;\n  }),\n      Se = e.MutationObserver || e.WebKitMutationObserver,\n      Ve = e.HTMLAnchorElement,\n      Pe = (e.HTMLElement || e.Element || e.Node).prototype,\n      Re = !me.call(Pe, ie),\n      Ue = Re ? function (e, t, n) {\n    return e[t] = n.value, e;\n  } : fe,\n      ke = Re ? function (e) {\n    return 1 === e.nodeType;\n  } : function (e) {\n    return me.call(Pe, e);\n  },\n      _e = Re && [],\n      xe = Pe.attachShadow,\n      qe = Pe.cloneNode,\n      Be = Pe.dispatchEvent,\n      Ze = Pe.getAttribute,\n      je = Pe.hasAttribute,\n      Ge = Pe.removeAttribute,\n      ze = Pe.setAttribute,\n      Ke = y.createElement,\n      Xe = y.importNode,\n      $e = Ke,\n      Qe = Se && {\n    attributes: !0,\n    characterData: !0,\n    attributeOldValue: !0\n  },\n      We = Se || function (e) {\n    nt = !1, ie.removeEventListener(W, We);\n  },\n      Ye = 0,\n      Je = R in y && !/^force-all/.test(t.type),\n      et = !0,\n      tt = !1,\n      nt = !0,\n      rt = !0,\n      ot = !0;\n\n  if (Se && (P = y.createElement(\"div\"), P.innerHTML = \"<div><div></div></div>\", new Se(function (e, t) {\n    if (e[0] && \"childList\" == e[0].type && !e[0].removedNodes[0].childNodes.length) {\n      P = de(Pe, \"innerHTML\");\n      var n = P && P.set;\n      n && fe(Pe, \"innerHTML\", {\n        set: function set(e) {\n          for (; this.lastChild;) {\n            this.removeChild(this.lastChild);\n          }\n\n          n.call(this, e);\n        }\n      });\n    }\n\n    t.disconnect(), P = null;\n  }).observe(P, {\n    childList: !0,\n    subtree: !0\n  }), P.innerHTML = \"\"), Je || (Le || Me ? (S = function S(e, t) {\n    me.call(t, e) || p(e, t);\n  }, V = p) : (S = function S(e, t) {\n    e[U] || (e[U] = C(!0), p(e, t));\n  }, V = S), Re ? (nt = !1, function () {\n    var e = de(Pe, k),\n        t = e.value,\n        n = function n(e) {\n      var t = new CustomEvent(W, {\n        bubbles: !0\n      });\n      t.attrName = e, t.prevValue = Ze.call(this, e), t.newValue = null, t[Q] = t.attrChange = 2, Ge.call(this, e), Be.call(this, t);\n    },\n        r = function r(e, t) {\n      var n = je.call(this, e),\n          r = n && Ze.call(this, e),\n          o = new CustomEvent(W, {\n        bubbles: !0\n      });\n      ze.call(this, e, t), o.attrName = e, o.prevValue = n ? r : null, o.newValue = t, n ? o.MODIFICATION = o.attrChange = 1 : o[$] = o.attrChange = 0, Be.call(this, o);\n    },\n        o = function o(e) {\n      var t,\n          n = e.currentTarget,\n          r = n[U],\n          o = e.propertyName;\n      r.hasOwnProperty(o) && (r = r[o], t = new CustomEvent(W, {\n        bubbles: !0\n      }), t.attrName = r.name, t.prevValue = r.value || null, t.newValue = r.value = n[o] || null, null == t.prevValue ? t[$] = t.attrChange = 0 : t.MODIFICATION = t.attrChange = 1, Be.call(n, t));\n    };\n\n    e.value = function (e, l, a) {\n      e === W && this[Z] && this.setAttribute !== r && (this[U] = {\n        className: {\n          name: \"class\",\n          value: this.className\n        }\n      }, this.setAttribute = r, this.removeAttribute = n, t.call(this, \"propertychange\", o)), t.call(this, e, l, a);\n    }, fe(Pe, k, e);\n  }()) : Se || (ie[k](W, We), ie.setAttribute(U, 1), ie.removeAttribute(U), nt && (O = function O(e) {\n    var t,\n        n,\n        r,\n        o = this;\n\n    if (o === e.target) {\n      t = o[U], o[U] = n = D(o);\n\n      for (r in n) {\n        if (!(r in t)) return N(0, o, r, t[r], n[r], $);\n        if (n[r] !== t[r]) return N(1, o, r, t[r], n[r], \"MODIFICATION\");\n      }\n\n      for (r in t) {\n        if (!(r in n)) return N(2, o, r, t[r], n[r], Q);\n      }\n    }\n  }, N = function N(e, t, n, r, o, l) {\n    var a = {\n      attrChange: e,\n      currentTarget: t,\n      attrName: n,\n      prevValue: r,\n      newValue: o\n    };\n    a[l] = e, u(a);\n  }, D = function D(e) {\n    for (var t, n, r = {}, o = e.attributes, l = 0, a = o.length; l < a; l++) {\n      t = o[l], \"setAttribute\" !== (n = t.name) && (r[n] = t.value);\n    }\n\n    return r;\n  })), y[R] = function (e, t) {\n    if (n = e.toUpperCase(), et && (et = !1, Se ? (I = function (e, t) {\n      function n(e, t) {\n        for (var n = 0, r = e.length; n < r; t(e[n++])) {\n          ;\n        }\n      }\n\n      return new Se(function (r) {\n        for (var o, l, a, i = 0, u = r.length; i < u; i++) {\n          o = r[i], \"childList\" === o.type ? (n(o.addedNodes, e), n(o.removedNodes, t)) : (l = o.target, ot && l[Z] && \"style\" !== o.attributeName && (a = Ze.call(l, o.attributeName)) !== o.oldValue && l[Z](o.attributeName, o.oldValue, a));\n        }\n      });\n    }(l(_), l(q)), F = function F(e) {\n      return I.observe(e, {\n        childList: !0,\n        subtree: !0\n      }), e;\n    }, F(y), xe && (Pe.attachShadow = function () {\n      return F(xe.apply(this, arguments));\n    })) : (A = [], y[k](\"DOMNodeInserted\", c(_)), y[k](\"DOMNodeRemoved\", c(q))), y[k](Y, s), y[k](\"readystatechange\", s), y.importNode = function (e, t) {\n      switch (e.nodeType) {\n        case 1:\n          return f(y, Xe, [e, !!t]);\n\n        case 11:\n          for (var n = y.createDocumentFragment(), r = e.childNodes, o = r.length, l = 0; l < o; l++) {\n            n.appendChild(y.importNode(r[l], !!t));\n          }\n\n          return n;\n\n        default:\n          return qe.call(e, !!t);\n      }\n    }, Pe.cloneNode = function (e) {\n      return f(this, qe, [!!e]);\n    }), tt) return tt = !1;\n    if (-2 < ue.call(oe, te + n) + ue.call(oe, ee + n) && h(e), !ne.test(n) || -1 < ue.call(re, n)) throw new Error(\"The type \" + e + \" is invalid\");\n\n    var n,\n        o,\n        a = function a() {\n      return u ? y.createElement(m, n) : y.createElement(m);\n    },\n        i = t || ce,\n        u = se.call(i, B),\n        m = u ? t[B].toUpperCase() : n;\n\n    return u && -1 < ue.call(oe, ee + m) && h(m), o = oe.push((u ? te : ee) + n) - 1, ae = ae.concat(ae.length ? \",\" : \"\", u ? m + '[is=\"' + e.toLowerCase() + '\"]' : m), a.prototype = le[o] = se.call(i, \"prototype\") ? i.prototype : Ie(Pe), ae.length && r(y.querySelectorAll(ae), _), a;\n  }, y.createElement = $e = function $e(e, t) {\n    var n = v(t),\n        r = n ? Ke.call(y, e, De(n)) : Ke.call(y, e),\n        o = \"\" + e,\n        l = ue.call(oe, (n ? te : ee) + (n || o).toUpperCase()),\n        a = -1 < l;\n    return n && (r.setAttribute(\"is\", n = n.toLowerCase()), a && (a = i(o.toUpperCase(), n))), ot = !y.createElement.innerHTMLHelper, a && V(r, le[l]), r;\n  }), L.prototype = {\n    constructor: L,\n    define: ge ? function (e, t, n) {\n      if (n) M(e, t, n);else {\n        var r = e.toUpperCase();\n        Ae[r] = {\n          constructor: t,\n          create: [r]\n        }, Ne.set(t, r), He.define(e, t);\n      }\n    } : M,\n    get: ge ? function (e) {\n      return He.get(e) || E(e);\n    } : E,\n    whenDefined: ge ? function (e) {\n      return Ce.race([He.whenDefined(e), g(e)]);\n    } : g\n  }, !He || /^force/.test(t.type)) b();else if (!t.noBuiltIn) try {\n    !function (t, n, r) {\n      var o = new RegExp(\"^<a\\\\s+is=('|\\\")\" + r + \"\\\\1></a>$\");\n      if (n[B] = \"a\", t.prototype = Ie(Ve.prototype), t.prototype.constructor = t, e.customElements.define(r, t, n), !o.test(y.createElement(\"a\", {\n        is: r\n      }).outerHTML) || !o.test(new t().outerHTML)) throw n;\n    }(function ut() {\n      return Reflect.construct(Ve, [], ut);\n    }, {}, \"document-register-element-a\");\n  } catch (lt) {\n    b();\n  }\n  if (!t.noBuiltIn) try {\n    if (Ke.call(y, \"a\", \"a\").outerHTML.indexOf(\"is\") < 0) throw {};\n  } catch (at) {\n    De = function De(e) {\n      return {\n        is: e.toLowerCase()\n      };\n    };\n  }\n}(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC9idWlsZC9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50LmpzPzI4OWUiXSwibmFtZXMiOlsiZSIsInQiLCJuIiwiQSIsInNwbGljZSIsImxlbmd0aCIsIlllIiwic2hpZnQiLCJjYWxsIiwiciIsIlQiLCJvIiwiViIsImxlIiwiYSIsImwiLCJrZSIsImFlIiwicXVlcnlTZWxlY3RvckFsbCIsIlplIiwibm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInVlIiwib2UiLCJ0ZSIsImVlIiwiaSIsImluZGV4T2YiLCJ1IiwiY3VycmVudFRhcmdldCIsImF0dHJDaGFuZ2UiLCJhdHRyTmFtZSIsInRhcmdldCIsIiQiLCJRIiwib3QiLCJaIiwicHJldlZhbHVlIiwibmV3VmFsdWUiLCJjIiwicHVzaCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJzIiwicnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiWSIsInkiLCJkZXRhaWwiLCJxIiwiXyIsIlJlIiwiZCIsIm0iLCJ6ZSIsIk8iLCJmIiwiYXBwbHkiLCJwb3AiLCJwIiwiRmUiLCJJIiwib2JzZXJ2ZSIsIlFlIiwibnQiLCJzZXRBdHRyaWJ1dGUiLCJVIiwiRCIsImsiLCJKIiwiVyIsIksiLCJjcmVhdGVkIiwiX2UiLCJpZSIsImNvbnRhaW5zIiwiaCIsIkVycm9yIiwiUyIsIngiLCJMIiwiTSIsIkIiLCJwcm90b3R5cGUiLCJJZSIsIm9ic2VydmVkQXR0cmlidXRlcyIsInBlIiwiVWUiLCJ2YWx1ZSIsIndlIiwidmUiLCJBZSIsIk5lIiwiZ2V0IiwiZ2UiLCJjcmVhdGUiLCJIIiwiYXJndW1lbnRzIiwiRyIsImoiLCJ6IiwiWCIsImNvbnN0cnVjdG9yIiwiRGUiLCJzZXQiLCJSIiwidG9Mb3dlckNhc2UiLCJnIiwiT2UiLCJFIiwidiIsImlzIiwiYXR0cmlidXRlcyIsIm5hbWUiLCJub2RlVmFsdWUiLCJDZSIsImIiLCJIZSIsImN1c3RvbUVsZW1lbnRzIiwiZmUiLCJjb25maWd1cmFibGUiLCJ3IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImNyZWF0ZUVsZW1lbnQiLCJFZSIsIiRlIiwiSmUiLCJ0dCIsImRvY3VtZW50IiwiQyIsIk9iamVjdCIsInRlc3QiLCJjb25jYXQiLCJjb2xsZWN0aW9ucyIsIkhUTUxBbGxDb2xsZWN0aW9uIiwiSFRNTENvbGxlY3Rpb24iLCJIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbiIsIkhUTUxPcHRpb25zQ29sbGVjdGlvbiIsImVsZW1lbnRzIiwiRWxlbWVudCIsIkhUTUxBbmNob3JFbGVtZW50IiwiSFRNTEFwcGxldEVsZW1lbnQiLCJIVE1MQXJlYUVsZW1lbnQiLCJIVE1MQXR0YWNobWVudEVsZW1lbnQiLCJIVE1MQXVkaW9FbGVtZW50IiwiSFRNTEJSRWxlbWVudCIsIkhUTUxCYXNlRWxlbWVudCIsIkhUTUxCb2R5RWxlbWVudCIsIkhUTUxCdXR0b25FbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJIVE1MQ29udGVudEVsZW1lbnQiLCJIVE1MRExpc3RFbGVtZW50IiwiSFRNTERhdGFFbGVtZW50IiwiSFRNTERhdGFMaXN0RWxlbWVudCIsIkhUTUxEZXRhaWxzRWxlbWVudCIsIkhUTUxEaWFsb2dFbGVtZW50IiwiSFRNTERpcmVjdG9yeUVsZW1lbnQiLCJIVE1MRGl2RWxlbWVudCIsIkhUTUxEb2N1bWVudCIsIkhUTUxFbGVtZW50IiwiSFRNTEVtYmVkRWxlbWVudCIsIkhUTUxGaWVsZFNldEVsZW1lbnQiLCJIVE1MRm9udEVsZW1lbnQiLCJIVE1MRm9ybUVsZW1lbnQiLCJIVE1MRnJhbWVFbGVtZW50IiwiSFRNTEZyYW1lU2V0RWxlbWVudCIsIkhUTUxIUkVsZW1lbnQiLCJIVE1MSGVhZEVsZW1lbnQiLCJIVE1MSGVhZGluZ0VsZW1lbnQiLCJIVE1MSHRtbEVsZW1lbnQiLCJIVE1MSUZyYW1lRWxlbWVudCIsIkhUTUxJbWFnZUVsZW1lbnQiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTEtleWdlbkVsZW1lbnQiLCJIVE1MTElFbGVtZW50IiwiSFRNTExhYmVsRWxlbWVudCIsIkhUTUxMZWdlbmRFbGVtZW50IiwiSFRNTExpbmtFbGVtZW50IiwiSFRNTE1hcEVsZW1lbnQiLCJIVE1MTWFycXVlZUVsZW1lbnQiLCJIVE1MTWVkaWFFbGVtZW50IiwiSFRNTE1lbnVFbGVtZW50IiwiSFRNTE1lbnVJdGVtRWxlbWVudCIsIkhUTUxNZXRhRWxlbWVudCIsIkhUTUxNZXRlckVsZW1lbnQiLCJIVE1MTW9kRWxlbWVudCIsIkhUTUxPTGlzdEVsZW1lbnQiLCJIVE1MT2JqZWN0RWxlbWVudCIsIkhUTUxPcHRHcm91cEVsZW1lbnQiLCJIVE1MT3B0aW9uRWxlbWVudCIsIkhUTUxPdXRwdXRFbGVtZW50IiwiSFRNTFBhcmFncmFwaEVsZW1lbnQiLCJIVE1MUGFyYW1FbGVtZW50IiwiSFRNTFBpY3R1cmVFbGVtZW50IiwiSFRNTFByZUVsZW1lbnQiLCJIVE1MUHJvZ3Jlc3NFbGVtZW50IiwiSFRNTFF1b3RlRWxlbWVudCIsIkhUTUxTY3JpcHRFbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJIVE1MU2hhZG93RWxlbWVudCIsIkhUTUxTbG90RWxlbWVudCIsIkhUTUxTb3VyY2VFbGVtZW50IiwiSFRNTFNwYW5FbGVtZW50IiwiSFRNTFN0eWxlRWxlbWVudCIsIkhUTUxUYWJsZUNhcHRpb25FbGVtZW50IiwiSFRNTFRhYmxlQ2VsbEVsZW1lbnQiLCJIVE1MVGFibGVDb2xFbGVtZW50IiwiSFRNTFRhYmxlRWxlbWVudCIsIkhUTUxUYWJsZVJvd0VsZW1lbnQiLCJIVE1MVGFibGVTZWN0aW9uRWxlbWVudCIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiSFRNTFRpbWVFbGVtZW50IiwiSFRNTFRpdGxlRWxlbWVudCIsIkhUTUxUcmFja0VsZW1lbnQiLCJIVE1MVUxpc3RFbGVtZW50IiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTFZpZGVvRWxlbWVudCIsIm5vZGVzIiwiQXR0ciIsIkF1ZGlvIiwiQ0RBVEFTZWN0aW9uIiwiQ2hhcmFjdGVyRGF0YSIsIkNvbW1lbnQiLCJEb2N1bWVudCIsIkRvY3VtZW50RnJhZ21lbnQiLCJEb2N1bWVudFR5cGUiLCJJbWFnZSIsIk9wdGlvbiIsIlByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsIlNoYWRvd1Jvb3QiLCJUZXh0IiwiWE1MRG9jdW1lbnQiLCJ0eXBlIiwiTiIsIkYiLCJQIiwiTWF0aCIsInJhbmRvbSIsIm5lIiwicmUiLCJkb2N1bWVudEVsZW1lbnQiLCJjZSIsInNlIiwiaGFzT3duUHJvcGVydHkiLCJtZSIsImlzUHJvdG90eXBlT2YiLCJkZWZpbmVQcm9wZXJ0eSIsImRlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaGUiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiVGUiLCJnZXRQcm90b3R5cGVPZiIsIkxlIiwic2V0UHJvdG90eXBlT2YiLCJNZSIsIl9fcHJvdG9fXyIsImRlZmluZSIsIndoZW5EZWZpbmVkIiwiYmUiLCJ5ZSIsIk1hcCIsIlByb21pc2UiLCJ0aGVuIiwiaXQiLCJTZSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiVmUiLCJQZSIsIk5vZGUiLCJub2RlVHlwZSIsInhlIiwiYXR0YWNoU2hhZG93IiwicWUiLCJjbG9uZU5vZGUiLCJCZSIsImRpc3BhdGNoRXZlbnQiLCJnZXRBdHRyaWJ1dGUiLCJqZSIsImhhc0F0dHJpYnV0ZSIsIkdlIiwicmVtb3ZlQXR0cmlidXRlIiwiS2UiLCJYZSIsImltcG9ydE5vZGUiLCJjaGFyYWN0ZXJEYXRhIiwiYXR0cmlidXRlT2xkVmFsdWUiLCJXZSIsImV0IiwiaW5uZXJIVE1MIiwicmVtb3ZlZE5vZGVzIiwiY2hpbGROb2RlcyIsImxhc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwiZGlzY29ubmVjdCIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJNT0RJRklDQVRJT04iLCJwcm9wZXJ0eU5hbWUiLCJjbGFzc05hbWUiLCJhZGRlZE5vZGVzIiwiYXR0cmlidXRlTmFtZSIsIm9sZFZhbHVlIiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImFwcGVuZENoaWxkIiwiaW5uZXJIVE1MSGVscGVyIiwicmFjZSIsIm5vQnVpbHRJbiIsIlJlZ0V4cCIsIm91dGVySFRNTCIsInV0IiwibHQiLCJhdCIsIndpbmRvdyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLENBQUMsVUFBU0EsQ0FBVCxFQUFXQyxDQUFYLEVBQWE7QUFBQzs7QUFBYSxXQUFTQyxDQUFULEdBQVk7QUFBQyxRQUFJRixDQUFDLEdBQUNHLENBQUMsQ0FBQ0MsTUFBRixDQUFTLENBQVQsRUFBV0QsQ0FBQyxDQUFDRSxNQUFiLENBQU47O0FBQTJCLFNBQUlDLEVBQUUsR0FBQyxDQUFQLEVBQVNOLENBQUMsQ0FBQ0ssTUFBWDtBQUFtQkwsT0FBQyxDQUFDTyxLQUFGLEdBQVVDLElBQVYsQ0FBZSxJQUFmLEVBQW9CUixDQUFDLENBQUNPLEtBQUYsRUFBcEI7QUFBbkI7QUFBa0Q7O0FBQUEsV0FBU0UsQ0FBVCxDQUFXVCxDQUFYLEVBQWFDLENBQWIsRUFBZTtBQUFDLFNBQUksSUFBSUMsQ0FBQyxHQUFDLENBQU4sRUFBUU8sQ0FBQyxHQUFDVCxDQUFDLENBQUNLLE1BQWhCLEVBQXVCSCxDQUFDLEdBQUNPLENBQXpCLEVBQTJCUCxDQUFDLEVBQTVCO0FBQStCUSxPQUFDLENBQUNWLENBQUMsQ0FBQ0UsQ0FBRCxDQUFGLEVBQU1ELENBQU4sQ0FBRDtBQUEvQjtBQUF5Qzs7QUFBQSxXQUFTVSxDQUFULENBQVdYLENBQVgsRUFBYTtBQUFDLFNBQUksSUFBSUMsQ0FBSixFQUFNQyxDQUFDLEdBQUMsQ0FBUixFQUFVTyxDQUFDLEdBQUNULENBQUMsQ0FBQ0ssTUFBbEIsRUFBeUJILENBQUMsR0FBQ08sQ0FBM0IsRUFBNkJQLENBQUMsRUFBOUI7QUFBaUNELE9BQUMsR0FBQ0QsQ0FBQyxDQUFDRSxDQUFELENBQUgsRUFBT1UsQ0FBQyxDQUFD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SixPQUFOO0FBQTJCLEtBQTFDO0FBQTJDO0FBQUMsQ0FBMzFhLENBQTQxYW9OLE1BQTUxYSxDQUFEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQvYnVpbGQvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISAoQykgQW5kcmVhIEdpYW1tYXJjaGkgLSBAV2ViUmVmbGVjdGlvbiAtIElTQyBTdHlsZSBMaWNlbnNlICovXG4hZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKCl7dmFyIGU9QS5zcGxpY2UoMCxBLmxlbmd0aCk7Zm9yKFllPTA7ZS5sZW5ndGg7KWUuc2hpZnQoKS5jYWxsKG51bGwsZS5zaGlmdCgpKX1mdW5jdGlvbiByKGUsdCl7Zm9yKHZhciBuPTAscj1lLmxlbmd0aDtuPHI7bisrKVQoZVtuXSx0KX1mdW5jdGlvbiBvKGUpe2Zvcih2YXIgdCxuPTAscj1lLmxlbmd0aDtuPHI7bisrKXQ9ZVtuXSxWKHQsbGVbYSh0KV0pfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2tlKHQpJiYoVCh0LGUpLGFlLmxlbmd0aCYmcih0LnF1ZXJ5U2VsZWN0b3JBbGwoYWUpLGUpKX19ZnVuY3Rpb24gYShlKXt2YXIgdD1aZS5jYWxsKGUsXCJpc1wiKSxuPWUubm9kZU5hbWUudG9VcHBlckNhc2UoKSxyPXVlLmNhbGwob2UsdD90ZSt0LnRvVXBwZXJDYXNlKCk6ZWUrbik7cmV0dXJuIHQmJi0xPHImJiFpKG4sdCk/LTE6cn1mdW5jdGlvbiBpKGUsdCl7cmV0dXJuLTE8YWUuaW5kZXhPZihlKydbaXM9XCInK3QrJ1wiXScpfWZ1bmN0aW9uIHUoZSl7dmFyIHQ9ZS5jdXJyZW50VGFyZ2V0LG49ZS5hdHRyQ2hhbmdlLHI9ZS5hdHRyTmFtZSxvPWUudGFyZ2V0LGw9ZVskXXx8MixhPWVbUV18fDM7IW90fHxvJiZvIT09dHx8IXRbWl18fFwic3R5bGVcIj09PXJ8fGUucHJldlZhbHVlPT09ZS5uZXdWYWx1ZSYmKFwiXCIhPT1lLm5ld1ZhbHVlfHxuIT09bCYmbiE9PWEpfHx0W1pdKHIsbj09PWw/bnVsbDplLnByZXZWYWx1ZSxuPT09YT9udWxsOmUubmV3VmFsdWUpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9bChlKTtyZXR1cm4gZnVuY3Rpb24oZSl7QS5wdXNoKHQsZS50YXJnZXQpLFllJiZjbGVhclRpbWVvdXQoWWUpLFllPXNldFRpbWVvdXQobiwxKX19ZnVuY3Rpb24gcyhlKXtydCYmKHJ0PSExLGUuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFkscykpLGFlLmxlbmd0aCYmcigoZS50YXJnZXR8fHkpLnF1ZXJ5U2VsZWN0b3JBbGwoYWUpLGUuZGV0YWlsPT09cT9xOl8pLFJlJiZkKCl9ZnVuY3Rpb24gbShlLHQpe3ZhciBuPXRoaXM7emUuY2FsbChuLGUsdCksTy5jYWxsKG4se3RhcmdldDpufSl9ZnVuY3Rpb24gZihlLHQsbil7dmFyIHI9dC5hcHBseShlLG4pLGw9YShyKTtyZXR1cm4tMTxsJiZWKHIsbGVbbF0pLG4ucG9wKCkmJmFlLmxlbmd0aCYmbyhyLnF1ZXJ5U2VsZWN0b3JBbGwoYWUpKSxyfWZ1bmN0aW9uIHAoZSx0KXtGZShlLHQpLEk/SS5vYnNlcnZlKGUsUWUpOihudCYmKGUuc2V0QXR0cmlidXRlPW0sZVtVXT1EKGUpLGVba10oSixPKSksZVtrXShXLHUpKSxlW0tdJiZvdCYmKGUuY3JlYXRlZD0hMCxlW0tdKCksZS5jcmVhdGVkPSExKX1mdW5jdGlvbiBkKCl7Zm9yKHZhciBlLHQ9MCxuPV9lLmxlbmd0aDt0PG47dCsrKWU9X2VbdF0saWUuY29udGFpbnMoZSl8fChuLS0sX2Uuc3BsaWNlKHQtLSwxKSxUKGUscSkpfWZ1bmN0aW9uIGgoZSl7dGhyb3cgbmV3IEVycm9yKFwiQSBcIitlK1wiIHR5cGUgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpfWZ1bmN0aW9uIFQoZSx0KXt2YXIgbixyLG89YShlKTstMTxvJiYoUyhlLGxlW29dKSxvPTAsdCE9PV98fGVbX10/dCE9PXF8fGVbcV18fChlW19dPSExLGVbcV09ITAscj1cImRpc2Nvbm5lY3RlZFwiLG89MSk6KGVbcV09ITEsZVtfXT0hMCxyPVwiY29ubmVjdGVkXCIsbz0xLFJlJiZ1ZS5jYWxsKF9lLGUpPDAmJl9lLnB1c2goZSkpLG8mJihuPWVbdCt4XXx8ZVtyK3hdKSYmbi5jYWxsKGUpKX1mdW5jdGlvbiBMKCl7fWZ1bmN0aW9uIE0oZSx0LG4pe3ZhciByPW4mJm5bQl18fFwiXCIsbz10LnByb3RvdHlwZSxsPUllKG8pLGE9dC5vYnNlcnZlZEF0dHJpYnV0ZXN8fHBlLGk9e3Byb3RvdHlwZTpsfTtVZShsLEsse3ZhbHVlOmZ1bmN0aW9uKCl7aWYod2Upd2U9ITE7ZWxzZSBpZighdGhpc1t2ZV0pe3RoaXNbdmVdPSEwLG5ldyB0KHRoaXMpLG9bS10mJm9bS10uY2FsbCh0aGlzKTt2YXIgZT1BZVtOZS5nZXQodCldOyghZ2V8fGUuY3JlYXRlLmxlbmd0aD4xKSYmSCh0aGlzKX19fSksVWUobCxaLHt2YWx1ZTpmdW5jdGlvbihlKXstMTx1ZS5jYWxsKGEsZSkmJm9bWl0mJm9bWl0uYXBwbHkodGhpcyxhcmd1bWVudHMpfX0pLG9bR10mJlVlKGwsaix7dmFsdWU6b1tHXX0pLG9bel0mJlVlKGwsWCx7dmFsdWU6b1t6XX0pLHImJihpW0JdPXIpLGU9ZS50b1VwcGVyQ2FzZSgpLEFlW2VdPXtjb25zdHJ1Y3Rvcjp0LGNyZWF0ZTpyP1tyLERlKGUpXTpbZV19LE5lLnNldCh0LGUpLHlbUl0oZS50b0xvd2VyQ2FzZSgpLGkpLGcoZSksT2VbZV0ucigpfWZ1bmN0aW9uIEUoZSl7dmFyIHQ9QWVbZS50b1VwcGVyQ2FzZSgpXTtyZXR1cm4gdCYmdC5jb25zdHJ1Y3Rvcn1mdW5jdGlvbiB2KGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSYmZS5pc3x8XCJcIn1mdW5jdGlvbiBIKGUpe2Zvcih2YXIgdCxuPWVbWl0scj1uP2UuYXR0cmlidXRlczpwZSxvPXIubGVuZ3RoO28tLTspdD1yW29dLG4uY2FsbChlLHQubmFtZXx8dC5ub2RlTmFtZSxudWxsLHQudmFsdWV8fHQubm9kZVZhbHVlKX1mdW5jdGlvbiBnKGUpe3JldHVybiBlPWUudG9VcHBlckNhc2UoKSxlIGluIE9lfHwoT2VbZV09e30sT2VbZV0ucD1uZXcgQ2UoZnVuY3Rpb24odCl7T2VbZV0ucj10fSkpLE9lW2VdLnB9ZnVuY3Rpb24gYigpe0hlJiZkZWxldGUgZS5jdXN0b21FbGVtZW50cyxmZShlLFwiY3VzdG9tRWxlbWVudHNcIix7Y29uZmlndXJhYmxlOiEwLHZhbHVlOm5ldyBMfSksZmUoZSxcIkN1c3RvbUVsZW1lbnRSZWdpc3RyeVwiLHtjb25maWd1cmFibGU6ITAsdmFsdWU6TH0pO2Zvcih2YXIgdD13LmdldCgvXkhUTUxbQS1aXSpbYS16XS8pLG49dC5sZW5ndGg7bi0tO2Z1bmN0aW9uKHQpe3ZhciBuPWVbdF07aWYobil7ZVt0XT1mdW5jdGlvbihlKXt2YXIgdCxyO3JldHVybiBlfHwoZT10aGlzKSxlW3ZlXXx8KHdlPSEwLHQ9QWVbTmUuZ2V0KGUuY29uc3RydWN0b3IpXSxyPWdlJiYxPT09dC5jcmVhdGUubGVuZ3RoLGU9cj9SZWZsZWN0LmNvbnN0cnVjdChuLHBlLHQuY29uc3RydWN0b3IpOnkuY3JlYXRlRWxlbWVudC5hcHBseSh5LHQuY3JlYXRlKSxlW3ZlXT0hMCx3ZT0hMSxyfHxIKGUpKSxlfSxlW3RdLnByb3RvdHlwZT1uLnByb3RvdHlwZTt0cnl7bi5wcm90b3R5cGUuY29uc3RydWN0b3I9ZVt0XX1jYXRjaChyKXtFZT0hMCxmZShuLHZlLHt2YWx1ZTplW3RdfSl9fX0odFtuXSkpO3kuY3JlYXRlRWxlbWVudD1mdW5jdGlvbihlLHQpe3ZhciBuPXYodCk7cmV0dXJuIG4/JGUuY2FsbCh0aGlzLGUsRGUobikpOiRlLmNhbGwodGhpcyxlKX0sSmV8fCh0dD0hMCx5W1JdKFwiXCIpKX12YXIgeT1lLmRvY3VtZW50LEM9ZS5PYmplY3Qsdz1mdW5jdGlvbihlKXt2YXIgdCxuLHIsbyxsPS9eW0EtWl0rW2Etel0vLGE9ZnVuY3Rpb24oZSl7dmFyIHQsbj1bXTtmb3IodCBpbiB1KWUudGVzdCh0KSYmbi5wdXNoKHQpO3JldHVybiBufSxpPWZ1bmN0aW9uKGUsdCl7KHQ9dC50b0xvd2VyQ2FzZSgpKWluIHV8fCh1W2VdPSh1W2VdfHxbXSkuY29uY2F0KHQpLHVbdF09dVt0LnRvVXBwZXJDYXNlKCldPWUpfSx1PShDLmNyZWF0ZXx8QykobnVsbCksYz17fTtmb3IobiBpbiBlKWZvcihvIGluIGVbbl0pZm9yKHI9ZVtuXVtvXSx1W29dPXIsdD0wO3Q8ci5sZW5ndGg7dCsrKXVbclt0XS50b0xvd2VyQ2FzZSgpXT11W3JbdF0udG9VcHBlckNhc2UoKV09bztyZXR1cm4gYy5nZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/dVtlXXx8KGwudGVzdChlKT9bXTpcIlwiKTphKGUpfSxjLnNldD1mdW5jdGlvbihlLHQpe3JldHVybiBsLnRlc3QoZSk/aShlLHQpOmkodCxlKSxjfSxjfSh7Y29sbGVjdGlvbnM6e0hUTUxBbGxDb2xsZWN0aW9uOltcImFsbFwiXSxIVE1MQ29sbGVjdGlvbjpbXCJmb3Jtc1wiXSxIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbjpbXCJlbGVtZW50c1wiXSxIVE1MT3B0aW9uc0NvbGxlY3Rpb246W1wib3B0aW9uc1wiXX0sZWxlbWVudHM6e0VsZW1lbnQ6W1wiZWxlbWVudFwiXSxIVE1MQW5jaG9yRWxlbWVudDpbXCJhXCJdLEhUTUxBcHBsZXRFbGVtZW50OltcImFwcGxldFwiXSxIVE1MQXJlYUVsZW1lbnQ6W1wiYXJlYVwiXSxIVE1MQXR0YWNobWVudEVsZW1lbnQ6W1wiYXR0YWNobWVudFwiXSxIVE1MQXVkaW9FbGVtZW50OltcImF1ZGlvXCJdLEhUTUxCUkVsZW1lbnQ6W1wiYnJcIl0sSFRNTEJhc2VFbGVtZW50OltcImJhc2VcIl0sSFRNTEJvZHlFbGVtZW50OltcImJvZHlcIl0sSFRNTEJ1dHRvbkVsZW1lbnQ6W1wiYnV0dG9uXCJdLEhUTUxDYW52YXNFbGVtZW50OltcImNhbnZhc1wiXSxIVE1MQ29udGVudEVsZW1lbnQ6W1wiY29udGVudFwiXSxIVE1MRExpc3RFbGVtZW50OltcImRsXCJdLEhUTUxEYXRhRWxlbWVudDpbXCJkYXRhXCJdLEhUTUxEYXRhTGlzdEVsZW1lbnQ6W1wiZGF0YWxpc3RcIl0sSFRNTERldGFpbHNFbGVtZW50OltcImRldGFpbHNcIl0sSFRNTERpYWxvZ0VsZW1lbnQ6W1wiZGlhbG9nXCJdLEhUTUxEaXJlY3RvcnlFbGVtZW50OltcImRpclwiXSxIVE1MRGl2RWxlbWVudDpbXCJkaXZcIl0sSFRNTERvY3VtZW50OltcImRvY3VtZW50XCJdLEhUTUxFbGVtZW50OltcImVsZW1lbnRcIixcImFiYnJcIixcImFkZHJlc3NcIixcImFydGljbGVcIixcImFzaWRlXCIsXCJiXCIsXCJiZGlcIixcImJkb1wiLFwiY2l0ZVwiLFwiY29kZVwiLFwiY29tbWFuZFwiLFwiZGRcIixcImRmblwiLFwiZHRcIixcImVtXCIsXCJmaWdjYXB0aW9uXCIsXCJmaWd1cmVcIixcImZvb3RlclwiLFwiaGVhZGVyXCIsXCJpXCIsXCJrYmRcIixcIm1hcmtcIixcIm5hdlwiLFwibm9zY3JpcHRcIixcInJwXCIsXCJydFwiLFwicnVieVwiLFwic1wiLFwic2FtcFwiLFwic2VjdGlvblwiLFwic21hbGxcIixcInN0cm9uZ1wiLFwic3ViXCIsXCJzdW1tYXJ5XCIsXCJzdXBcIixcInVcIixcInZhclwiLFwid2JyXCJdLEhUTUxFbWJlZEVsZW1lbnQ6W1wiZW1iZWRcIl0sSFRNTEZpZWxkU2V0RWxlbWVudDpbXCJmaWVsZHNldFwiXSxIVE1MRm9udEVsZW1lbnQ6W1wiZm9udFwiXSxIVE1MRm9ybUVsZW1lbnQ6W1wiZm9ybVwiXSxIVE1MRnJhbWVFbGVtZW50OltcImZyYW1lXCJdLEhUTUxGcmFtZVNldEVsZW1lbnQ6W1wiZnJhbWVzZXRcIl0sSFRNTEhSRWxlbWVudDpbXCJoclwiXSxIVE1MSGVhZEVsZW1lbnQ6W1wiaGVhZFwiXSxIVE1MSGVhZGluZ0VsZW1lbnQ6W1wiaDFcIixcImgyXCIsXCJoM1wiLFwiaDRcIixcImg1XCIsXCJoNlwiXSxIVE1MSHRtbEVsZW1lbnQ6W1wiaHRtbFwiXSxIVE1MSUZyYW1lRWxlbWVudDpbXCJpZnJhbWVcIl0sSFRNTEltYWdlRWxlbWVudDpbXCJpbWdcIl0sSFRNTElucHV0RWxlbWVudDpbXCJpbnB1dFwiXSxIVE1MS2V5Z2VuRWxlbWVudDpbXCJrZXlnZW5cIl0sSFRNTExJRWxlbWVudDpbXCJsaVwiXSxIVE1MTGFiZWxFbGVtZW50OltcImxhYmVsXCJdLEhUTUxMZWdlbmRFbGVtZW50OltcImxlZ2VuZFwiXSxIVE1MTGlua0VsZW1lbnQ6W1wibGlua1wiXSxIVE1MTWFwRWxlbWVudDpbXCJtYXBcIl0sSFRNTE1hcnF1ZWVFbGVtZW50OltcIm1hcnF1ZWVcIl0sSFRNTE1lZGlhRWxlbWVudDpbXCJtZWRpYVwiXSxIVE1MTWVudUVsZW1lbnQ6W1wibWVudVwiXSxIVE1MTWVudUl0ZW1FbGVtZW50OltcIm1lbnVpdGVtXCJdLEhUTUxNZXRhRWxlbWVudDpbXCJtZXRhXCJdLEhUTUxNZXRlckVsZW1lbnQ6W1wibWV0ZXJcIl0sSFRNTE1vZEVsZW1lbnQ6W1wiZGVsXCIsXCJpbnNcIl0sSFRNTE9MaXN0RWxlbWVudDpbXCJvbFwiXSxIVE1MT2JqZWN0RWxlbWVudDpbXCJvYmplY3RcIl0sSFRNTE9wdEdyb3VwRWxlbWVudDpbXCJvcHRncm91cFwiXSxIVE1MT3B0aW9uRWxlbWVudDpbXCJvcHRpb25cIl0sSFRNTE91dHB1dEVsZW1lbnQ6W1wib3V0cHV0XCJdLEhUTUxQYXJhZ3JhcGhFbGVtZW50OltcInBcIl0sSFRNTFBhcmFtRWxlbWVudDpbXCJwYXJhbVwiXSxIVE1MUGljdHVyZUVsZW1lbnQ6W1wicGljdHVyZVwiXSxIVE1MUHJlRWxlbWVudDpbXCJwcmVcIl0sSFRNTFByb2dyZXNzRWxlbWVudDpbXCJwcm9ncmVzc1wiXSxIVE1MUXVvdGVFbGVtZW50OltcImJsb2NrcXVvdGVcIixcInFcIixcInF1b3RlXCJdLEhUTUxTY3JpcHRFbGVtZW50OltcInNjcmlwdFwiXSxIVE1MU2VsZWN0RWxlbWVudDpbXCJzZWxlY3RcIl0sSFRNTFNoYWRvd0VsZW1lbnQ6W1wic2hhZG93XCJdLEhUTUxTbG90RWxlbWVudDpbXCJzbG90XCJdLEhUTUxTb3VyY2VFbGVtZW50OltcInNvdXJjZVwiXSxIVE1MU3BhbkVsZW1lbnQ6W1wic3BhblwiXSxIVE1MU3R5bGVFbGVtZW50OltcInN0eWxlXCJdLEhUTUxUYWJsZUNhcHRpb25FbGVtZW50OltcImNhcHRpb25cIl0sSFRNTFRhYmxlQ2VsbEVsZW1lbnQ6W1widGRcIixcInRoXCJdLEhUTUxUYWJsZUNvbEVsZW1lbnQ6W1wiY29sXCIsXCJjb2xncm91cFwiXSxIVE1MVGFibGVFbGVtZW50OltcInRhYmxlXCJdLEhUTUxUYWJsZVJvd0VsZW1lbnQ6W1widHJcIl0sSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ6W1widGhlYWRcIixcInRib2R5XCIsXCJ0Zm9vdFwiXSxIVE1MVGVtcGxhdGVFbGVtZW50OltcInRlbXBsYXRlXCJdLEhUTUxUZXh0QXJlYUVsZW1lbnQ6W1widGV4dGFyZWFcIl0sSFRNTFRpbWVFbGVtZW50OltcInRpbWVcIl0sSFRNTFRpdGxlRWxlbWVudDpbXCJ0aXRsZVwiXSxIVE1MVHJhY2tFbGVtZW50OltcInRyYWNrXCJdLEhUTUxVTGlzdEVsZW1lbnQ6W1widWxcIl0sSFRNTFVua25vd25FbGVtZW50OltcInVua25vd25cIixcInZoZ3JvdXB2XCIsXCJ2a2V5Z2VuXCJdLEhUTUxWaWRlb0VsZW1lbnQ6W1widmlkZW9cIl19LG5vZGVzOntBdHRyOltcIm5vZGVcIl0sQXVkaW86W1wiYXVkaW9cIl0sQ0RBVEFTZWN0aW9uOltcIm5vZGVcIl0sQ2hhcmFjdGVyRGF0YTpbXCJub2RlXCJdLENvbW1lbnQ6W1wiI2NvbW1lbnRcIl0sRG9jdW1lbnQ6W1wiI2RvY3VtZW50XCJdLERvY3VtZW50RnJhZ21lbnQ6W1wiI2RvY3VtZW50LWZyYWdtZW50XCJdLERvY3VtZW50VHlwZTpbXCJub2RlXCJdLEhUTUxEb2N1bWVudDpbXCIjZG9jdW1lbnRcIl0sSW1hZ2U6W1wiaW1nXCJdLE9wdGlvbjpbXCJvcHRpb25cIl0sUHJvY2Vzc2luZ0luc3RydWN0aW9uOltcIm5vZGVcIl0sU2hhZG93Um9vdDpbXCIjc2hhZG93LXJvb3RcIl0sVGV4dDpbXCIjdGV4dFwiXSxYTUxEb2N1bWVudDpbXCJ4bWxcIl19fSk7XCJvYmplY3RcIiE9dHlwZW9mIHQmJih0PXt0eXBlOnR8fFwiYXV0b1wifSk7dmFyIEEsTyxOLEQsSSxGLFMsVixQLFI9XCJyZWdpc3RlckVsZW1lbnRcIixVPVwiX19cIitSKygxZTUqZS5NYXRoLnJhbmRvbSgpPj4wKSxrPVwiYWRkRXZlbnRMaXN0ZW5lclwiLF89XCJhdHRhY2hlZFwiLHg9XCJDYWxsYmFja1wiLHE9XCJkZXRhY2hlZFwiLEI9XCJleHRlbmRzXCIsWj1cImF0dHJpYnV0ZUNoYW5nZWRcIit4LGo9Xyt4LEc9XCJjb25uZWN0ZWRcIit4LHo9XCJkaXNjb25uZWN0ZWRcIit4LEs9XCJjcmVhdGVkXCIreCxYPXEreCwkPVwiQURESVRJT05cIixRPVwiUkVNT1ZBTFwiLFc9XCJET01BdHRyTW9kaWZpZWRcIixZPVwiRE9NQ29udGVudExvYWRlZFwiLEo9XCJET01TdWJ0cmVlTW9kaWZpZWRcIixlZT1cIjxcIix0ZT1cIj1cIixuZT0vXltBLVpdW0EtWjAtOV0qKD86LVtBLVowLTldKykrJC8scmU9W1wiQU5OT1RBVElPTi1YTUxcIixcIkNPTE9SLVBST0ZJTEVcIixcIkZPTlQtRkFDRVwiLFwiRk9OVC1GQUNFLVNSQ1wiLFwiRk9OVC1GQUNFLVVSSVwiLFwiRk9OVC1GQUNFLUZPUk1BVFwiLFwiRk9OVC1GQUNFLU5BTUVcIixcIk1JU1NJTkctR0xZUEhcIl0sb2U9W10sbGU9W10sYWU9XCJcIixpZT15LmRvY3VtZW50RWxlbWVudCx1ZT1vZS5pbmRleE9mfHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5sZW5ndGg7dC0tJiZ0aGlzW3RdIT09ZTspO3JldHVybiB0fSxjZT1DLnByb3RvdHlwZSxzZT1jZS5oYXNPd25Qcm9wZXJ0eSxtZT1jZS5pc1Byb3RvdHlwZU9mLGZlPUMuZGVmaW5lUHJvcGVydHkscGU9W10sZGU9Qy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsaGU9Qy5nZXRPd25Qcm9wZXJ0eU5hbWVzLFRlPUMuZ2V0UHJvdG90eXBlT2YsTGU9Qy5zZXRQcm90b3R5cGVPZixNZT0hIUMuX19wcm90b19fLEVlPSExLHZlPVwiX19kcmVDRXYxXCIsSGU9ZS5jdXN0b21FbGVtZW50cyxnZT0hL15mb3JjZS8udGVzdCh0LnR5cGUpJiYhIShIZSYmSGUuZGVmaW5lJiZIZS5nZXQmJkhlLndoZW5EZWZpbmVkKSxiZT1DLmNyZWF0ZXx8Qyx5ZT1lLk1hcHx8ZnVuY3Rpb24oKXt2YXIgZSx0PVtdLG49W107cmV0dXJue2dldDpmdW5jdGlvbihlKXtyZXR1cm4gblt1ZS5jYWxsKHQsZSldfSxzZXQ6ZnVuY3Rpb24ocixvKXtlPXVlLmNhbGwodCxyKSxlPDA/blt0LnB1c2gociktMV09bzpuW2VdPW99fX0sQ2U9ZS5Qcm9taXNlfHxmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUpe2ZvcihyPSEwO24ubGVuZ3RoOyluLnNoaWZ0KCkoZSl9dmFyIG49W10scj0hMSxvPXtcImNhdGNoXCI6ZnVuY3Rpb24oKXtyZXR1cm4gb30sdGhlbjpmdW5jdGlvbihlKXtyZXR1cm4gbi5wdXNoKGUpLHImJnNldFRpbWVvdXQodCwxKSxvfX07cmV0dXJuIGUodCksb30sd2U9ITEsQWU9YmUobnVsbCksT2U9YmUobnVsbCksTmU9bmV3IHllLERlPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRvTG93ZXJDYXNlKCl9LEllPUMuY3JlYXRlfHxmdW5jdGlvbiBpdChlKXtyZXR1cm4gZT8oaXQucHJvdG90eXBlPWUsbmV3IGl0KTp0aGlzfSxGZT1MZXx8KE1lP2Z1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX06aGUmJmRlP2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbixyPWhlKHQpLG89MCxsPXIubGVuZ3RoO288bDtvKyspbj1yW29dLHNlLmNhbGwoZSxuKXx8ZmUoZSxuLGRlKHQsbikpfXJldHVybiBmdW5jdGlvbih0LG4pe2Rve2UodCxuKX13aGlsZSgobj1UZShuKSkmJiFtZS5jYWxsKG4sdCkpO3JldHVybiB0fX0oKTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiB0KWVbbl09dFtuXTtyZXR1cm4gZX0pLFNlPWUuTXV0YXRpb25PYnNlcnZlcnx8ZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLFZlPWUuSFRNTEFuY2hvckVsZW1lbnQsUGU9KGUuSFRNTEVsZW1lbnR8fGUuRWxlbWVudHx8ZS5Ob2RlKS5wcm90b3R5cGUsUmU9IW1lLmNhbGwoUGUsaWUpLFVlPVJlP2Z1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZVt0XT1uLnZhbHVlLGV9OmZlLGtlPVJlP2Z1bmN0aW9uKGUpe3JldHVybiAxPT09ZS5ub2RlVHlwZX06ZnVuY3Rpb24oZSl7cmV0dXJuIG1lLmNhbGwoUGUsZSl9LF9lPVJlJiZbXSx4ZT1QZS5hdHRhY2hTaGFkb3cscWU9UGUuY2xvbmVOb2RlLEJlPVBlLmRpc3BhdGNoRXZlbnQsWmU9UGUuZ2V0QXR0cmlidXRlLGplPVBlLmhhc0F0dHJpYnV0ZSxHZT1QZS5yZW1vdmVBdHRyaWJ1dGUsemU9UGUuc2V0QXR0cmlidXRlLEtlPXkuY3JlYXRlRWxlbWVudCxYZT15LmltcG9ydE5vZGUsJGU9S2UsUWU9U2UmJnthdHRyaWJ1dGVzOiEwLGNoYXJhY3RlckRhdGE6ITAsYXR0cmlidXRlT2xkVmFsdWU6ITB9LFdlPVNlfHxmdW5jdGlvbihlKXtudD0hMSxpZS5yZW1vdmVFdmVudExpc3RlbmVyKFcsV2UpfSxZZT0wLEplPVIgaW4geSYmIS9eZm9yY2UtYWxsLy50ZXN0KHQudHlwZSksZXQ9ITAsdHQ9ITEsbnQ9ITAscnQ9ITAsb3Q9ITA7aWYoU2UmJihQPXkuY3JlYXRlRWxlbWVudChcImRpdlwiKSxQLmlubmVySFRNTD1cIjxkaXY+PGRpdj48L2Rpdj48L2Rpdj5cIixuZXcgU2UoZnVuY3Rpb24oZSx0KXtpZihlWzBdJiZcImNoaWxkTGlzdFwiPT1lWzBdLnR5cGUmJiFlWzBdLnJlbW92ZWROb2Rlc1swXS5jaGlsZE5vZGVzLmxlbmd0aCl7UD1kZShQZSxcImlubmVySFRNTFwiKTt2YXIgbj1QJiZQLnNldDtuJiZmZShQZSxcImlubmVySFRNTFwiLHtzZXQ6ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLmxhc3RDaGlsZDspdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmxhc3RDaGlsZCk7bi5jYWxsKHRoaXMsZSl9fSl9dC5kaXNjb25uZWN0KCksUD1udWxsfSkub2JzZXJ2ZShQLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pLFAuaW5uZXJIVE1MPVwiXCIpLEplfHwoTGV8fE1lPyhTPWZ1bmN0aW9uKGUsdCl7bWUuY2FsbCh0LGUpfHxwKGUsdCl9LFY9cCk6KFM9ZnVuY3Rpb24oZSx0KXtlW1VdfHwoZVtVXT1DKCEwKSxwKGUsdCkpfSxWPVMpLFJlPyhudD0hMSxmdW5jdGlvbigpe3ZhciBlPWRlKFBlLGspLHQ9ZS52YWx1ZSxuPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBDdXN0b21FdmVudChXLHtidWJibGVzOiEwfSk7dC5hdHRyTmFtZT1lLHQucHJldlZhbHVlPVplLmNhbGwodGhpcyxlKSx0Lm5ld1ZhbHVlPW51bGwsdFtRXT10LmF0dHJDaGFuZ2U9MixHZS5jYWxsKHRoaXMsZSksQmUuY2FsbCh0aGlzLHQpfSxyPWZ1bmN0aW9uKGUsdCl7dmFyIG49amUuY2FsbCh0aGlzLGUpLHI9biYmWmUuY2FsbCh0aGlzLGUpLG89bmV3IEN1c3RvbUV2ZW50KFcse2J1YmJsZXM6ITB9KTt6ZS5jYWxsKHRoaXMsZSx0KSxvLmF0dHJOYW1lPWUsby5wcmV2VmFsdWU9bj9yOm51bGwsby5uZXdWYWx1ZT10LG4/by5NT0RJRklDQVRJT049by5hdHRyQ2hhbmdlPTE6b1skXT1vLmF0dHJDaGFuZ2U9MCxCZS5jYWxsKHRoaXMsbyl9LG89ZnVuY3Rpb24oZSl7dmFyIHQsbj1lLmN1cnJlbnRUYXJnZXQscj1uW1VdLG89ZS5wcm9wZXJ0eU5hbWU7ci5oYXNPd25Qcm9wZXJ0eShvKSYmKHI9cltvXSx0PW5ldyBDdXN0b21FdmVudChXLHtidWJibGVzOiEwfSksdC5hdHRyTmFtZT1yLm5hbWUsdC5wcmV2VmFsdWU9ci52YWx1ZXx8bnVsbCx0Lm5ld1ZhbHVlPXIudmFsdWU9bltvXXx8bnVsbCxudWxsPT10LnByZXZWYWx1ZT90WyRdPXQuYXR0ckNoYW5nZT0wOnQuTU9ESUZJQ0FUSU9OPXQuYXR0ckNoYW5nZT0xLEJlLmNhbGwobix0KSl9O2UudmFsdWU9ZnVuY3Rpb24oZSxsLGEpe2U9PT1XJiZ0aGlzW1pdJiZ0aGlzLnNldEF0dHJpYnV0ZSE9PXImJih0aGlzW1VdPXtjbGFzc05hbWU6e25hbWU6XCJjbGFzc1wiLHZhbHVlOnRoaXMuY2xhc3NOYW1lfX0sdGhpcy5zZXRBdHRyaWJ1dGU9cix0aGlzLnJlbW92ZUF0dHJpYnV0ZT1uLHQuY2FsbCh0aGlzLFwicHJvcGVydHljaGFuZ2VcIixvKSksdC5jYWxsKHRoaXMsZSxsLGEpfSxmZShQZSxrLGUpfSgpKTpTZXx8KGllW2tdKFcsV2UpLGllLnNldEF0dHJpYnV0ZShVLDEpLGllLnJlbW92ZUF0dHJpYnV0ZShVKSxudCYmKE89ZnVuY3Rpb24oZSl7dmFyIHQsbixyLG89dGhpcztpZihvPT09ZS50YXJnZXQpe3Q9b1tVXSxvW1VdPW49RChvKTtmb3IociBpbiBuKXtpZighKHIgaW4gdCkpcmV0dXJuIE4oMCxvLHIsdFtyXSxuW3JdLCQpO2lmKG5bcl0hPT10W3JdKXJldHVybiBOKDEsbyxyLHRbcl0sbltyXSxcIk1PRElGSUNBVElPTlwiKX1mb3IociBpbiB0KWlmKCEociBpbiBuKSlyZXR1cm4gTigyLG8scix0W3JdLG5bcl0sUSl9fSxOPWZ1bmN0aW9uKGUsdCxuLHIsbyxsKXt2YXIgYT17YXR0ckNoYW5nZTplLGN1cnJlbnRUYXJnZXQ6dCxhdHRyTmFtZTpuLHByZXZWYWx1ZTpyLG5ld1ZhbHVlOm99O2FbbF09ZSx1KGEpfSxEPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuLHI9e30sbz1lLmF0dHJpYnV0ZXMsbD0wLGE9by5sZW5ndGg7bDxhO2wrKyl0PW9bbF0sXCJzZXRBdHRyaWJ1dGVcIiE9PShuPXQubmFtZSkmJihyW25dPXQudmFsdWUpO3JldHVybiByfSkpLHlbUl09ZnVuY3Rpb24oZSx0KXtpZihuPWUudG9VcHBlckNhc2UoKSxldCYmKGV0PSExLFNlPyhJPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGg7bjxyO3QoZVtuKytdKSk7fXJldHVybiBuZXcgU2UoZnVuY3Rpb24ocil7Zm9yKHZhciBvLGwsYSxpPTAsdT1yLmxlbmd0aDtpPHU7aSsrKW89cltpXSxcImNoaWxkTGlzdFwiPT09by50eXBlPyhuKG8uYWRkZWROb2RlcyxlKSxuKG8ucmVtb3ZlZE5vZGVzLHQpKToobD1vLnRhcmdldCxvdCYmbFtaXSYmXCJzdHlsZVwiIT09by5hdHRyaWJ1dGVOYW1lJiYoYT1aZS5jYWxsKGwsby5hdHRyaWJ1dGVOYW1lKSkhPT1vLm9sZFZhbHVlJiZsW1pdKG8uYXR0cmlidXRlTmFtZSxvLm9sZFZhbHVlLGEpKX0pfShsKF8pLGwocSkpLEY9ZnVuY3Rpb24oZSl7cmV0dXJuIEkub2JzZXJ2ZShlLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pLGV9LEYoeSkseGUmJihQZS5hdHRhY2hTaGFkb3c9ZnVuY3Rpb24oKXtyZXR1cm4gRih4ZS5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSkpOihBPVtdLHlba10oXCJET01Ob2RlSW5zZXJ0ZWRcIixjKF8pKSx5W2tdKFwiRE9NTm9kZVJlbW92ZWRcIixjKHEpKSkseVtrXShZLHMpLHlba10oXCJyZWFkeXN0YXRlY2hhbmdlXCIscykseS5pbXBvcnROb2RlPWZ1bmN0aW9uKGUsdCl7c3dpdGNoKGUubm9kZVR5cGUpe2Nhc2UgMTpyZXR1cm4gZih5LFhlLFtlLCEhdF0pO2Nhc2UgMTE6Zm9yKHZhciBuPXkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHI9ZS5jaGlsZE5vZGVzLG89ci5sZW5ndGgsbD0wO2w8bztsKyspbi5hcHBlbmRDaGlsZCh5LmltcG9ydE5vZGUocltsXSwhIXQpKTtyZXR1cm4gbjtkZWZhdWx0OnJldHVybiBxZS5jYWxsKGUsISF0KX19LFBlLmNsb25lTm9kZT1mdW5jdGlvbihlKXtyZXR1cm4gZih0aGlzLHFlLFshIWVdKX0pLHR0KXJldHVybiB0dD0hMTtpZigtMjx1ZS5jYWxsKG9lLHRlK24pK3VlLmNhbGwob2UsZWUrbikmJmgoZSksIW5lLnRlc3Qobil8fC0xPHVlLmNhbGwocmUsbikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR5cGUgXCIrZStcIiBpcyBpbnZhbGlkXCIpO3ZhciBuLG8sYT1mdW5jdGlvbigpe3JldHVybiB1P3kuY3JlYXRlRWxlbWVudChtLG4pOnkuY3JlYXRlRWxlbWVudChtKX0saT10fHxjZSx1PXNlLmNhbGwoaSxCKSxtPXU/dFtCXS50b1VwcGVyQ2FzZSgpOm47cmV0dXJuIHUmJi0xPHVlLmNhbGwob2UsZWUrbSkmJmgobSksbz1vZS5wdXNoKCh1P3RlOmVlKStuKS0xLGFlPWFlLmNvbmNhdChhZS5sZW5ndGg/XCIsXCI6XCJcIix1P20rJ1tpcz1cIicrZS50b0xvd2VyQ2FzZSgpKydcIl0nOm0pLGEucHJvdG90eXBlPWxlW29dPXNlLmNhbGwoaSxcInByb3RvdHlwZVwiKT9pLnByb3RvdHlwZTpJZShQZSksYWUubGVuZ3RoJiZyKHkucXVlcnlTZWxlY3RvckFsbChhZSksXyksYX0seS5jcmVhdGVFbGVtZW50PSRlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dih0KSxyPW4/S2UuY2FsbCh5LGUsRGUobikpOktlLmNhbGwoeSxlKSxvPVwiXCIrZSxsPXVlLmNhbGwob2UsKG4/dGU6ZWUpKyhufHxvKS50b1VwcGVyQ2FzZSgpKSxhPS0xPGw7cmV0dXJuIG4mJihyLnNldEF0dHJpYnV0ZShcImlzXCIsbj1uLnRvTG93ZXJDYXNlKCkpLGEmJihhPWkoby50b1VwcGVyQ2FzZSgpLG4pKSksb3Q9IXkuY3JlYXRlRWxlbWVudC5pbm5lckhUTUxIZWxwZXIsYSYmVihyLGxlW2xdKSxyfSksTC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOkwsZGVmaW5lOmdlP2Z1bmN0aW9uKGUsdCxuKXtpZihuKU0oZSx0LG4pO2Vsc2V7dmFyIHI9ZS50b1VwcGVyQ2FzZSgpO0FlW3JdPXtjb25zdHJ1Y3Rvcjp0LGNyZWF0ZTpbcl19LE5lLnNldCh0LHIpLEhlLmRlZmluZShlLHQpfX06TSxnZXQ6Z2U/ZnVuY3Rpb24oZSl7cmV0dXJuIEhlLmdldChlKXx8RShlKX06RSx3aGVuRGVmaW5lZDpnZT9mdW5jdGlvbihlKXtyZXR1cm4gQ2UucmFjZShbSGUud2hlbkRlZmluZWQoZSksZyhlKV0pfTpnfSwhSGV8fC9eZm9yY2UvLnRlc3QodC50eXBlKSliKCk7ZWxzZSBpZighdC5ub0J1aWx0SW4pdHJ5eyFmdW5jdGlvbih0LG4scil7dmFyIG89bmV3IFJlZ0V4cChcIl48YVxcXFxzK2lzPSgnfFxcXCIpXCIrcitcIlxcXFwxPjwvYT4kXCIpO2lmKG5bQl09XCJhXCIsdC5wcm90b3R5cGU9SWUoVmUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LGUuY3VzdG9tRWxlbWVudHMuZGVmaW5lKHIsdCxuKSwhby50ZXN0KHkuY3JlYXRlRWxlbWVudChcImFcIix7aXM6cn0pLm91dGVySFRNTCl8fCFvLnRlc3QoKG5ldyB0KS5vdXRlckhUTUwpKXRocm93IG59KGZ1bmN0aW9uIHV0KCl7cmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KFZlLFtdLHV0KX0se30sXCJkb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50LWFcIil9Y2F0Y2gobHQpe2IoKX1pZighdC5ub0J1aWx0SW4pdHJ5e2lmKEtlLmNhbGwoeSxcImFcIixcImFcIikub3V0ZXJIVE1MLmluZGV4T2YoXCJpc1wiKTwwKXRocm93e319Y2F0Y2goYXQpe0RlPWZ1bmN0aW9uKGUpe3JldHVybntpczplLnRvTG93ZXJDYXNlKCl9fX19KHdpbmRvdyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/document-register-element/build/document-register-element.js\n");

/***/ })

}]);